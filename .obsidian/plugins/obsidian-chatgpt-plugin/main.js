/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// ../../node_modules/decamelize/index.js
var require_decamelize = __commonJS({
  "../../node_modules/decamelize/index.js"(exports, module2) {
    "use strict";
    module2.exports = function(str, sep) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      sep = typeof sep === "undefined" ? "_" : sep;
      return str.replace(/([a-z\d])([A-Z])/g, "$1" + sep + "$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1" + sep + "$2").toLowerCase();
    };
  }
});

// ../../node_modules/camelcase/index.js
var require_camelcase = __commonJS({
  "../../node_modules/camelcase/index.js"(exports, module2) {
    "use strict";
    var UPPERCASE = /[\p{Lu}]/u;
    var LOWERCASE = /[\p{Ll}]/u;
    var LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
    var IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
    var SEPARATORS = /[_.\- ]+/;
    var LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source);
    var SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
    var NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu");
    var preserveCamelCase = (string, toLowerCase, toUpperCase) => {
      let isLastCharLower = false;
      let isLastCharUpper = false;
      let isLastLastCharUpper = false;
      for (let i = 0; i < string.length; i++) {
        const character = string[i];
        if (isLastCharLower && UPPERCASE.test(character)) {
          string = string.slice(0, i) + "-" + string.slice(i);
          isLastCharLower = false;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = true;
          i++;
        } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character)) {
          string = string.slice(0, i - 1) + "-" + string.slice(i - 1);
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = false;
          isLastCharLower = true;
        } else {
          isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
        }
      }
      return string;
    };
    var preserveConsecutiveUppercase = (input, toLowerCase) => {
      LEADING_CAPITAL.lastIndex = 0;
      return input.replace(LEADING_CAPITAL, (m1) => toLowerCase(m1));
    };
    var postProcess = (input, toUpperCase) => {
      SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
      NUMBERS_AND_IDENTIFIER.lastIndex = 0;
      return input.replace(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier)).replace(NUMBERS_AND_IDENTIFIER, (m) => toUpperCase(m));
    };
    var camelCase2 = (input, options) => {
      if (!(typeof input === "string" || Array.isArray(input))) {
        throw new TypeError("Expected the input to be `string | string[]`");
      }
      options = {
        pascalCase: false,
        preserveConsecutiveUppercase: false,
        ...options
      };
      if (Array.isArray(input)) {
        input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
      } else {
        input = input.trim();
      }
      if (input.length === 0) {
        return "";
      }
      const toLowerCase = options.locale === false ? (string) => string.toLowerCase() : (string) => string.toLocaleLowerCase(options.locale);
      const toUpperCase = options.locale === false ? (string) => string.toUpperCase() : (string) => string.toLocaleUpperCase(options.locale);
      if (input.length === 1) {
        return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
      }
      const hasUpperCase = input !== toLowerCase(input);
      if (hasUpperCase) {
        input = preserveCamelCase(input, toLowerCase, toUpperCase);
      }
      input = input.replace(LEADING_SEPARATORS, "");
      if (options.preserveConsecutiveUppercase) {
        input = preserveConsecutiveUppercase(input, toLowerCase);
      } else {
        input = toLowerCase(input);
      }
      if (options.pascalCase) {
        input = toUpperCase(input.charAt(0)) + input.slice(1);
      }
      return postProcess(input, toUpperCase);
    };
    module2.exports = camelCase2;
    module2.exports.default = camelCase2;
  }
});

// ../../node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "../../node_modules/ansi-styles/index.js"(exports, module2) {
    "use strict";
    var ANSI_BACKGROUND_OFFSET = 10;
    var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
    var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles2 = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          overline: [53, 55],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles2.color.gray = styles2.color.blackBright;
      styles2.bgColor.bgGray = styles2.bgColor.bgBlackBright;
      styles2.color.grey = styles2.color.blackBright;
      styles2.bgColor.bgGrey = styles2.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles2)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles2[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles2[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles2, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles2, "codes", {
        value: codes,
        enumerable: false
      });
      styles2.color.close = "\x1B[39m";
      styles2.bgColor.close = "\x1B[49m";
      styles2.color.ansi256 = wrapAnsi256();
      styles2.color.ansi16m = wrapAnsi16m();
      styles2.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
      styles2.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
      Object.defineProperties(styles2, {
        rgbToAnsi256: {
          value: (red, green, blue) => {
            if (red === green && green === blue) {
              if (red < 8) {
                return 16;
              }
              if (red > 248) {
                return 231;
              }
              return Math.round((red - 8) / 247 * 24) + 232;
            }
            return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
          },
          enumerable: false
        },
        hexToRgb: {
          value: (hex) => {
            const matches = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex.toString(16));
            if (!matches) {
              return [0, 0, 0];
            }
            let { colorString } = matches.groups;
            if (colorString.length === 3) {
              colorString = colorString.split("").map((character) => character + character).join("");
            }
            const integer = Number.parseInt(colorString, 16);
            return [
              integer >> 16 & 255,
              integer >> 8 & 255,
              integer & 255
            ];
          },
          enumerable: false
        },
        hexToAnsi256: {
          value: (hex) => styles2.rgbToAnsi256(...styles2.hexToRgb(hex)),
          enumerable: false
        }
      });
      return styles2;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// ../../node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "../../node_modules/retry/lib/retry_operation.js"(exports, module2) {
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self2 = this;
      this._timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// ../../node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "../../node_modules/retry/lib/retry.js"(exports) {
    var RetryOperation = require_retry_operation();
    exports.operation = function(options) {
      var timeouts = exports.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && (options.forever || options.retries === Infinity),
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = function retryWrapper(original2) {
          var op = exports.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }.bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// ../../node_modules/retry/index.js
var require_retry2 = __commonJS({
  "../../node_modules/retry/index.js"(exports, module2) {
    module2.exports = require_retry();
  }
});

// ../../node_modules/p-retry/index.js
var require_p_retry = __commonJS({
  "../../node_modules/p-retry/index.js"(exports, module2) {
    "use strict";
    var retry = require_retry2();
    var networkErrorMsgs = [
      "Failed to fetch",
      // Chrome
      "NetworkError when attempting to fetch resource.",
      // Firefox
      "The Internet connection appears to be offline.",
      // Safari
      "Network request failed"
      // `cross-fetch`
    ];
    var AbortError = class extends Error {
      constructor(message) {
        super();
        if (message instanceof Error) {
          this.originalError = message;
          ({ message } = message);
        } else {
          this.originalError = new Error(message);
          this.originalError.stack = this.stack;
        }
        this.name = "AbortError";
        this.message = message;
      }
    };
    var decorateErrorWithCounts = (error, attemptNumber, options) => {
      const retriesLeft = options.retries - (attemptNumber - 1);
      error.attemptNumber = attemptNumber;
      error.retriesLeft = retriesLeft;
      return error;
    };
    var isNetworkError = (errorMessage) => networkErrorMsgs.includes(errorMessage);
    var pRetry4 = (input, options) => new Promise((resolve, reject) => {
      options = {
        onFailedAttempt: () => {
        },
        retries: 10,
        ...options
      };
      const operation = retry.operation(options);
      operation.attempt(async (attemptNumber) => {
        try {
          resolve(await input(attemptNumber));
        } catch (error) {
          if (!(error instanceof Error)) {
            reject(new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`));
            return;
          }
          if (error instanceof AbortError) {
            operation.stop();
            reject(error.originalError);
          } else if (error instanceof TypeError && !isNetworkError(error.message)) {
            operation.stop();
            reject(error);
          } else {
            decorateErrorWithCounts(error, attemptNumber, options);
            try {
              await options.onFailedAttempt(error);
            } catch (error2) {
              reject(error2);
              return;
            }
            if (!operation.retry(error)) {
              reject(operation.mainError());
            }
          }
        }
      });
    });
    module2.exports = pRetry4;
    module2.exports.default = pRetry4;
    module2.exports.AbortError = AbortError;
  }
});

// ../../node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "../../node_modules/eventemitter3/index.js"(exports, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix;
    EventEmitter.EventEmitter = EventEmitter;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter;
    }
  }
});

// ../../node_modules/p-finally/index.js
var require_p_finally = __commonJS({
  "../../node_modules/p-finally/index.js"(exports, module2) {
    "use strict";
    module2.exports = (promise, onFinally) => {
      onFinally = onFinally || (() => {
      });
      return promise.then(
        (val) => new Promise((resolve) => {
          resolve(onFinally());
        }).then(() => val),
        (err) => new Promise((resolve) => {
          resolve(onFinally());
        }).then(() => {
          throw err;
        })
      );
    };
  }
});

// ../../node_modules/p-timeout/index.js
var require_p_timeout = __commonJS({
  "../../node_modules/p-timeout/index.js"(exports, module2) {
    "use strict";
    var pFinally = require_p_finally();
    var TimeoutError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "TimeoutError";
      }
    };
    var pTimeout = (promise, milliseconds, fallback) => new Promise((resolve, reject) => {
      if (typeof milliseconds !== "number" || milliseconds < 0) {
        throw new TypeError("Expected `milliseconds` to be a positive number");
      }
      if (milliseconds === Infinity) {
        resolve(promise);
        return;
      }
      const timer = setTimeout(() => {
        if (typeof fallback === "function") {
          try {
            resolve(fallback());
          } catch (error) {
            reject(error);
          }
          return;
        }
        const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
        const timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        reject(timeoutError);
      }, milliseconds);
      pFinally(
        // eslint-disable-next-line promise/prefer-await-to-then
        promise.then(resolve, reject),
        () => {
          clearTimeout(timer);
        }
      );
    });
    module2.exports = pTimeout;
    module2.exports.default = pTimeout;
    module2.exports.TimeoutError = TimeoutError;
  }
});

// ../../node_modules/p-queue/dist/lower-bound.js
var require_lower_bound = __commonJS({
  "../../node_modules/p-queue/dist/lower-bound.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function lowerBound(array, value, comparator) {
      let first = 0;
      let count = array.length;
      while (count > 0) {
        const step = count / 2 | 0;
        let it = first + step;
        if (comparator(array[it], value) <= 0) {
          first = ++it;
          count -= step + 1;
        } else {
          count = step;
        }
      }
      return first;
    }
    exports.default = lowerBound;
  }
});

// ../../node_modules/p-queue/dist/priority-queue.js
var require_priority_queue = __commonJS({
  "../../node_modules/p-queue/dist/priority-queue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var lower_bound_1 = require_lower_bound();
    var PriorityQueue = class {
      constructor() {
        this._queue = [];
      }
      enqueue(run2, options) {
        options = Object.assign({ priority: 0 }, options);
        const element2 = {
          priority: options.priority,
          run: run2
        };
        if (this.size && this._queue[this.size - 1].priority >= options.priority) {
          this._queue.push(element2);
          return;
        }
        const index = lower_bound_1.default(this._queue, element2, (a, b) => b.priority - a.priority);
        this._queue.splice(index, 0, element2);
      }
      dequeue() {
        const item = this._queue.shift();
        return item === null || item === void 0 ? void 0 : item.run;
      }
      filter(options) {
        return this._queue.filter((element2) => element2.priority === options.priority).map((element2) => element2.run);
      }
      get size() {
        return this._queue.length;
      }
    };
    exports.default = PriorityQueue;
  }
});

// ../../node_modules/p-queue/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/p-queue/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var EventEmitter = require_eventemitter3();
    var p_timeout_1 = require_p_timeout();
    var priority_queue_1 = require_priority_queue();
    var empty = () => {
    };
    var timeoutError = new p_timeout_1.TimeoutError();
    var PQueue = class extends EventEmitter {
      constructor(options) {
        var _a, _b, _c, _d;
        super();
        this._intervalCount = 0;
        this._intervalEnd = 0;
        this._pendingCount = 0;
        this._resolveEmpty = empty;
        this._resolveIdle = empty;
        options = Object.assign({ carryoverConcurrencyCount: false, intervalCap: Infinity, interval: 0, concurrency: Infinity, autoStart: true, queueClass: priority_queue_1.default }, options);
        if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
          throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ""}\` (${typeof options.intervalCap})`);
        }
        if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
          throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""}\` (${typeof options.interval})`);
        }
        this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;
        this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;
        this._intervalCap = options.intervalCap;
        this._interval = options.interval;
        this._queue = new options.queueClass();
        this._queueClass = options.queueClass;
        this.concurrency = options.concurrency;
        this._timeout = options.timeout;
        this._throwOnTimeout = options.throwOnTimeout === true;
        this._isPaused = options.autoStart === false;
      }
      get _doesIntervalAllowAnother() {
        return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
      }
      get _doesConcurrentAllowAnother() {
        return this._pendingCount < this._concurrency;
      }
      _next() {
        this._pendingCount--;
        this._tryToStartAnother();
        this.emit("next");
      }
      _resolvePromises() {
        this._resolveEmpty();
        this._resolveEmpty = empty;
        if (this._pendingCount === 0) {
          this._resolveIdle();
          this._resolveIdle = empty;
          this.emit("idle");
        }
      }
      _onResumeInterval() {
        this._onInterval();
        this._initializeIntervalIfNeeded();
        this._timeoutId = void 0;
      }
      _isIntervalPaused() {
        const now2 = Date.now();
        if (this._intervalId === void 0) {
          const delay = this._intervalEnd - now2;
          if (delay < 0) {
            this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
          } else {
            if (this._timeoutId === void 0) {
              this._timeoutId = setTimeout(() => {
                this._onResumeInterval();
              }, delay);
            }
            return true;
          }
        }
        return false;
      }
      _tryToStartAnother() {
        if (this._queue.size === 0) {
          if (this._intervalId) {
            clearInterval(this._intervalId);
          }
          this._intervalId = void 0;
          this._resolvePromises();
          return false;
        }
        if (!this._isPaused) {
          const canInitializeInterval = !this._isIntervalPaused();
          if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
            const job = this._queue.dequeue();
            if (!job) {
              return false;
            }
            this.emit("active");
            job();
            if (canInitializeInterval) {
              this._initializeIntervalIfNeeded();
            }
            return true;
          }
        }
        return false;
      }
      _initializeIntervalIfNeeded() {
        if (this._isIntervalIgnored || this._intervalId !== void 0) {
          return;
        }
        this._intervalId = setInterval(() => {
          this._onInterval();
        }, this._interval);
        this._intervalEnd = Date.now() + this._interval;
      }
      _onInterval() {
        if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {
          clearInterval(this._intervalId);
          this._intervalId = void 0;
        }
        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
        this._processQueue();
      }
      /**
      Executes all queued functions until it reaches the limit.
      */
      _processQueue() {
        while (this._tryToStartAnother()) {
        }
      }
      get concurrency() {
        return this._concurrency;
      }
      set concurrency(newConcurrency) {
        if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
          throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
        }
        this._concurrency = newConcurrency;
        this._processQueue();
      }
      /**
      Adds a sync or async task to the queue. Always returns a promise.
      */
      async add(fn, options = {}) {
        return new Promise((resolve, reject) => {
          const run2 = async () => {
            this._pendingCount++;
            this._intervalCount++;
            try {
              const operation = this._timeout === void 0 && options.timeout === void 0 ? fn() : p_timeout_1.default(Promise.resolve(fn()), options.timeout === void 0 ? this._timeout : options.timeout, () => {
                if (options.throwOnTimeout === void 0 ? this._throwOnTimeout : options.throwOnTimeout) {
                  reject(timeoutError);
                }
                return void 0;
              });
              resolve(await operation);
            } catch (error) {
              reject(error);
            }
            this._next();
          };
          this._queue.enqueue(run2, options);
          this._tryToStartAnother();
          this.emit("add");
        });
      }
      /**
          Same as `.add()`, but accepts an array of sync or async functions.
      
          @returns A promise that resolves when all functions are resolved.
          */
      async addAll(functions, options) {
        return Promise.all(functions.map(async (function_) => this.add(function_, options)));
      }
      /**
      Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
      */
      start() {
        if (!this._isPaused) {
          return this;
        }
        this._isPaused = false;
        this._processQueue();
        return this;
      }
      /**
      Put queue execution on hold.
      */
      pause() {
        this._isPaused = true;
      }
      /**
      Clear the queue.
      */
      clear() {
        this._queue = new this._queueClass();
      }
      /**
          Can be called multiple times. Useful if you for example add additional items at a later time.
      
          @returns A promise that settles when the queue becomes empty.
          */
      async onEmpty() {
        if (this._queue.size === 0) {
          return;
        }
        return new Promise((resolve) => {
          const existingResolve = this._resolveEmpty;
          this._resolveEmpty = () => {
            existingResolve();
            resolve();
          };
        });
      }
      /**
          The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
      
          @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
          */
      async onIdle() {
        if (this._pendingCount === 0 && this._queue.size === 0) {
          return;
        }
        return new Promise((resolve) => {
          const existingResolve = this._resolveIdle;
          this._resolveIdle = () => {
            existingResolve();
            resolve();
          };
        });
      }
      /**
      Size of the queue.
      */
      get size() {
        return this._queue.size;
      }
      /**
          Size of the queue, filtered by the given options.
      
          For example, this can be used to find the number of items remaining in the queue with a specific priority level.
          */
      sizeBy(options) {
        return this._queue.filter(options).length;
      }
      /**
      Number of pending promises.
      */
      get pending() {
        return this._pendingCount;
      }
      /**
      Whether the queue is currently paused.
      */
      get isPaused() {
        return this._isPaused;
      }
      get timeout() {
        return this._timeout;
      }
      /**
      Set the timeout for future operations.
      */
      set timeout(milliseconds) {
        this._timeout = milliseconds;
      }
    };
    exports.default = PQueue;
  }
});

// ../../node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../../node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ObsidianChatGPTPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/settings.ts
var DEFAULT_SETTINGS = {
  OPENAI_API_KEY: "",
  OPENAI_API_BASE: "https://api.openai.com/v1",
  LANGCHAIN_TRACING_V2: false,
  LANGCHAIN_API_KEY: "",
  LANGCHAIN_PROJECT: "default",
  LANGCHAIN_ENDPOINT: "https://api.smith.langchain.com"
};

// src/SettingTab.ts
var import_obsidian = require("obsidian");
var SettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin2) {
    super(app, plugin2);
    __publicField(this, "plugin");
    this.plugin = plugin2;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("OPENAI_API_KEY").setDesc("e.g. sk-").addText(
      (text2) => text2.setPlaceholder("OPENAI_API_KEY").setValue(this.plugin.settings.OPENAI_API_KEY).onChange(async (value) => {
        this.plugin.settings.OPENAI_API_KEY = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("OPENAI_API_BASE").setDesc("e.g. https://api.openai.com/v1").addText(
      (text2) => text2.setPlaceholder("OPENAI_API_BASE").setValue(this.plugin.settings.OPENAI_API_BASE).onChange(async (value) => {
        this.plugin.settings.OPENAI_API_BASE = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("LANGCHAIN_TRACING_V2").setDesc("e.g. https://api.openai.com/v1").addToggle(
      (text2) => text2.setTooltip("LANGCHAIN_TRACING_V2").setValue(this.plugin.settings.LANGCHAIN_TRACING_V2).onChange(async (value) => {
        this.plugin.settings.LANGCHAIN_TRACING_V2 = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("LANGCHAIN_API_KEY").setDesc("e.g. ls__").addText(
      (text2) => text2.setPlaceholder("LANGCHAIN_API_KEY").setValue(this.plugin.settings.LANGCHAIN_API_KEY).onChange(async (value) => {
        this.plugin.settings.LANGCHAIN_API_KEY = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("LANGCHAIN_PROJECT").setDesc("e.g. default").addText(
      (text2) => text2.setValue(this.plugin.settings.LANGCHAIN_PROJECT).onChange(async (value) => {
        this.plugin.settings.LANGCHAIN_PROJECT = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("LANGCHAIN_ENDPOINT").setDesc("e.g. https://api.smith.langchain.com").addText(
      (text2) => text2.setPlaceholder("LANGCHAIN_ENDPOINT").setValue(this.plugin.settings.LANGCHAIN_ENDPOINT).onChange(async (value) => {
        this.plugin.settings.LANGCHAIN_ENDPOINT = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// ../../node_modules/@langchain/core/dist/utils/env.js
var isBrowser = () => typeof window !== "undefined" && typeof window.document !== "undefined";
var isWebWorker = () => typeof globalThis === "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope";
var isJsDom = () => typeof window !== "undefined" && window.name === "nodejs" || typeof navigator !== "undefined" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom"));
var isDeno = () => typeof Deno !== "undefined";
var isNode = () => typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined" && !isDeno();
var getEnv = () => {
  let env;
  if (isBrowser()) {
    env = "browser";
  } else if (isNode()) {
    env = "node";
  } else if (isWebWorker()) {
    env = "webworker";
  } else if (isJsDom()) {
    env = "jsdom";
  } else if (isDeno()) {
    env = "deno";
  } else {
    env = "other";
  }
  return env;
};
var runtimeEnvironment;
async function getRuntimeEnvironment() {
  if (runtimeEnvironment === void 0) {
    const env = getEnv();
    runtimeEnvironment = {
      library: "langchain-js",
      runtime: env
    };
  }
  return runtimeEnvironment;
}
function getEnvironmentVariable(name) {
  var _a;
  try {
    return typeof process !== "undefined" ? (
      // eslint-disable-next-line no-process-env
      (_a = process.env) == null ? void 0 : _a[name]
    ) : void 0;
  } catch (e) {
    return void 0;
  }
}

// ../../node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// ../../node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// ../../node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// ../../node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// ../../node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// ../../node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// ../../node_modules/@langchain/core/dist/load/map_keys.js
var import_decamelize = __toESM(require_decamelize(), 1);
var import_camelcase = __toESM(require_camelcase(), 1);
function keyToJson(key, map) {
  return (map == null ? void 0 : map[key]) || (0, import_decamelize.default)(key);
}
function mapKeys(fields, mapper, map) {
  const mapped = {};
  for (const key in fields) {
    if (Object.hasOwn(fields, key)) {
      mapped[mapper(key, map)] = fields[key];
    }
  }
  return mapped;
}

// ../../node_modules/@langchain/core/dist/load/serializable.js
function shallowCopy(obj) {
  return Array.isArray(obj) ? [...obj] : { ...obj };
}
function replaceSecrets(root2, secretsMap) {
  const result = shallowCopy(root2);
  for (const [path, secretId] of Object.entries(secretsMap)) {
    const [last, ...partsReverse] = path.split(".").reverse();
    let current = result;
    for (const part of partsReverse.reverse()) {
      if (current[part] === void 0) {
        break;
      }
      current[part] = shallowCopy(current[part]);
      current = current[part];
    }
    if (current[last] !== void 0) {
      current[last] = {
        lc: 1,
        type: "secret",
        id: [secretId]
      };
    }
  }
  return result;
}
function get_lc_unique_name(serializableClass) {
  const parentClass = Object.getPrototypeOf(serializableClass);
  const lcNameIsSubclassed = typeof serializableClass.lc_name === "function" && (typeof parentClass.lc_name !== "function" || serializableClass.lc_name() !== parentClass.lc_name());
  if (lcNameIsSubclassed) {
    return serializableClass.lc_name();
  } else {
    return serializableClass.name;
  }
}
var Serializable = class _Serializable {
  /**
   * The name of the serializable. Override to provide an alias or
   * to preserve the serialized module name in minified environments.
   *
   * Implemented as a static method to support loading logic.
   */
  static lc_name() {
    return this.name;
  }
  /**
   * The final serialized identifier for the module.
   */
  get lc_id() {
    return [
      ...this.lc_namespace,
      get_lc_unique_name(this.constructor)
    ];
  }
  /**
   * A map of secrets, which will be omitted from serialization.
   * Keys are paths to the secret in constructor args, e.g. "foo.bar.baz".
   * Values are the secret ids, which will be used when deserializing.
   */
  get lc_secrets() {
    return void 0;
  }
  /**
   * A map of additional attributes to merge with constructor args.
   * Keys are the attribute names, e.g. "foo".
   * Values are the attribute values, which will be serialized.
   * These attributes need to be accepted by the constructor as arguments.
   */
  get lc_attributes() {
    return void 0;
  }
  /**
   * A map of aliases for constructor args.
   * Keys are the attribute names, e.g. "foo".
   * Values are the alias that will replace the key in serialization.
   * This is used to eg. make argument names match Python.
   */
  get lc_aliases() {
    return void 0;
  }
  constructor(kwargs, ..._args) {
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "lc_kwargs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.lc_kwargs = kwargs || {};
  }
  toJSON() {
    if (!this.lc_serializable) {
      return this.toJSONNotImplemented();
    }
    if (
      // eslint-disable-next-line no-instanceof/no-instanceof
      this.lc_kwargs instanceof _Serializable || typeof this.lc_kwargs !== "object" || Array.isArray(this.lc_kwargs)
    ) {
      return this.toJSONNotImplemented();
    }
    const aliases = {};
    const secrets = {};
    const kwargs = Object.keys(this.lc_kwargs).reduce((acc, key) => {
      acc[key] = key in this ? this[key] : this.lc_kwargs[key];
      return acc;
    }, {});
    for (let current = Object.getPrototypeOf(this); current; current = Object.getPrototypeOf(current)) {
      Object.assign(aliases, Reflect.get(current, "lc_aliases", this));
      Object.assign(secrets, Reflect.get(current, "lc_secrets", this));
      Object.assign(kwargs, Reflect.get(current, "lc_attributes", this));
    }
    Object.keys(secrets).forEach((keyPath) => {
      let read = this;
      let write = kwargs;
      const [last, ...partsReverse] = keyPath.split(".").reverse();
      for (const key of partsReverse.reverse()) {
        if (!(key in read) || read[key] === void 0)
          return;
        if (!(key in write) || write[key] === void 0) {
          if (typeof read[key] === "object" && read[key] != null) {
            write[key] = {};
          } else if (Array.isArray(read[key])) {
            write[key] = [];
          }
        }
        read = read[key];
        write = write[key];
      }
      if (last in read && read[last] !== void 0) {
        write[last] = write[last] || read[last];
      }
    });
    return {
      lc: 1,
      type: "constructor",
      id: this.lc_id,
      kwargs: mapKeys(Object.keys(secrets).length ? replaceSecrets(kwargs, secrets) : kwargs, keyToJson, aliases)
    };
  }
  toJSONNotImplemented() {
    return {
      lc: 1,
      type: "not_implemented",
      id: this.lc_id
    };
  }
};

// ../../node_modules/@langchain/core/dist/callbacks/base.js
var BaseCallbackHandlerMethodsClass = class {
};
var BaseCallbackHandler = class _BaseCallbackHandler extends BaseCallbackHandlerMethodsClass {
  get lc_namespace() {
    return ["langchain_core", "callbacks", this.name];
  }
  get lc_secrets() {
    return void 0;
  }
  get lc_attributes() {
    return void 0;
  }
  get lc_aliases() {
    return void 0;
  }
  /**
   * The name of the serializable. Override to provide an alias or
   * to preserve the serialized module name in minified environments.
   *
   * Implemented as a static method to support loading logic.
   */
  static lc_name() {
    return this.name;
  }
  /**
   * The final serialized identifier for the module.
   */
  get lc_id() {
    return [
      ...this.lc_namespace,
      get_lc_unique_name(this.constructor)
    ];
  }
  constructor(input) {
    var _a, _b, _c, _d, _e;
    super();
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "lc_kwargs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "ignoreLLM", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "ignoreChain", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "ignoreAgent", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "ignoreRetriever", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "awaitHandlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: typeof process !== "undefined" ? (
        // eslint-disable-next-line no-process-env
        ((_a = process.env) == null ? void 0 : _a.LANGCHAIN_CALLBACKS_BACKGROUND) !== "true"
      ) : true
    });
    this.lc_kwargs = input || {};
    if (input) {
      this.ignoreLLM = (_b = input.ignoreLLM) != null ? _b : this.ignoreLLM;
      this.ignoreChain = (_c = input.ignoreChain) != null ? _c : this.ignoreChain;
      this.ignoreAgent = (_d = input.ignoreAgent) != null ? _d : this.ignoreAgent;
      this.ignoreRetriever = (_e = input.ignoreRetriever) != null ? _e : this.ignoreRetriever;
    }
  }
  copy() {
    return new this.constructor(this);
  }
  toJSON() {
    return Serializable.prototype.toJSON.call(this);
  }
  toJSONNotImplemented() {
    return Serializable.prototype.toJSONNotImplemented.call(this);
  }
  static fromMethods(methods) {
    class Handler extends _BaseCallbackHandler {
      constructor() {
        super();
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: v4_default()
        });
        Object.assign(this, methods);
      }
    }
    return new Handler();
  }
};

// ../../node_modules/@langchain/core/dist/tracers/base.js
function _coerceToDict(value, defaultKey) {
  return value && !Array.isArray(value) && typeof value === "object" ? value : { [defaultKey]: value };
}
function stripNonAlphanumeric(input) {
  return input.replace(/[-:.]/g, "");
}
function convertToDottedOrderFormat(epoch, runId) {
  return stripNonAlphanumeric(`${new Date(epoch).toISOString().slice(0, -1)}000Z`) + runId;
}
var BaseTracer = class extends BaseCallbackHandler {
  constructor(_fields) {
    super(...arguments);
    Object.defineProperty(this, "runMap", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /* @__PURE__ */ new Map()
    });
  }
  copy() {
    return this;
  }
  stringifyError(error) {
    if (error instanceof Error) {
      return error.message + ((error == null ? void 0 : error.stack) ? `

${error.stack}` : "");
    }
    if (typeof error === "string") {
      return error;
    }
    return `${error}`;
  }
  _addChildRun(parentRun, childRun) {
    parentRun.child_runs.push(childRun);
  }
  async _startTrace(run2) {
    var _a;
    const currentDottedOrder = convertToDottedOrderFormat(run2.start_time, run2.id);
    const storedRun = { ...run2 };
    if (storedRun.parent_run_id !== void 0) {
      const parentRun = this.runMap.get(storedRun.parent_run_id);
      if (parentRun) {
        this._addChildRun(parentRun, storedRun);
        parentRun.child_execution_order = Math.max(parentRun.child_execution_order, storedRun.child_execution_order);
        storedRun.trace_id = parentRun.trace_id;
        if (parentRun.dotted_order !== void 0) {
          storedRun.dotted_order = [
            parentRun.dotted_order,
            currentDottedOrder
          ].join(".");
        } else {
        }
      } else {
      }
    } else {
      storedRun.trace_id = storedRun.id;
      storedRun.dotted_order = currentDottedOrder;
    }
    this.runMap.set(storedRun.id, storedRun);
    await ((_a = this.onRunCreate) == null ? void 0 : _a.call(this, storedRun));
  }
  async _endTrace(run2) {
    var _a;
    const parentRun = run2.parent_run_id !== void 0 && this.runMap.get(run2.parent_run_id);
    if (parentRun) {
      parentRun.child_execution_order = Math.max(parentRun.child_execution_order, run2.child_execution_order);
    } else {
      await this.persistRun(run2);
    }
    this.runMap.delete(run2.id);
    await ((_a = this.onRunUpdate) == null ? void 0 : _a.call(this, run2));
  }
  _getExecutionOrder(parentRunId) {
    const parentRun = parentRunId !== void 0 && this.runMap.get(parentRunId);
    if (!parentRun) {
      return 1;
    }
    return parentRun.child_execution_order + 1;
  }
  async handleLLMStart(llm2, prompts, runId, parentRunId, extraParams, tags, metadata, name) {
    var _a;
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const finalExtraParams = metadata ? { ...extraParams, metadata } : extraParams;
    const run2 = {
      id: runId,
      name: name != null ? name : llm2.id[llm2.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: llm2,
      events: [
        {
          name: "start",
          time: new Date(start_time).toISOString()
        }
      ],
      inputs: { prompts },
      execution_order,
      child_runs: [],
      child_execution_order: execution_order,
      run_type: "llm",
      extra: finalExtraParams != null ? finalExtraParams : {},
      tags: tags || []
    };
    await this._startTrace(run2);
    await ((_a = this.onLLMStart) == null ? void 0 : _a.call(this, run2));
    return run2;
  }
  async handleChatModelStart(llm2, messages, runId, parentRunId, extraParams, tags, metadata, name) {
    var _a;
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const finalExtraParams = metadata ? { ...extraParams, metadata } : extraParams;
    const run2 = {
      id: runId,
      name: name != null ? name : llm2.id[llm2.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: llm2,
      events: [
        {
          name: "start",
          time: new Date(start_time).toISOString()
        }
      ],
      inputs: { messages },
      execution_order,
      child_runs: [],
      child_execution_order: execution_order,
      run_type: "llm",
      extra: finalExtraParams != null ? finalExtraParams : {},
      tags: tags || []
    };
    await this._startTrace(run2);
    await ((_a = this.onLLMStart) == null ? void 0 : _a.call(this, run2));
    return run2;
  }
  async handleLLMEnd(output, runId) {
    var _a;
    const run2 = this.runMap.get(runId);
    if (!run2 || (run2 == null ? void 0 : run2.run_type) !== "llm") {
      throw new Error("No LLM run to end.");
    }
    run2.end_time = Date.now();
    run2.outputs = output;
    run2.events.push({
      name: "end",
      time: new Date(run2.end_time).toISOString()
    });
    await ((_a = this.onLLMEnd) == null ? void 0 : _a.call(this, run2));
    await this._endTrace(run2);
    return run2;
  }
  async handleLLMError(error, runId) {
    var _a;
    const run2 = this.runMap.get(runId);
    if (!run2 || (run2 == null ? void 0 : run2.run_type) !== "llm") {
      throw new Error("No LLM run to end.");
    }
    run2.end_time = Date.now();
    run2.error = this.stringifyError(error);
    run2.events.push({
      name: "error",
      time: new Date(run2.end_time).toISOString()
    });
    await ((_a = this.onLLMError) == null ? void 0 : _a.call(this, run2));
    await this._endTrace(run2);
    return run2;
  }
  async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {
    var _a;
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const run2 = {
      id: runId,
      name: name != null ? name : chain.id[chain.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: chain,
      events: [
        {
          name: "start",
          time: new Date(start_time).toISOString()
        }
      ],
      inputs,
      execution_order,
      child_execution_order: execution_order,
      run_type: runType != null ? runType : "chain",
      child_runs: [],
      extra: metadata ? { metadata } : {},
      tags: tags || []
    };
    await this._startTrace(run2);
    await ((_a = this.onChainStart) == null ? void 0 : _a.call(this, run2));
    return run2;
  }
  async handleChainEnd(outputs, runId, _parentRunId, _tags, kwargs) {
    var _a;
    const run2 = this.runMap.get(runId);
    if (!run2) {
      throw new Error("No chain run to end.");
    }
    run2.end_time = Date.now();
    run2.outputs = _coerceToDict(outputs, "output");
    run2.events.push({
      name: "end",
      time: new Date(run2.end_time).toISOString()
    });
    if ((kwargs == null ? void 0 : kwargs.inputs) !== void 0) {
      run2.inputs = _coerceToDict(kwargs.inputs, "input");
    }
    await ((_a = this.onChainEnd) == null ? void 0 : _a.call(this, run2));
    await this._endTrace(run2);
    return run2;
  }
  async handleChainError(error, runId, _parentRunId, _tags, kwargs) {
    var _a;
    const run2 = this.runMap.get(runId);
    if (!run2) {
      throw new Error("No chain run to end.");
    }
    run2.end_time = Date.now();
    run2.error = this.stringifyError(error);
    run2.events.push({
      name: "error",
      time: new Date(run2.end_time).toISOString()
    });
    if ((kwargs == null ? void 0 : kwargs.inputs) !== void 0) {
      run2.inputs = _coerceToDict(kwargs.inputs, "input");
    }
    await ((_a = this.onChainError) == null ? void 0 : _a.call(this, run2));
    await this._endTrace(run2);
    return run2;
  }
  async handleToolStart(tool, input, runId, parentRunId, tags, metadata, name) {
    var _a;
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const run2 = {
      id: runId,
      name: name != null ? name : tool.id[tool.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: tool,
      events: [
        {
          name: "start",
          time: new Date(start_time).toISOString()
        }
      ],
      inputs: { input },
      execution_order,
      child_execution_order: execution_order,
      run_type: "tool",
      child_runs: [],
      extra: metadata ? { metadata } : {},
      tags: tags || []
    };
    await this._startTrace(run2);
    await ((_a = this.onToolStart) == null ? void 0 : _a.call(this, run2));
    return run2;
  }
  async handleToolEnd(output, runId) {
    var _a;
    const run2 = this.runMap.get(runId);
    if (!run2 || (run2 == null ? void 0 : run2.run_type) !== "tool") {
      throw new Error("No tool run to end");
    }
    run2.end_time = Date.now();
    run2.outputs = { output };
    run2.events.push({
      name: "end",
      time: new Date(run2.end_time).toISOString()
    });
    await ((_a = this.onToolEnd) == null ? void 0 : _a.call(this, run2));
    await this._endTrace(run2);
    return run2;
  }
  async handleToolError(error, runId) {
    var _a;
    const run2 = this.runMap.get(runId);
    if (!run2 || (run2 == null ? void 0 : run2.run_type) !== "tool") {
      throw new Error("No tool run to end");
    }
    run2.end_time = Date.now();
    run2.error = this.stringifyError(error);
    run2.events.push({
      name: "error",
      time: new Date(run2.end_time).toISOString()
    });
    await ((_a = this.onToolError) == null ? void 0 : _a.call(this, run2));
    await this._endTrace(run2);
    return run2;
  }
  async handleAgentAction(action, runId) {
    var _a;
    const run2 = this.runMap.get(runId);
    if (!run2 || (run2 == null ? void 0 : run2.run_type) !== "chain") {
      return;
    }
    const agentRun = run2;
    agentRun.actions = agentRun.actions || [];
    agentRun.actions.push(action);
    agentRun.events.push({
      name: "agent_action",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { action }
    });
    await ((_a = this.onAgentAction) == null ? void 0 : _a.call(this, run2));
  }
  async handleAgentEnd(action, runId) {
    var _a;
    const run2 = this.runMap.get(runId);
    if (!run2 || (run2 == null ? void 0 : run2.run_type) !== "chain") {
      return;
    }
    run2.events.push({
      name: "agent_end",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { action }
    });
    await ((_a = this.onAgentEnd) == null ? void 0 : _a.call(this, run2));
  }
  async handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {
    var _a;
    const execution_order = this._getExecutionOrder(parentRunId);
    const start_time = Date.now();
    const run2 = {
      id: runId,
      name: name != null ? name : retriever.id[retriever.id.length - 1],
      parent_run_id: parentRunId,
      start_time,
      serialized: retriever,
      events: [
        {
          name: "start",
          time: new Date(start_time).toISOString()
        }
      ],
      inputs: { query },
      execution_order,
      child_execution_order: execution_order,
      run_type: "retriever",
      child_runs: [],
      extra: metadata ? { metadata } : {},
      tags: tags || []
    };
    await this._startTrace(run2);
    await ((_a = this.onRetrieverStart) == null ? void 0 : _a.call(this, run2));
    return run2;
  }
  async handleRetrieverEnd(documents, runId) {
    var _a;
    const run2 = this.runMap.get(runId);
    if (!run2 || (run2 == null ? void 0 : run2.run_type) !== "retriever") {
      throw new Error("No retriever run to end");
    }
    run2.end_time = Date.now();
    run2.outputs = { documents };
    run2.events.push({
      name: "end",
      time: new Date(run2.end_time).toISOString()
    });
    await ((_a = this.onRetrieverEnd) == null ? void 0 : _a.call(this, run2));
    await this._endTrace(run2);
    return run2;
  }
  async handleRetrieverError(error, runId) {
    var _a;
    const run2 = this.runMap.get(runId);
    if (!run2 || (run2 == null ? void 0 : run2.run_type) !== "retriever") {
      throw new Error("No retriever run to end");
    }
    run2.end_time = Date.now();
    run2.error = this.stringifyError(error);
    run2.events.push({
      name: "error",
      time: new Date(run2.end_time).toISOString()
    });
    await ((_a = this.onRetrieverError) == null ? void 0 : _a.call(this, run2));
    await this._endTrace(run2);
    return run2;
  }
  async handleText(text2, runId) {
    var _a;
    const run2 = this.runMap.get(runId);
    if (!run2 || (run2 == null ? void 0 : run2.run_type) !== "chain") {
      return;
    }
    run2.events.push({
      name: "text",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { text: text2 }
    });
    await ((_a = this.onText) == null ? void 0 : _a.call(this, run2));
  }
  async handleLLMNewToken(token, idx, runId, _parentRunId, _tags, fields) {
    var _a;
    const run2 = this.runMap.get(runId);
    if (!run2 || (run2 == null ? void 0 : run2.run_type) !== "llm") {
      throw new Error(`Invalid "runId" provided to "handleLLMNewToken" callback.`);
    }
    run2.events.push({
      name: "new_token",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      kwargs: { token, idx, chunk: fields == null ? void 0 : fields.chunk }
    });
    await ((_a = this.onLLMNewToken) == null ? void 0 : _a.call(this, run2, token, { chunk: fields == null ? void 0 : fields.chunk }));
    return run2;
  }
};

// ../../node_modules/@langchain/core/dist/tracers/console.js
var import_ansi_styles = __toESM(require_ansi_styles(), 1);
function wrap(style, text2) {
  return `${style.open}${text2}${style.close}`;
}
function tryJsonStringify(obj, fallback) {
  try {
    return JSON.stringify(obj, null, 2);
  } catch (err) {
    return fallback;
  }
}
function elapsed(run2) {
  if (!run2.end_time)
    return "";
  const elapsed2 = run2.end_time - run2.start_time;
  if (elapsed2 < 1e3) {
    return `${elapsed2}ms`;
  }
  return `${(elapsed2 / 1e3).toFixed(2)}s`;
}
var { color } = import_ansi_styles.default;
var ConsoleCallbackHandler = class extends BaseTracer {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "console_callback_handler"
    });
  }
  /**
   * Method used to persist the run. In this case, it simply returns a
   * resolved promise as there's no persistence logic.
   * @param _run The run to persist.
   * @returns A resolved promise.
   */
  persistRun(_run) {
    return Promise.resolve();
  }
  // utility methods
  /**
   * Method used to get all the parent runs of a given run.
   * @param run The run whose parents are to be retrieved.
   * @returns An array of parent runs.
   */
  getParents(run2) {
    const parents = [];
    let currentRun = run2;
    while (currentRun.parent_run_id) {
      const parent = this.runMap.get(currentRun.parent_run_id);
      if (parent) {
        parents.push(parent);
        currentRun = parent;
      } else {
        break;
      }
    }
    return parents;
  }
  /**
   * Method used to get a string representation of the run's lineage, which
   * is used in logging.
   * @param run The run whose lineage is to be retrieved.
   * @returns A string representation of the run's lineage.
   */
  getBreadcrumbs(run2) {
    const parents = this.getParents(run2).reverse();
    const string = [...parents, run2].map((parent, i, arr) => {
      const name = `${parent.execution_order}:${parent.run_type}:${parent.name}`;
      return i === arr.length - 1 ? wrap(import_ansi_styles.default.bold, name) : name;
    }).join(" > ");
    return wrap(color.grey, string);
  }
  // logging methods
  /**
   * Method used to log the start of a chain run.
   * @param run The chain run that has started.
   * @returns void
   */
  onChainStart(run2) {
    const crumbs = this.getBreadcrumbs(run2);
    console.log(`${wrap(color.green, "[chain/start]")} [${crumbs}] Entering Chain run with input: ${tryJsonStringify(run2.inputs, "[inputs]")}`);
  }
  /**
   * Method used to log the end of a chain run.
   * @param run The chain run that has ended.
   * @returns void
   */
  onChainEnd(run2) {
    const crumbs = this.getBreadcrumbs(run2);
    console.log(`${wrap(color.cyan, "[chain/end]")} [${crumbs}] [${elapsed(run2)}] Exiting Chain run with output: ${tryJsonStringify(run2.outputs, "[outputs]")}`);
  }
  /**
   * Method used to log any errors of a chain run.
   * @param run The chain run that has errored.
   * @returns void
   */
  onChainError(run2) {
    const crumbs = this.getBreadcrumbs(run2);
    console.log(`${wrap(color.red, "[chain/error]")} [${crumbs}] [${elapsed(run2)}] Chain run errored with error: ${tryJsonStringify(run2.error, "[error]")}`);
  }
  /**
   * Method used to log the start of an LLM run.
   * @param run The LLM run that has started.
   * @returns void
   */
  onLLMStart(run2) {
    const crumbs = this.getBreadcrumbs(run2);
    const inputs = "prompts" in run2.inputs ? { prompts: run2.inputs.prompts.map((p) => p.trim()) } : run2.inputs;
    console.log(`${wrap(color.green, "[llm/start]")} [${crumbs}] Entering LLM run with input: ${tryJsonStringify(inputs, "[inputs]")}`);
  }
  /**
   * Method used to log the end of an LLM run.
   * @param run The LLM run that has ended.
   * @returns void
   */
  onLLMEnd(run2) {
    const crumbs = this.getBreadcrumbs(run2);
    console.log(`${wrap(color.cyan, "[llm/end]")} [${crumbs}] [${elapsed(run2)}] Exiting LLM run with output: ${tryJsonStringify(run2.outputs, "[response]")}`);
  }
  /**
   * Method used to log any errors of an LLM run.
   * @param run The LLM run that has errored.
   * @returns void
   */
  onLLMError(run2) {
    const crumbs = this.getBreadcrumbs(run2);
    console.log(`${wrap(color.red, "[llm/error]")} [${crumbs}] [${elapsed(run2)}] LLM run errored with error: ${tryJsonStringify(run2.error, "[error]")}`);
  }
  /**
   * Method used to log the start of a tool run.
   * @param run The tool run that has started.
   * @returns void
   */
  onToolStart(run2) {
    var _a;
    const crumbs = this.getBreadcrumbs(run2);
    console.log(`${wrap(color.green, "[tool/start]")} [${crumbs}] Entering Tool run with input: "${(_a = run2.inputs.input) == null ? void 0 : _a.trim()}"`);
  }
  /**
   * Method used to log the end of a tool run.
   * @param run The tool run that has ended.
   * @returns void
   */
  onToolEnd(run2) {
    var _a, _b;
    const crumbs = this.getBreadcrumbs(run2);
    console.log(`${wrap(color.cyan, "[tool/end]")} [${crumbs}] [${elapsed(run2)}] Exiting Tool run with output: "${(_b = (_a = run2.outputs) == null ? void 0 : _a.output) == null ? void 0 : _b.trim()}"`);
  }
  /**
   * Method used to log any errors of a tool run.
   * @param run The tool run that has errored.
   * @returns void
   */
  onToolError(run2) {
    const crumbs = this.getBreadcrumbs(run2);
    console.log(`${wrap(color.red, "[tool/error]")} [${crumbs}] [${elapsed(run2)}] Tool run errored with error: ${tryJsonStringify(run2.error, "[error]")}`);
  }
  /**
   * Method used to log the start of a retriever run.
   * @param run The retriever run that has started.
   * @returns void
   */
  onRetrieverStart(run2) {
    const crumbs = this.getBreadcrumbs(run2);
    console.log(`${wrap(color.green, "[retriever/start]")} [${crumbs}] Entering Retriever run with input: ${tryJsonStringify(run2.inputs, "[inputs]")}`);
  }
  /**
   * Method used to log the end of a retriever run.
   * @param run The retriever run that has ended.
   * @returns void
   */
  onRetrieverEnd(run2) {
    const crumbs = this.getBreadcrumbs(run2);
    console.log(`${wrap(color.cyan, "[retriever/end]")} [${crumbs}] [${elapsed(run2)}] Exiting Retriever run with output: ${tryJsonStringify(run2.outputs, "[outputs]")}`);
  }
  /**
   * Method used to log any errors of a retriever run.
   * @param run The retriever run that has errored.
   * @returns void
   */
  onRetrieverError(run2) {
    const crumbs = this.getBreadcrumbs(run2);
    console.log(`${wrap(color.red, "[retriever/error]")} [${crumbs}] [${elapsed(run2)}] Retriever run errored with error: ${tryJsonStringify(run2.error, "[error]")}`);
  }
  /**
   * Method used to log the action selected by the agent.
   * @param run The run in which the agent action occurred.
   * @returns void
   */
  onAgentAction(run2) {
    const agentRun = run2;
    const crumbs = this.getBreadcrumbs(run2);
    console.log(`${wrap(color.blue, "[agent/action]")} [${crumbs}] Agent selected action: ${tryJsonStringify(agentRun.actions[agentRun.actions.length - 1], "[action]")}`);
  }
};

// ../../node_modules/langsmith/dist/utils/async_caller.js
var import_p_retry = __toESM(require_p_retry(), 1);
var import_p_queue = __toESM(require_dist(), 1);
var STATUS_NO_RETRY = [
  400,
  401,
  403,
  404,
  405,
  406,
  407,
  408
  // Request Timeout
];
var STATUS_IGNORE = [
  409
  // Conflict
];
var AsyncCaller = class {
  constructor(params) {
    var _a, _b;
    Object.defineProperty(this, "maxConcurrency", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "maxRetries", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "queue", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "onFailedResponseHook", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxConcurrency = (_a = params.maxConcurrency) != null ? _a : Infinity;
    this.maxRetries = (_b = params.maxRetries) != null ? _b : 6;
    const PQueue = "default" in import_p_queue.default ? import_p_queue.default.default : import_p_queue.default;
    this.queue = new PQueue({ concurrency: this.maxConcurrency });
    this.onFailedResponseHook = params == null ? void 0 : params.onFailedResponseHook;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  call(callable, ...args) {
    const onFailedResponseHook = this.onFailedResponseHook;
    return this.queue.add(() => (0, import_p_retry.default)(() => callable(...args).catch((error) => {
      if (error instanceof Error) {
        throw error;
      } else {
        throw new Error(error);
      }
    }), {
      async onFailedAttempt(error) {
        if (error.message.startsWith("Cancel") || error.message.startsWith("TimeoutError") || error.message.startsWith("AbortError")) {
          throw error;
        }
        if ((error == null ? void 0 : error.code) === "ECONNABORTED") {
          throw error;
        }
        const response = error == null ? void 0 : error.response;
        const status = response == null ? void 0 : response.status;
        if (status) {
          if (STATUS_NO_RETRY.includes(+status)) {
            throw error;
          } else if (STATUS_IGNORE.includes(+status)) {
            return;
          }
          if (onFailedResponseHook) {
            await onFailedResponseHook(response);
          }
        }
      },
      // If needed we can change some of the defaults here,
      // but they're quite sensible.
      retries: this.maxRetries,
      randomize: true
    }), { throwOnTimeout: true });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  callWithOptions(options, callable, ...args) {
    if (options.signal) {
      return Promise.race([
        this.call(callable, ...args),
        new Promise((_, reject) => {
          var _a;
          (_a = options.signal) == null ? void 0 : _a.addEventListener("abort", () => {
            reject(new Error("AbortError"));
          });
        })
      ]);
    }
    return this.call(callable, ...args);
  }
  fetch(...args) {
    return this.call(() => fetch(...args).then((res) => res.ok ? res : Promise.reject(res)));
  }
};

// ../../node_modules/langsmith/dist/utils/messages.js
function isLangChainMessage(message) {
  return typeof (message == null ? void 0 : message._getType) === "function";
}
function convertLangChainMessageToExample(message) {
  const converted = {
    type: message._getType(),
    data: { content: message.content }
  };
  if ((message == null ? void 0 : message.additional_kwargs) && Object.keys(message.additional_kwargs).length > 0) {
    converted.data.additional_kwargs = { ...message.additional_kwargs };
  }
  return converted;
}

// ../../node_modules/langsmith/dist/utils/env.js
var globalEnv;
var isBrowser2 = () => typeof window !== "undefined" && typeof window.document !== "undefined";
var isWebWorker2 = () => typeof globalThis === "object" && globalThis.constructor && globalThis.constructor.name === "DedicatedWorkerGlobalScope";
var isJsDom2 = () => typeof window !== "undefined" && window.name === "nodejs" || typeof navigator !== "undefined" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom"));
var isDeno2 = () => typeof Deno !== "undefined";
var isNode2 = () => typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined" && !isDeno2();
var getEnv2 = () => {
  if (globalEnv) {
    return globalEnv;
  }
  if (isBrowser2()) {
    globalEnv = "browser";
  } else if (isNode2()) {
    globalEnv = "node";
  } else if (isWebWorker2()) {
    globalEnv = "webworker";
  } else if (isJsDom2()) {
    globalEnv = "jsdom";
  } else if (isDeno2()) {
    globalEnv = "deno";
  } else {
    globalEnv = "other";
  }
  return globalEnv;
};
var runtimeEnvironment2;
async function getRuntimeEnvironment2() {
  if (runtimeEnvironment2 === void 0) {
    const env = getEnv2();
    const releaseEnv = getShas();
    runtimeEnvironment2 = {
      library: "langsmith",
      runtime: env,
      sdk: "langsmith-js",
      sdk_version: __version__,
      ...releaseEnv
    };
  }
  return runtimeEnvironment2;
}
function getLangChainEnvVarsMetadata() {
  const allEnvVars = getEnvironmentVariables() || {};
  const envVars = {};
  const excluded = [
    "LANGCHAIN_API_KEY",
    "LANGCHAIN_ENDPOINT",
    "LANGCHAIN_TRACING_V2",
    "LANGCHAIN_PROJECT",
    "LANGCHAIN_SESSION"
  ];
  for (const [key, value] of Object.entries(allEnvVars)) {
    if (key.startsWith("LANGCHAIN_") && typeof value === "string" && !excluded.includes(key) && !key.toLowerCase().includes("key") && !key.toLowerCase().includes("secret") && !key.toLowerCase().includes("token")) {
      if (key === "LANGCHAIN_REVISION_ID") {
        envVars["revision_id"] = value;
      } else {
        envVars[key] = value;
      }
    }
  }
  return envVars;
}
function getEnvironmentVariables() {
  try {
    if (typeof process !== "undefined" && process.env) {
      return Object.entries(process.env).reduce((acc, [key, value]) => {
        acc[key] = String(value);
        return acc;
      }, {});
    }
    return void 0;
  } catch (e) {
    return void 0;
  }
}
function getEnvironmentVariable2(name) {
  var _a;
  try {
    return typeof process !== "undefined" ? (
      // eslint-disable-next-line no-process-env
      (_a = process.env) == null ? void 0 : _a[name]
    ) : void 0;
  } catch (e) {
    return void 0;
  }
}
var cachedCommitSHAs;
function getShas() {
  if (cachedCommitSHAs !== void 0) {
    return cachedCommitSHAs;
  }
  const common_release_envs = [
    "VERCEL_GIT_COMMIT_SHA",
    "NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA",
    "COMMIT_REF",
    "RENDER_GIT_COMMIT",
    "CI_COMMIT_SHA",
    "CIRCLE_SHA1",
    "CF_PAGES_COMMIT_SHA",
    "REACT_APP_GIT_SHA",
    "SOURCE_VERSION",
    "GITHUB_SHA",
    "TRAVIS_COMMIT",
    "GIT_COMMIT",
    "BUILD_VCS_NUMBER",
    "bamboo_planRepository_revision",
    "Build.SourceVersion",
    "BITBUCKET_COMMIT",
    "DRONE_COMMIT_SHA",
    "SEMAPHORE_GIT_SHA",
    "BUILDKITE_COMMIT"
  ];
  const shas = {};
  for (const env of common_release_envs) {
    const envVar = getEnvironmentVariable2(env);
    if (envVar !== void 0) {
      shas[env] = envVar;
    }
  }
  cachedCommitSHAs = shas;
  return shas;
}

// ../../node_modules/langsmith/dist/client.js
async function mergeRuntimeEnvIntoRunCreates(runs) {
  const runtimeEnv = await getRuntimeEnvironment2();
  const envVars = getLangChainEnvVarsMetadata();
  return runs.map((run2) => {
    var _a, _b;
    const extra = (_a = run2.extra) != null ? _a : {};
    const metadata = extra.metadata;
    run2.extra = {
      ...extra,
      runtime: {
        ...runtimeEnv,
        ...extra == null ? void 0 : extra.runtime
      },
      metadata: {
        ...envVars,
        ...envVars.revision_id || run2.revision_id ? { revision_id: (_b = run2.revision_id) != null ? _b : envVars.revision_id } : {},
        ...metadata
      }
    };
    return run2;
  });
}
var getTracingSamplingRate = () => {
  const samplingRateStr = getEnvironmentVariable2("LANGCHAIN_TRACING_SAMPLING_RATE");
  if (samplingRateStr === void 0) {
    return void 0;
  }
  const samplingRate = parseFloat(samplingRateStr);
  if (samplingRate < 0 || samplingRate > 1) {
    throw new Error(`LANGCHAIN_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);
  }
  return samplingRate;
};
var isLocalhost = (url) => {
  const strippedUrl = url.replace("http://", "").replace("https://", "");
  const hostname = strippedUrl.split("/")[0].split(":")[0];
  return hostname === "localhost" || hostname === "127.0.0.1" || hostname === "::1";
};
var raiseForStatus = async (response, operation) => {
  const body = await response.text();
  if (!response.ok) {
    throw new Error(`Failed to ${operation}: ${response.status} ${response.statusText} ${body}`);
  }
};
async function toArray(iterable) {
  const result = [];
  for await (const item of iterable) {
    result.push(item);
  }
  return result;
}
function trimQuotes(str) {
  if (str === void 0) {
    return void 0;
  }
  return str.trim().replace(/^"(.*)"$/, "$1").replace(/^'(.*)'$/, "$1");
}
function assertUuid(str) {
  if (!validate_default(str)) {
    throw new Error(`Invalid UUID: ${str}`);
  }
}
var handle429 = async (response) => {
  var _a;
  if ((response == null ? void 0 : response.status) === 429) {
    const retryAfter = parseInt((_a = response.headers.get("retry-after")) != null ? _a : "30", 10) * 1e3;
    if (retryAfter > 0) {
      await new Promise((resolve) => setTimeout(resolve, retryAfter));
      return true;
    }
  }
  return false;
};
var Queue = class {
  constructor() {
    Object.defineProperty(this, "items", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
  }
  get size() {
    return this.items.length;
  }
  push(item) {
    return new Promise((resolve) => {
      this.items.push([item, resolve]);
    });
  }
  pop(upToN) {
    if (upToN < 1) {
      throw new Error("Number of items to pop off may not be less than 1.");
    }
    const popped = [];
    while (popped.length < upToN && this.items.length) {
      const item = this.items.shift();
      if (item) {
        popped.push(item);
      } else {
        break;
      }
    }
    return [popped.map((it) => it[0]), () => popped.forEach((it) => it[1]())];
  }
};
var DEFAULT_BATCH_SIZE_LIMIT_BYTES = 20971520;
var Client = class _Client {
  constructor(config = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    Object.defineProperty(this, "apiKey", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "apiUrl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "webUrl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "caller", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "batchIngestCaller", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "timeout_ms", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_tenantId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: null
    });
    Object.defineProperty(this, "hideInputs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "hideOutputs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "tracingSampleRate", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "sampledPostUuids", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /* @__PURE__ */ new Set()
    });
    Object.defineProperty(this, "autoBatchTracing", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "batchEndpointSupported", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "autoBatchQueue", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new Queue()
    });
    Object.defineProperty(this, "pendingAutoBatchedRunLimit", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 100
    });
    Object.defineProperty(this, "autoBatchTimeout", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "autoBatchInitialDelayMs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 250
    });
    Object.defineProperty(this, "autoBatchAggregationDelayMs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 50
    });
    Object.defineProperty(this, "serverInfo", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    const defaultConfig = _Client.getDefaultClientConfig();
    this.tracingSampleRate = getTracingSamplingRate();
    this.apiUrl = (_b = trimQuotes((_a = config.apiUrl) != null ? _a : defaultConfig.apiUrl)) != null ? _b : "";
    this.apiKey = trimQuotes((_c = config.apiKey) != null ? _c : defaultConfig.apiKey);
    this.webUrl = trimQuotes((_d = config.webUrl) != null ? _d : defaultConfig.webUrl);
    this.timeout_ms = (_e = config.timeout_ms) != null ? _e : 12e3;
    this.caller = new AsyncCaller((_f = config.callerOptions) != null ? _f : {});
    this.batchIngestCaller = new AsyncCaller({
      ...(_g = config.callerOptions) != null ? _g : {},
      onFailedResponseHook: handle429
    });
    this.hideInputs = (_h = config.hideInputs) != null ? _h : defaultConfig.hideInputs;
    this.hideOutputs = (_i = config.hideOutputs) != null ? _i : defaultConfig.hideOutputs;
    this.autoBatchTracing = (_j = config.autoBatchTracing) != null ? _j : this.autoBatchTracing;
    this.pendingAutoBatchedRunLimit = (_k = config.pendingAutoBatchedRunLimit) != null ? _k : this.pendingAutoBatchedRunLimit;
  }
  static getDefaultClientConfig() {
    var _a;
    const apiKey = getEnvironmentVariable2("LANGCHAIN_API_KEY");
    const apiUrl = (_a = getEnvironmentVariable2("LANGCHAIN_ENDPOINT")) != null ? _a : "https://api.smith.langchain.com";
    const hideInputs = getEnvironmentVariable2("LANGCHAIN_HIDE_INPUTS") === "true";
    const hideOutputs = getEnvironmentVariable2("LANGCHAIN_HIDE_OUTPUTS") === "true";
    return {
      apiUrl,
      apiKey,
      webUrl: void 0,
      hideInputs,
      hideOutputs
    };
  }
  getHostUrl() {
    if (this.webUrl) {
      return this.webUrl;
    } else if (isLocalhost(this.apiUrl)) {
      this.webUrl = "http://localhost";
      return "http://localhost";
    } else if (this.apiUrl.includes("/api") && !this.apiUrl.split(".", 1)[0].endsWith("api")) {
      this.webUrl = this.apiUrl.replace("/api", "");
      return this.webUrl;
    } else if (this.apiUrl.split(".", 1)[0].includes("dev")) {
      this.webUrl = "https://dev.smith.langchain.com";
      return "https://dev.smith.langchain.com";
    } else {
      this.webUrl = "https://smith.langchain.com";
      return "https://smith.langchain.com";
    }
  }
  get headers() {
    const headers = {
      "User-Agent": `langsmith-js/${__version__}`
    };
    if (this.apiKey) {
      headers["x-api-key"] = `${this.apiKey}`;
    }
    return headers;
  }
  processInputs(inputs) {
    if (this.hideInputs) {
      return {};
    }
    return inputs;
  }
  processOutputs(outputs) {
    if (this.hideOutputs) {
      return {};
    }
    return outputs;
  }
  prepareRunCreateOrUpdateInputs(run2) {
    const runParams = { ...run2 };
    if (runParams.inputs !== void 0) {
      runParams.inputs = this.processInputs(runParams.inputs);
    }
    if (runParams.outputs !== void 0) {
      runParams.outputs = this.processOutputs(runParams.outputs);
    }
    return runParams;
  }
  async _getResponse(path, queryParams) {
    var _a;
    const paramsString = (_a = queryParams == null ? void 0 : queryParams.toString()) != null ? _a : "";
    const url = `${this.apiUrl}${path}?${paramsString}`;
    const response = await this.caller.call(fetch, url, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms)
    });
    if (!response.ok) {
      throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);
    }
    return response;
  }
  async _get(path, queryParams) {
    const response = await this._getResponse(path, queryParams);
    return response.json();
  }
  async *_getPaginated(path, queryParams = new URLSearchParams()) {
    let offset = Number(queryParams.get("offset")) || 0;
    const limit = Number(queryParams.get("limit")) || 100;
    while (true) {
      queryParams.set("offset", String(offset));
      queryParams.set("limit", String(limit));
      const url = `${this.apiUrl}${path}?${queryParams}`;
      const response = await this.caller.call(fetch, url, {
        method: "GET",
        headers: this.headers,
        signal: AbortSignal.timeout(this.timeout_ms)
      });
      if (!response.ok) {
        throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);
      }
      const items = await response.json();
      if (items.length === 0) {
        break;
      }
      yield items;
      if (items.length < limit) {
        break;
      }
      offset += items.length;
    }
  }
  async *_getCursorPaginatedList(path, body = null, requestMethod = "POST", dataKey = "runs") {
    const bodyParams = body ? { ...body } : {};
    while (true) {
      const response = await this.caller.call(fetch, `${this.apiUrl}${path}`, {
        method: requestMethod,
        headers: { ...this.headers, "Content-Type": "application/json" },
        signal: AbortSignal.timeout(this.timeout_ms),
        body: JSON.stringify(bodyParams)
      });
      const responseBody = await response.json();
      if (!responseBody) {
        break;
      }
      if (!responseBody[dataKey]) {
        break;
      }
      yield responseBody[dataKey];
      const cursors = responseBody.cursors;
      if (!cursors) {
        break;
      }
      if (!cursors.next) {
        break;
      }
      bodyParams.cursor = cursors.next;
    }
  }
  _filterForSampling(runs, patch = false) {
    if (this.tracingSampleRate === void 0) {
      return runs;
    }
    if (patch) {
      const sampled = [];
      for (const run2 of runs) {
        if (this.sampledPostUuids.has(run2.id)) {
          sampled.push(run2);
          this.sampledPostUuids.delete(run2.id);
        }
      }
      return sampled;
    } else {
      const sampled = [];
      for (const run2 of runs) {
        if (Math.random() < this.tracingSampleRate) {
          sampled.push(run2);
          this.sampledPostUuids.add(run2.id);
        }
      }
      return sampled;
    }
  }
  async drainAutoBatchQueue() {
    while (this.autoBatchQueue.size >= 0) {
      const [batch, done] = this.autoBatchQueue.pop(this.pendingAutoBatchedRunLimit);
      if (!batch.length) {
        done();
        return;
      }
      try {
        await this.batchIngestRuns({
          runCreates: batch.filter((item) => item.action === "create").map((item) => item.item),
          runUpdates: batch.filter((item) => item.action === "update").map((item) => item.item)
        });
      } finally {
        done();
      }
    }
  }
  async processRunOperation(item, immediatelyTriggerBatch) {
    const oldTimeout = this.autoBatchTimeout;
    clearTimeout(this.autoBatchTimeout);
    this.autoBatchTimeout = void 0;
    const itemPromise = this.autoBatchQueue.push(item);
    if (immediatelyTriggerBatch || this.autoBatchQueue.size > this.pendingAutoBatchedRunLimit) {
      await this.drainAutoBatchQueue();
    }
    if (this.autoBatchQueue.size > 0) {
      this.autoBatchTimeout = setTimeout(() => {
        this.autoBatchTimeout = void 0;
        void this.drainAutoBatchQueue().catch(console.error);
      }, oldTimeout ? this.autoBatchAggregationDelayMs : this.autoBatchInitialDelayMs);
    }
    return itemPromise;
  }
  async _getServerInfo() {
    const response = await fetch(`${this.apiUrl}/info`, {
      method: "GET",
      headers: { Accept: "application/json" },
      signal: AbortSignal.timeout(this.timeout_ms)
    });
    if (!response.ok) {
      await response.text();
      throw new Error("Failed to retrieve server info.");
    }
    return response.json();
  }
  async batchEndpointIsSupported() {
    try {
      this.serverInfo = await this._getServerInfo();
    } catch (e) {
      return false;
    }
    return true;
  }
  async createRun(run2) {
    var _a;
    if (!this._filterForSampling([run2]).length) {
      return;
    }
    const headers = { ...this.headers, "Content-Type": "application/json" };
    const session_name = run2.project_name;
    delete run2.project_name;
    const runCreate = this.prepareRunCreateOrUpdateInputs({
      session_name,
      ...run2,
      start_time: (_a = run2.start_time) != null ? _a : Date.now()
    });
    if (this.autoBatchTracing && runCreate.trace_id !== void 0 && runCreate.dotted_order !== void 0) {
      void this.processRunOperation({
        action: "create",
        item: runCreate
      }).catch(console.error);
      return;
    }
    const mergedRunCreateParams = await mergeRuntimeEnvIntoRunCreates([
      runCreate
    ]);
    const response = await this.caller.call(fetch, `${this.apiUrl}/runs`, {
      method: "POST",
      headers,
      body: JSON.stringify(mergedRunCreateParams[0]),
      signal: AbortSignal.timeout(this.timeout_ms)
    });
    await raiseForStatus(response, "create run");
  }
  /**
   * Batch ingest/upsert multiple runs in the Langsmith system.
   * @param runs
   */
  async batchIngestRuns({ runCreates, runUpdates }) {
    var _a, _b, _c, _d, _e;
    if (runCreates === void 0 && runUpdates === void 0) {
      return;
    }
    let preparedCreateParams = (_a = runCreates == null ? void 0 : runCreates.map((create) => this.prepareRunCreateOrUpdateInputs(create))) != null ? _a : [];
    let preparedUpdateParams = (_b = runUpdates == null ? void 0 : runUpdates.map((update) => this.prepareRunCreateOrUpdateInputs(update))) != null ? _b : [];
    if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {
      const createById = preparedCreateParams.reduce((params, run2) => {
        if (!run2.id) {
          return params;
        }
        params[run2.id] = run2;
        return params;
      }, {});
      const standaloneUpdates = [];
      for (const updateParam of preparedUpdateParams) {
        if (updateParam.id !== void 0 && createById[updateParam.id]) {
          createById[updateParam.id] = {
            ...createById[updateParam.id],
            ...updateParam
          };
        } else {
          standaloneUpdates.push(updateParam);
        }
      }
      preparedCreateParams = Object.values(createById);
      preparedUpdateParams = standaloneUpdates;
    }
    const rawBatch = {
      post: this._filterForSampling(preparedCreateParams),
      patch: this._filterForSampling(preparedUpdateParams, true)
    };
    if (!rawBatch.post.length && !rawBatch.patch.length) {
      return;
    }
    preparedCreateParams = await mergeRuntimeEnvIntoRunCreates(preparedCreateParams);
    if (this.batchEndpointSupported === void 0) {
      this.batchEndpointSupported = await this.batchEndpointIsSupported();
    }
    if (!this.batchEndpointSupported) {
      this.autoBatchTracing = false;
      for (const preparedCreateParam of rawBatch.post) {
        await this.createRun(preparedCreateParam);
      }
      for (const preparedUpdateParam of rawBatch.patch) {
        if (preparedUpdateParam.id !== void 0) {
          await this.updateRun(preparedUpdateParam.id, preparedUpdateParam);
        }
      }
      return;
    }
    const sizeLimitBytes = (_e = (_d = (_c = this.serverInfo) == null ? void 0 : _c.batch_ingest_config) == null ? void 0 : _d.size_limit_bytes) != null ? _e : DEFAULT_BATCH_SIZE_LIMIT_BYTES;
    const batchChunks = {
      post: [],
      patch: []
    };
    let currentBatchSizeBytes = 0;
    for (const k of ["post", "patch"]) {
      const key = k;
      const batchItems = rawBatch[key].reverse();
      let batchItem = batchItems.pop();
      while (batchItem !== void 0) {
        const stringifiedBatchItem = JSON.stringify(batchItem);
        if (currentBatchSizeBytes > 0 && currentBatchSizeBytes + stringifiedBatchItem.length > sizeLimitBytes) {
          await this._postBatchIngestRuns(JSON.stringify(batchChunks));
          currentBatchSizeBytes = 0;
          batchChunks.post = [];
          batchChunks.patch = [];
        }
        currentBatchSizeBytes += stringifiedBatchItem.length;
        batchChunks[key].push(batchItem);
        batchItem = batchItems.pop();
      }
    }
    if (batchChunks.post.length > 0 || batchChunks.patch.length > 0) {
      await this._postBatchIngestRuns(JSON.stringify(batchChunks));
    }
  }
  async _postBatchIngestRuns(body) {
    const headers = {
      ...this.headers,
      "Content-Type": "application/json",
      Accept: "application/json"
    };
    const response = await this.batchIngestCaller.call(fetch, `${this.apiUrl}/runs/batch`, {
      method: "POST",
      headers,
      body,
      signal: AbortSignal.timeout(this.timeout_ms)
    });
    await raiseForStatus(response, "batch create run");
  }
  async updateRun(runId, run2) {
    assertUuid(runId);
    if (run2.inputs) {
      run2.inputs = this.processInputs(run2.inputs);
    }
    if (run2.outputs) {
      run2.outputs = this.processOutputs(run2.outputs);
    }
    const data = { ...run2, id: runId };
    if (!this._filterForSampling([data], true).length) {
      return;
    }
    if (this.autoBatchTracing && data.trace_id !== void 0 && data.dotted_order !== void 0) {
      if (run2.end_time !== void 0 && data.parent_run_id === void 0) {
        await this.processRunOperation({ action: "update", item: data }, true);
        return;
      } else {
        void this.processRunOperation({ action: "update", item: data }).catch(console.error);
      }
      return;
    }
    const headers = { ...this.headers, "Content-Type": "application/json" };
    const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}`, {
      method: "PATCH",
      headers,
      body: JSON.stringify(run2),
      signal: AbortSignal.timeout(this.timeout_ms)
    });
    await raiseForStatus(response, "update run");
  }
  async readRun(runId, { loadChildRuns } = { loadChildRuns: false }) {
    assertUuid(runId);
    let run2 = await this._get(`/runs/${runId}`);
    if (loadChildRuns && run2.child_run_ids) {
      run2 = await this._loadChildRuns(run2);
    }
    return run2;
  }
  async getRunUrl({ runId, run: run2, projectOpts }) {
    if (run2 !== void 0) {
      let sessionId;
      if (run2.session_id) {
        sessionId = run2.session_id;
      } else if (projectOpts == null ? void 0 : projectOpts.projectName) {
        sessionId = (await this.readProject({ projectName: projectOpts == null ? void 0 : projectOpts.projectName })).id;
      } else if (projectOpts == null ? void 0 : projectOpts.projectId) {
        sessionId = projectOpts == null ? void 0 : projectOpts.projectId;
      } else {
        const project = await this.readProject({
          projectName: getEnvironmentVariable2("LANGCHAIN_PROJECT") || "default"
        });
        sessionId = project.id;
      }
      const tenantId = await this._getTenantId();
      return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run2.id}?poll=true`;
    } else if (runId !== void 0) {
      const run_ = await this.readRun(runId);
      if (!run_.app_path) {
        throw new Error(`Run ${runId} has no app_path`);
      }
      const baseUrl = this.getHostUrl();
      return `${baseUrl}${run_.app_path}`;
    } else {
      throw new Error("Must provide either runId or run");
    }
  }
  async _loadChildRuns(run2) {
    const childRuns = await toArray(this.listRuns({ id: run2.child_run_ids }));
    const treemap = {};
    const runs = {};
    childRuns.sort((a, b) => {
      var _a, _b;
      return ((_a = a == null ? void 0 : a.dotted_order) != null ? _a : "").localeCompare((_b = b == null ? void 0 : b.dotted_order) != null ? _b : "");
    });
    for (const childRun of childRuns) {
      if (childRun.parent_run_id === null || childRun.parent_run_id === void 0) {
        throw new Error(`Child run ${childRun.id} has no parent`);
      }
      if (!(childRun.parent_run_id in treemap)) {
        treemap[childRun.parent_run_id] = [];
      }
      treemap[childRun.parent_run_id].push(childRun);
      runs[childRun.id] = childRun;
    }
    run2.child_runs = treemap[run2.id] || [];
    for (const runId in treemap) {
      if (runId !== run2.id) {
        runs[runId].child_runs = treemap[runId];
      }
    }
    return run2;
  }
  /**
   * List runs from the LangSmith server.
   * @param projectId - The ID of the project to filter by.
   * @param projectName - The name of the project to filter by.
   * @param parentRunId - The ID of the parent run to filter by.
   * @param traceId - The ID of the trace to filter by.
   * @param referenceExampleId - The ID of the reference example to filter by.
   * @param startTime - The start time to filter by.
   * @param executionOrder - The execution order to filter by.
   * @param runType - The run type to filter by.
   * @param error - Indicates whether to filter by error runs.
   * @param id - The ID of the run to filter by.
   * @param query - The query string to filter by.
   * @param filter - The filter string to apply to the run spans.
   * @param traceFilter - The filter string to apply on the root run of the trace.
   * @param limit - The maximum number of runs to retrieve.
   * @returns {AsyncIterable<Run>} - The runs.
   *
   * @example
   * // List all runs in a project
   * const projectRuns = client.listRuns({ projectName: "<your_project>" });
   *
   * @example
   * // List LLM and Chat runs in the last 24 hours
   * const todaysLLMRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),
   *   run_type: "llm",
   * });
   *
   * @example
   * // List traces in a project
   * const rootRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   execution_order: 1,
   * });
   *
   * @example
   * // List runs without errors
   * const correctRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   error: false,
   * });
   *
   * @example
   * // List runs by run ID
   * const runIds = [
   *   "a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836",
   *   "9398e6be-964f-4aa4-8ae9-ad78cd4b7074",
   * ];
   * const selectedRuns = client.listRuns({ run_ids: runIds });
   *
   * @example
   * // List all "chain" type runs that took more than 10 seconds and had `total_tokens` greater than 5000
   * const chainRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(eq(run_type, "chain"), gt(latency, 10), gt(total_tokens, 5000))',
   * });
   *
   * @example
   * // List all runs called "extractor" whose root of the trace was assigned feedback "user_score" score of 1
   * const goodExtractorRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'eq(name, "extractor")',
   *   traceFilter: 'and(eq(feedback_key, "user_score"), eq(feedback_score, 1))',
   * });
   *
   * @example
   * // List all runs that started after a specific timestamp and either have "error" not equal to null or a "Correctness" feedback score equal to 0
   * const complexRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(gt(start_time, "2023-07-15T12:34:56Z"), or(neq(error, null), and(eq(feedback_key, "Correctness"), eq(feedback_score, 0.0))))',
   * });
   *
   * @example
   * // List all runs where `tags` include "experimental" or "beta" and `latency` is greater than 2 seconds
   * const taggedRuns = client.listRuns({
   *   projectName: "<your_project>",
   *   filter: 'and(or(has(tags, "experimental"), has(tags, "beta")), gt(latency, 2))',
   * });
   */
  async *listRuns(props) {
    const { projectId, projectName, parentRunId, traceId, referenceExampleId, startTime, executionOrder, runType, error, id, query, filter, traceFilter, limit } = props;
    let projectIds = [];
    if (projectId) {
      projectIds = Array.isArray(projectId) ? projectId : [projectId];
    }
    if (projectName) {
      const projectNames = Array.isArray(projectName) ? projectName : [projectName];
      const projectIds_ = await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)));
      projectIds.push(...projectIds_);
    }
    const body = {
      session: projectIds.length ? projectIds : null,
      run_type: runType,
      reference_example: referenceExampleId,
      query,
      filter,
      trace_filter: traceFilter,
      execution_order: executionOrder,
      parent_run: parentRunId ? [parentRunId] : null,
      start_time: startTime ? startTime.toISOString() : null,
      error,
      id,
      limit,
      trace: traceId
    };
    for await (const runs of this._getCursorPaginatedList("/runs/query", body)) {
      yield* runs;
    }
  }
  async shareRun(runId, { shareId } = {}) {
    const data = {
      run_id: runId,
      share_token: shareId || v4_default()
    };
    assertUuid(runId);
    const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {
      method: "PUT",
      headers: this.headers,
      body: JSON.stringify(data),
      signal: AbortSignal.timeout(this.timeout_ms)
    });
    const result = await response.json();
    if (result === null || !("share_token" in result)) {
      throw new Error("Invalid response from server");
    }
    return `${this.getHostUrl()}/public/${result["share_token"]}/r`;
  }
  async unshareRun(runId) {
    assertUuid(runId);
    const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms)
    });
    await raiseForStatus(response, "unshare run");
  }
  async readRunSharedLink(runId) {
    assertUuid(runId);
    const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms)
    });
    const result = await response.json();
    if (result === null || !("share_token" in result)) {
      return void 0;
    }
    return `${this.getHostUrl()}/public/${result["share_token"]}/r`;
  }
  async listSharedRuns(shareToken, { runIds } = {}) {
    const queryParams = new URLSearchParams({
      share_token: shareToken
    });
    if (runIds !== void 0) {
      for (const runId of runIds) {
        queryParams.append("id", runId);
      }
    }
    assertUuid(shareToken);
    const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms)
    });
    const runs = await response.json();
    return runs;
  }
  async readDatasetSharedSchema(datasetId, datasetName) {
    if (!datasetId && !datasetName) {
      throw new Error("Either datasetId or datasetName must be given");
    }
    if (!datasetId) {
      const dataset = await this.readDataset({ datasetName });
      datasetId = dataset.id;
    }
    assertUuid(datasetId);
    const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms)
    });
    const shareSchema = await response.json();
    shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;
    return shareSchema;
  }
  async shareDataset(datasetId, datasetName) {
    if (!datasetId && !datasetName) {
      throw new Error("Either datasetId or datasetName must be given");
    }
    if (!datasetId) {
      const dataset = await this.readDataset({ datasetName });
      datasetId = dataset.id;
    }
    const data = {
      dataset_id: datasetId
    };
    assertUuid(datasetId);
    const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {
      method: "PUT",
      headers: this.headers,
      body: JSON.stringify(data),
      signal: AbortSignal.timeout(this.timeout_ms)
    });
    const shareSchema = await response.json();
    shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;
    return shareSchema;
  }
  async unshareDataset(datasetId) {
    assertUuid(datasetId);
    const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms)
    });
    await raiseForStatus(response, "unshare dataset");
  }
  async readSharedDataset(shareToken) {
    assertUuid(shareToken);
    const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/datasets`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms)
    });
    const dataset = await response.json();
    return dataset;
  }
  async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null }) {
    const upsert_ = upsert ? `?upsert=true` : "";
    const endpoint = `${this.apiUrl}/sessions${upsert_}`;
    const extra = projectExtra || {};
    if (metadata) {
      extra["metadata"] = metadata;
    }
    const body = {
      name: projectName,
      extra,
      description
    };
    if (referenceDatasetId !== null) {
      body["reference_dataset_id"] = referenceDatasetId;
    }
    const response = await this.caller.call(fetch, endpoint, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(body),
      signal: AbortSignal.timeout(this.timeout_ms)
    });
    const result = await response.json();
    if (!response.ok) {
      throw new Error(`Failed to create session ${projectName}: ${response.status} ${response.statusText}`);
    }
    return result;
  }
  async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null }) {
    const endpoint = `${this.apiUrl}/sessions/${projectId}`;
    let extra = projectExtra;
    if (metadata) {
      extra = { ...extra || {}, metadata };
    }
    const body = {
      name,
      extra,
      description,
      end_time: endTime ? new Date(endTime).toISOString() : null
    };
    const response = await this.caller.call(fetch, endpoint, {
      method: "PATCH",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(body),
      signal: AbortSignal.timeout(this.timeout_ms)
    });
    const result = await response.json();
    if (!response.ok) {
      throw new Error(`Failed to update project ${projectId}: ${response.status} ${response.statusText}`);
    }
    return result;
  }
  async hasProject({ projectId, projectName }) {
    let path = "/sessions";
    const params = new URLSearchParams();
    if (projectId !== void 0 && projectName !== void 0) {
      throw new Error("Must provide either projectName or projectId, not both");
    } else if (projectId !== void 0) {
      assertUuid(projectId);
      path += `/${projectId}`;
    } else if (projectName !== void 0) {
      params.append("name", projectName);
    } else {
      throw new Error("Must provide projectName or projectId");
    }
    const response = await this.caller.call(fetch, `${this.apiUrl}${path}?${params}`, {
      method: "GET",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms)
    });
    try {
      const result = await response.json();
      if (!response.ok) {
        return false;
      }
      if (Array.isArray(result)) {
        return result.length > 0;
      }
      return true;
    } catch (e) {
      return false;
    }
  }
  async readProject({ projectId, projectName, includeStats }) {
    let path = "/sessions";
    const params = new URLSearchParams();
    if (projectId !== void 0 && projectName !== void 0) {
      throw new Error("Must provide either projectName or projectId, not both");
    } else if (projectId !== void 0) {
      assertUuid(projectId);
      path += `/${projectId}`;
    } else if (projectName !== void 0) {
      params.append("name", projectName);
    } else {
      throw new Error("Must provide projectName or projectId");
    }
    if (includeStats !== void 0) {
      params.append("include_stats", includeStats.toString());
    }
    const response = await this._get(path, params);
    let result;
    if (Array.isArray(response)) {
      if (response.length === 0) {
        throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);
      }
      result = response[0];
    } else {
      result = response;
    }
    return result;
  }
  async _getTenantId() {
    if (this._tenantId !== null) {
      return this._tenantId;
    }
    const queryParams = new URLSearchParams({ limit: "1" });
    for await (const projects of this._getPaginated("/sessions", queryParams)) {
      this._tenantId = projects[0].tenant_id;
      return projects[0].tenant_id;
    }
    throw new Error("No projects found to resolve tenant.");
  }
  async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, referenceFree } = {}) {
    const params = new URLSearchParams();
    if (projectIds !== void 0) {
      for (const projectId of projectIds) {
        params.append("id", projectId);
      }
    }
    if (name !== void 0) {
      params.append("name", name);
    }
    if (nameContains !== void 0) {
      params.append("name_contains", nameContains);
    }
    if (referenceDatasetId !== void 0) {
      params.append("reference_dataset", referenceDatasetId);
    } else if (referenceDatasetName !== void 0) {
      const dataset = await this.readDataset({
        datasetName: referenceDatasetName
      });
      params.append("reference_dataset", dataset.id);
    }
    if (referenceFree !== void 0) {
      params.append("reference_free", referenceFree.toString());
    }
    for await (const projects of this._getPaginated("/sessions", params)) {
      yield* projects;
    }
  }
  async deleteProject({ projectId, projectName }) {
    let projectId_;
    if (projectId === void 0 && projectName === void 0) {
      throw new Error("Must provide projectName or projectId");
    } else if (projectId !== void 0 && projectName !== void 0) {
      throw new Error("Must provide either projectName or projectId, not both");
    } else if (projectId === void 0) {
      projectId_ = (await this.readProject({ projectName })).id;
    } else {
      projectId_ = projectId;
    }
    assertUuid(projectId_);
    const response = await this.caller.call(fetch, `${this.apiUrl}/sessions/${projectId_}`, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms)
    });
    await raiseForStatus(response, `delete session ${projectId_} (${projectName})`);
  }
  async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name }) {
    const url = `${this.apiUrl}/datasets/upload`;
    const formData = new FormData();
    formData.append("file", csvFile, fileName);
    inputKeys.forEach((key) => {
      formData.append("input_keys", key);
    });
    outputKeys.forEach((key) => {
      formData.append("output_keys", key);
    });
    if (description) {
      formData.append("description", description);
    }
    if (dataType) {
      formData.append("data_type", dataType);
    }
    if (name) {
      formData.append("name", name);
    }
    const response = await this.caller.call(fetch, url, {
      method: "POST",
      headers: this.headers,
      body: formData,
      signal: AbortSignal.timeout(this.timeout_ms)
    });
    if (!response.ok) {
      const result2 = await response.json();
      if (result2.detail && result2.detail.includes("already exists")) {
        throw new Error(`Dataset ${fileName} already exists`);
      }
      throw new Error(`Failed to upload CSV: ${response.status} ${response.statusText}`);
    }
    const result = await response.json();
    return result;
  }
  async createDataset(name, { description, dataType } = {}) {
    const body = {
      name,
      description
    };
    if (dataType) {
      body.data_type = dataType;
    }
    const response = await this.caller.call(fetch, `${this.apiUrl}/datasets`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(body),
      signal: AbortSignal.timeout(this.timeout_ms)
    });
    if (!response.ok) {
      const result2 = await response.json();
      if (result2.detail && result2.detail.includes("already exists")) {
        throw new Error(`Dataset ${name} already exists`);
      }
      throw new Error(`Failed to create dataset ${response.status} ${response.statusText}`);
    }
    const result = await response.json();
    return result;
  }
  async readDataset({ datasetId, datasetName }) {
    let path = "/datasets";
    const params = new URLSearchParams({ limit: "1" });
    if (datasetId !== void 0 && datasetName !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId !== void 0) {
      assertUuid(datasetId);
      path += `/${datasetId}`;
    } else if (datasetName !== void 0) {
      params.append("name", datasetName);
    } else {
      throw new Error("Must provide datasetName or datasetId");
    }
    const response = await this._get(path, params);
    let result;
    if (Array.isArray(response)) {
      if (response.length === 0) {
        throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);
      }
      result = response[0];
    } else {
      result = response;
    }
    return result;
  }
  async readDatasetOpenaiFinetuning({ datasetId, datasetName }) {
    const path = "/datasets";
    if (datasetId !== void 0) {
    } else if (datasetName !== void 0) {
      datasetId = (await this.readDataset({ datasetName })).id;
    } else {
      throw new Error("Must provide datasetName or datasetId");
    }
    const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);
    const datasetText = await response.text();
    const dataset = datasetText.trim().split("\n").map((line) => JSON.parse(line));
    return dataset;
  }
  async *listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains } = {}) {
    const path = "/datasets";
    const params = new URLSearchParams({
      limit: limit.toString(),
      offset: offset.toString()
    });
    if (datasetIds !== void 0) {
      for (const id_ of datasetIds) {
        params.append("id", id_);
      }
    }
    if (datasetName !== void 0) {
      params.append("name", datasetName);
    }
    if (datasetNameContains !== void 0) {
      params.append("name_contains", datasetNameContains);
    }
    for await (const datasets of this._getPaginated(path, params)) {
      yield* datasets;
    }
  }
  async deleteDataset({ datasetId, datasetName }) {
    let path = "/datasets";
    let datasetId_ = datasetId;
    if (datasetId !== void 0 && datasetName !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetName !== void 0) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    }
    if (datasetId_ !== void 0) {
      assertUuid(datasetId_);
      path += `/${datasetId_}`;
    } else {
      throw new Error("Must provide datasetName or datasetId");
    }
    const response = await this.caller.call(fetch, this.apiUrl + path, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms)
    });
    if (!response.ok) {
      throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);
    }
    await response.json();
  }
  async createExample(inputs, outputs, { datasetId, datasetName, createdAt, exampleId }) {
    let datasetId_ = datasetId;
    if (datasetId_ === void 0 && datasetName === void 0) {
      throw new Error("Must provide either datasetName or datasetId");
    } else if (datasetId_ !== void 0 && datasetName !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId_ === void 0) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    }
    const createdAt_ = createdAt || /* @__PURE__ */ new Date();
    const data = {
      dataset_id: datasetId_,
      inputs,
      outputs,
      created_at: createdAt_ == null ? void 0 : createdAt_.toISOString(),
      id: exampleId
    };
    const response = await this.caller.call(fetch, `${this.apiUrl}/examples`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(data),
      signal: AbortSignal.timeout(this.timeout_ms)
    });
    if (!response.ok) {
      throw new Error(`Failed to create example: ${response.status} ${response.statusText}`);
    }
    const result = await response.json();
    return result;
  }
  async createExamples(props) {
    const { inputs, outputs, sourceRunIds, exampleIds, datasetId, datasetName } = props;
    let datasetId_ = datasetId;
    if (datasetId_ === void 0 && datasetName === void 0) {
      throw new Error("Must provide either datasetName or datasetId");
    } else if (datasetId_ !== void 0 && datasetName !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId_ === void 0) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    }
    const formattedExamples = inputs.map((input, idx) => {
      return {
        dataset_id: datasetId_,
        inputs: input,
        outputs: outputs ? outputs[idx] : void 0,
        id: exampleIds ? exampleIds[idx] : void 0,
        source_run_id: sourceRunIds ? sourceRunIds[idx] : void 0
      };
    });
    const response = await this.caller.call(fetch, `${this.apiUrl}/examples/bulk`, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(formattedExamples),
      signal: AbortSignal.timeout(this.timeout_ms)
    });
    if (!response.ok) {
      throw new Error(`Failed to create examples: ${response.status} ${response.statusText}`);
    }
    const result = await response.json();
    return result;
  }
  async createLLMExample(input, generation, options) {
    return this.createExample({ input }, { output: generation }, options);
  }
  async createChatExample(input, generations, options) {
    const finalInput = input.map((message) => {
      if (isLangChainMessage(message)) {
        return convertLangChainMessageToExample(message);
      }
      return message;
    });
    const finalOutput = isLangChainMessage(generations) ? convertLangChainMessageToExample(generations) : generations;
    return this.createExample({ input: finalInput }, { output: finalOutput }, options);
  }
  async readExample(exampleId) {
    assertUuid(exampleId);
    const path = `/examples/${exampleId}`;
    return await this._get(path);
  }
  async *listExamples({ datasetId, datasetName, exampleIds } = {}) {
    let datasetId_;
    if (datasetId !== void 0 && datasetName !== void 0) {
      throw new Error("Must provide either datasetName or datasetId, not both");
    } else if (datasetId !== void 0) {
      datasetId_ = datasetId;
    } else if (datasetName !== void 0) {
      const dataset = await this.readDataset({ datasetName });
      datasetId_ = dataset.id;
    } else {
      throw new Error("Must provide a datasetName or datasetId");
    }
    const params = new URLSearchParams({ dataset: datasetId_ });
    if (exampleIds !== void 0) {
      for (const id_ of exampleIds) {
        params.append("id", id_);
      }
    }
    for await (const examples of this._getPaginated("/examples", params)) {
      yield* examples;
    }
  }
  async deleteExample(exampleId) {
    assertUuid(exampleId);
    const path = `/examples/${exampleId}`;
    const response = await this.caller.call(fetch, this.apiUrl + path, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms)
    });
    if (!response.ok) {
      throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);
    }
    await response.json();
  }
  async updateExample(exampleId, update) {
    assertUuid(exampleId);
    const response = await this.caller.call(fetch, `${this.apiUrl}/examples/${exampleId}`, {
      method: "PATCH",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(update),
      signal: AbortSignal.timeout(this.timeout_ms)
    });
    if (!response.ok) {
      throw new Error(`Failed to update example ${exampleId}: ${response.status} ${response.statusText}`);
    }
    const result = await response.json();
    return result;
  }
  async evaluateRun(run2, evaluator, { sourceInfo, loadChildRuns, referenceExample } = { loadChildRuns: false }) {
    var _a;
    let run_;
    if (typeof run2 === "string") {
      run_ = await this.readRun(run2, { loadChildRuns });
    } else if (typeof run2 === "object" && "id" in run2) {
      run_ = run2;
    } else {
      throw new Error(`Invalid run type: ${typeof run2}`);
    }
    if (run_.reference_example_id !== null && run_.reference_example_id !== void 0) {
      referenceExample = await this.readExample(run_.reference_example_id);
    }
    const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);
    let sourceInfo_ = sourceInfo != null ? sourceInfo : {};
    if (feedbackResult.evaluatorInfo) {
      sourceInfo_ = { ...sourceInfo_, ...feedbackResult.evaluatorInfo };
    }
    const runId = (_a = feedbackResult.targetRunId) != null ? _a : run_.id;
    return await this.createFeedback(runId, feedbackResult.key, {
      score: feedbackResult == null ? void 0 : feedbackResult.score,
      value: feedbackResult == null ? void 0 : feedbackResult.value,
      comment: feedbackResult == null ? void 0 : feedbackResult.comment,
      correction: feedbackResult == null ? void 0 : feedbackResult.correction,
      sourceInfo: sourceInfo_,
      feedbackSourceType: "model",
      sourceRunId: feedbackResult == null ? void 0 : feedbackResult.sourceRunId
    });
  }
  async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = "api", sourceRunId, feedbackId, eager = false }) {
    var _a;
    const feedback_source = {
      type: feedbackSourceType != null ? feedbackSourceType : "api",
      metadata: sourceInfo != null ? sourceInfo : {}
    };
    if (sourceRunId !== void 0 && (feedback_source == null ? void 0 : feedback_source.metadata) !== void 0 && !feedback_source.metadata["__run"]) {
      feedback_source.metadata["__run"] = { run_id: sourceRunId };
    }
    if ((feedback_source == null ? void 0 : feedback_source.metadata) !== void 0 && ((_a = feedback_source.metadata["__run"]) == null ? void 0 : _a.run_id) !== void 0) {
      assertUuid(feedback_source.metadata["__run"].run_id);
    }
    const feedback = {
      id: feedbackId != null ? feedbackId : v4_default(),
      run_id: runId,
      key,
      score,
      value,
      correction,
      comment,
      feedback_source
    };
    const url = `${this.apiUrl}/feedback` + (eager ? "/eager" : "");
    const response = await this.caller.call(fetch, url, {
      method: "POST",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(feedback),
      signal: AbortSignal.timeout(this.timeout_ms)
    });
    await raiseForStatus(response, "create feedback");
    return feedback;
  }
  async updateFeedback(feedbackId, { score, value, correction, comment }) {
    const feedbackUpdate = {};
    if (score !== void 0 && score !== null) {
      feedbackUpdate["score"] = score;
    }
    if (value !== void 0 && value !== null) {
      feedbackUpdate["value"] = value;
    }
    if (correction !== void 0 && correction !== null) {
      feedbackUpdate["correction"] = correction;
    }
    if (comment !== void 0 && comment !== null) {
      feedbackUpdate["comment"] = comment;
    }
    assertUuid(feedbackId);
    const response = await this.caller.call(fetch, `${this.apiUrl}/feedback/${feedbackId}`, {
      method: "PATCH",
      headers: { ...this.headers, "Content-Type": "application/json" },
      body: JSON.stringify(feedbackUpdate),
      signal: AbortSignal.timeout(this.timeout_ms)
    });
    await raiseForStatus(response, "update feedback");
  }
  async readFeedback(feedbackId) {
    assertUuid(feedbackId);
    const path = `/feedback/${feedbackId}`;
    const response = await this._get(path);
    return response;
  }
  async deleteFeedback(feedbackId) {
    assertUuid(feedbackId);
    const path = `/feedback/${feedbackId}`;
    const response = await this.caller.call(fetch, this.apiUrl + path, {
      method: "DELETE",
      headers: this.headers,
      signal: AbortSignal.timeout(this.timeout_ms)
    });
    if (!response.ok) {
      throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);
    }
    await response.json();
  }
  async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes } = {}) {
    const queryParams = new URLSearchParams();
    if (runIds) {
      queryParams.append("run", runIds.join(","));
    }
    if (feedbackKeys) {
      for (const key of feedbackKeys) {
        queryParams.append("key", key);
      }
    }
    if (feedbackSourceTypes) {
      for (const type of feedbackSourceTypes) {
        queryParams.append("source", type);
      }
    }
    for await (const feedbacks of this._getPaginated("/feedback", queryParams)) {
      yield* feedbacks;
    }
  }
};

// ../../node_modules/langsmith/dist/index.js
var __version__ = "0.1.8";

// ../../node_modules/@langchain/core/dist/tracers/tracer_langchain.js
var LangChainTracer = class extends BaseTracer {
  constructor(fields = {}) {
    var _a;
    super(fields);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "langchain_tracer"
    });
    Object.defineProperty(this, "projectName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "exampleId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "client", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    const { exampleId, projectName, client } = fields;
    this.projectName = (_a = projectName != null ? projectName : getEnvironmentVariable("LANGCHAIN_PROJECT")) != null ? _a : getEnvironmentVariable("LANGCHAIN_SESSION");
    this.exampleId = exampleId;
    this.client = client != null ? client : new Client({});
  }
  async _convertToCreate(run2, example_id = void 0) {
    return {
      ...run2,
      extra: {
        ...run2.extra,
        runtime: await getRuntimeEnvironment()
      },
      child_runs: void 0,
      session_name: this.projectName,
      reference_example_id: run2.parent_run_id ? void 0 : example_id
    };
  }
  async persistRun(_run) {
  }
  async onRunCreate(run2) {
    const persistedRun = await this._convertToCreate(run2, this.exampleId);
    await this.client.createRun(persistedRun);
  }
  async onRunUpdate(run2) {
    const runUpdate = {
      end_time: run2.end_time,
      error: run2.error,
      outputs: run2.outputs,
      events: run2.events,
      inputs: run2.inputs,
      trace_id: run2.trace_id,
      dotted_order: run2.dotted_order,
      parent_run_id: run2.parent_run_id
    };
    await this.client.updateRun(run2.id, runUpdate);
  }
  getRun(id) {
    return this.runMap.get(id);
  }
};

// ../../node_modules/@langchain/core/dist/messages/index.js
function mergeContent(firstContent, secondContent) {
  if (typeof firstContent === "string") {
    if (typeof secondContent === "string") {
      return firstContent + secondContent;
    } else {
      return [{ type: "text", text: firstContent }, ...secondContent];
    }
  } else if (Array.isArray(secondContent)) {
    return [...firstContent, ...secondContent];
  } else {
    return [...firstContent, { type: "text", text: secondContent }];
  }
}
var BaseMessage = class extends Serializable {
  get lc_aliases() {
    return { additional_kwargs: "additional_kwargs" };
  }
  /**
   * @deprecated
   * Use {@link BaseMessage.content} instead.
   */
  get text() {
    return typeof this.content === "string" ? this.content : "";
  }
  constructor(fields, kwargs) {
    if (typeof fields === "string") {
      fields = { content: fields, additional_kwargs: kwargs };
    }
    if (!fields.additional_kwargs) {
      fields.additional_kwargs = {};
    }
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "messages"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "content", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "additional_kwargs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = fields.name;
    this.content = fields.content;
    this.additional_kwargs = fields.additional_kwargs;
  }
  toDict() {
    return {
      type: this._getType(),
      data: this.toJSON().kwargs
    };
  }
  toChunk() {
    const type = this._getType();
    if (type === "human") {
      return new HumanMessageChunk({ ...this });
    } else if (type === "ai") {
      return new AIMessageChunk({ ...this });
    } else if (type === "system") {
      return new SystemMessageChunk({ ...this });
    } else if (type === "function") {
      return new FunctionMessageChunk({ ...this });
    } else if (ChatMessage.isInstance(this)) {
      return new ChatMessageChunk({ ...this });
    } else {
      throw new Error("Unknown message type.");
    }
  }
};
function isOpenAIToolCallArray(value) {
  return Array.isArray(value) && value.every((v) => typeof v.index === "number");
}
var BaseMessageChunk = class extends BaseMessage {
  static _mergeAdditionalKwargs(left, right) {
    var _a, _b;
    const merged = { ...left };
    for (const [key, value] of Object.entries(right)) {
      if (merged[key] === void 0) {
        merged[key] = value;
      } else if (typeof merged[key] !== typeof value) {
        throw new Error(`additional_kwargs[${key}] already exists in the message chunk, but with a different type.`);
      } else if (typeof merged[key] === "string") {
        merged[key] = merged[key] + value;
      } else if (!Array.isArray(merged[key]) && typeof merged[key] === "object") {
        merged[key] = this._mergeAdditionalKwargs(merged[key], value);
      } else if (key === "tool_calls" && isOpenAIToolCallArray(merged[key]) && isOpenAIToolCallArray(value)) {
        for (const toolCall of value) {
          if (((_a = merged[key]) == null ? void 0 : _a[toolCall.index]) !== void 0) {
            merged[key] = (_b = merged[key]) == null ? void 0 : _b.map((value2, i) => {
              var _a2, _b2, _c;
              if (i !== toolCall.index) {
                return value2;
              }
              return {
                ...value2,
                ...toolCall,
                function: {
                  name: (_a2 = toolCall.function.name) != null ? _a2 : value2.function.name,
                  arguments: ((_b2 = value2.function.arguments) != null ? _b2 : "") + ((_c = toolCall.function.arguments) != null ? _c : "")
                }
              };
            });
          } else {
            merged[key][toolCall.index] = toolCall;
          }
        }
      } else {
        throw new Error(`additional_kwargs[${key}] already exists in this message chunk.`);
      }
    }
    return merged;
  }
};
var HumanMessage = class extends BaseMessage {
  static lc_name() {
    return "HumanMessage";
  }
  _getType() {
    return "human";
  }
};
var HumanMessageChunk = class _HumanMessageChunk extends BaseMessageChunk {
  static lc_name() {
    return "HumanMessageChunk";
  }
  _getType() {
    return "human";
  }
  concat(chunk) {
    return new _HumanMessageChunk({
      content: mergeContent(this.content, chunk.content),
      additional_kwargs: _HumanMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs)
    });
  }
};
var AIMessage = class extends BaseMessage {
  static lc_name() {
    return "AIMessage";
  }
  _getType() {
    return "ai";
  }
};
var AIMessageChunk = class _AIMessageChunk extends BaseMessageChunk {
  static lc_name() {
    return "AIMessageChunk";
  }
  _getType() {
    return "ai";
  }
  concat(chunk) {
    return new _AIMessageChunk({
      content: mergeContent(this.content, chunk.content),
      additional_kwargs: _AIMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs)
    });
  }
};
var SystemMessage = class extends BaseMessage {
  static lc_name() {
    return "SystemMessage";
  }
  _getType() {
    return "system";
  }
};
var SystemMessageChunk = class _SystemMessageChunk extends BaseMessageChunk {
  static lc_name() {
    return "SystemMessageChunk";
  }
  _getType() {
    return "system";
  }
  concat(chunk) {
    return new _SystemMessageChunk({
      content: mergeContent(this.content, chunk.content),
      additional_kwargs: _SystemMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs)
    });
  }
};
var FunctionMessageChunk = class _FunctionMessageChunk extends BaseMessageChunk {
  static lc_name() {
    return "FunctionMessageChunk";
  }
  _getType() {
    return "function";
  }
  concat(chunk) {
    var _a;
    return new _FunctionMessageChunk({
      content: mergeContent(this.content, chunk.content),
      additional_kwargs: _FunctionMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs),
      name: (_a = this.name) != null ? _a : ""
    });
  }
};
var ChatMessage = class _ChatMessage extends BaseMessage {
  static lc_name() {
    return "ChatMessage";
  }
  static _chatMessageClass() {
    return _ChatMessage;
  }
  constructor(fields, role) {
    if (typeof fields === "string") {
      fields = { content: fields, role };
    }
    super(fields);
    Object.defineProperty(this, "role", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.role = fields.role;
  }
  _getType() {
    return "generic";
  }
  static isInstance(message) {
    return message._getType() === "generic";
  }
};
function isBaseMessage(messageLike) {
  return typeof (messageLike == null ? void 0 : messageLike._getType) === "function";
}
function coerceMessageLikeToMessage(messageLike) {
  if (typeof messageLike === "string") {
    return new HumanMessage(messageLike);
  } else if (isBaseMessage(messageLike)) {
    return messageLike;
  }
  const [type, content] = messageLike;
  if (type === "human" || type === "user") {
    return new HumanMessage({ content });
  } else if (type === "ai" || type === "assistant") {
    return new AIMessage({ content });
  } else if (type === "system") {
    return new SystemMessage({ content });
  } else {
    throw new Error(`Unable to coerce message from array: only human, AI, or system message coercion is currently supported.`);
  }
}
var ChatMessageChunk = class _ChatMessageChunk extends BaseMessageChunk {
  static lc_name() {
    return "ChatMessageChunk";
  }
  constructor(fields, role) {
    if (typeof fields === "string") {
      fields = { content: fields, role };
    }
    super(fields);
    Object.defineProperty(this, "role", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.role = fields.role;
  }
  _getType() {
    return "generic";
  }
  concat(chunk) {
    return new _ChatMessageChunk({
      content: mergeContent(this.content, chunk.content),
      additional_kwargs: _ChatMessageChunk._mergeAdditionalKwargs(this.additional_kwargs, chunk.additional_kwargs),
      role: this.role
    });
  }
};
function getBufferString(messages, humanPrefix = "Human", aiPrefix = "AI") {
  const string_messages = [];
  for (const m of messages) {
    let role;
    if (m._getType() === "human") {
      role = humanPrefix;
    } else if (m._getType() === "ai") {
      role = aiPrefix;
    } else if (m._getType() === "system") {
      role = "System";
    } else if (m._getType() === "function") {
      role = "Function";
    } else if (m._getType() === "tool") {
      role = "Tool";
    } else if (m._getType() === "generic") {
      role = m.role;
    } else {
      throw new Error(`Got unsupported message type: ${m._getType()}`);
    }
    const nameStr = m.name ? `${m.name}, ` : "";
    string_messages.push(`${role}: ${nameStr}${m.content}`);
  }
  return string_messages.join("\n");
}

// ../../node_modules/@langchain/core/dist/tracers/initialize.js
async function getTracingV2CallbackHandler() {
  return new LangChainTracer();
}

// ../../node_modules/@langchain/core/dist/callbacks/promises.js
var import_p_queue2 = __toESM(require_dist(), 1);
var queue;
function createQueue() {
  const PQueue = "default" in import_p_queue2.default ? import_p_queue2.default.default : import_p_queue2.default;
  return new PQueue({
    autoStart: true,
    concurrency: 1
  });
}
async function consumeCallback(promiseFn, wait) {
  if (wait === true) {
    await promiseFn();
  } else {
    if (typeof queue === "undefined") {
      queue = createQueue();
    }
    void queue.add(promiseFn);
  }
}

// ../../node_modules/@langchain/core/dist/callbacks/manager.js
var BaseCallbackManager = class {
  setHandler(handler) {
    return this.setHandlers([handler]);
  }
};
var BaseRunManager = class {
  constructor(runId, handlers, inheritableHandlers, tags, inheritableTags, metadata, inheritableMetadata, _parentRunId) {
    Object.defineProperty(this, "runId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: runId
    });
    Object.defineProperty(this, "handlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: handlers
    });
    Object.defineProperty(this, "inheritableHandlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: inheritableHandlers
    });
    Object.defineProperty(this, "tags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: tags
    });
    Object.defineProperty(this, "inheritableTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: inheritableTags
    });
    Object.defineProperty(this, "metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: metadata
    });
    Object.defineProperty(this, "inheritableMetadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: inheritableMetadata
    });
    Object.defineProperty(this, "_parentRunId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: _parentRunId
    });
  }
  async handleText(text2) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      try {
        await ((_a = handler.handleText) == null ? void 0 : _a.call(handler, text2, this.runId, this._parentRunId, this.tags));
      } catch (err) {
        console.error(`Error in handler ${handler.constructor.name}, handleText: ${err}`);
      }
    }, handler.awaitHandlers)));
  }
};
var CallbackManagerForRetrieverRun = class extends BaseRunManager {
  getChild(tag) {
    const manager = new CallbackManager(this.runId);
    manager.setHandlers(this.inheritableHandlers);
    manager.addTags(this.inheritableTags);
    manager.addMetadata(this.inheritableMetadata);
    if (tag) {
      manager.addTags([tag], false);
    }
    return manager;
  }
  async handleRetrieverEnd(documents) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      if (!handler.ignoreRetriever) {
        try {
          await ((_a = handler.handleRetrieverEnd) == null ? void 0 : _a.call(handler, documents, this.runId, this._parentRunId, this.tags));
        } catch (err) {
          console.error(`Error in handler ${handler.constructor.name}, handleRetriever`);
        }
      }
    }, handler.awaitHandlers)));
  }
  async handleRetrieverError(err) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      if (!handler.ignoreRetriever) {
        try {
          await ((_a = handler.handleRetrieverError) == null ? void 0 : _a.call(handler, err, this.runId, this._parentRunId, this.tags));
        } catch (error) {
          console.error(`Error in handler ${handler.constructor.name}, handleRetrieverError: ${error}`);
        }
      }
    }, handler.awaitHandlers)));
  }
};
var CallbackManagerForLLMRun = class extends BaseRunManager {
  async handleLLMNewToken(token, idx, _runId, _parentRunId, _tags, fields) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      if (!handler.ignoreLLM) {
        try {
          await ((_a = handler.handleLLMNewToken) == null ? void 0 : _a.call(handler, token, idx != null ? idx : { prompt: 0, completion: 0 }, this.runId, this._parentRunId, this.tags, fields));
        } catch (err) {
          console.error(`Error in handler ${handler.constructor.name}, handleLLMNewToken: ${err}`);
        }
      }
    }, handler.awaitHandlers)));
  }
  async handleLLMError(err) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      if (!handler.ignoreLLM) {
        try {
          await ((_a = handler.handleLLMError) == null ? void 0 : _a.call(handler, err, this.runId, this._parentRunId, this.tags));
        } catch (err2) {
          console.error(`Error in handler ${handler.constructor.name}, handleLLMError: ${err2}`);
        }
      }
    }, handler.awaitHandlers)));
  }
  async handleLLMEnd(output) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      if (!handler.ignoreLLM) {
        try {
          await ((_a = handler.handleLLMEnd) == null ? void 0 : _a.call(handler, output, this.runId, this._parentRunId, this.tags));
        } catch (err) {
          console.error(`Error in handler ${handler.constructor.name}, handleLLMEnd: ${err}`);
        }
      }
    }, handler.awaitHandlers)));
  }
};
var CallbackManagerForChainRun = class extends BaseRunManager {
  getChild(tag) {
    const manager = new CallbackManager(this.runId);
    manager.setHandlers(this.inheritableHandlers);
    manager.addTags(this.inheritableTags);
    manager.addMetadata(this.inheritableMetadata);
    if (tag) {
      manager.addTags([tag], false);
    }
    return manager;
  }
  async handleChainError(err, _runId, _parentRunId, _tags, kwargs) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      if (!handler.ignoreChain) {
        try {
          await ((_a = handler.handleChainError) == null ? void 0 : _a.call(handler, err, this.runId, this._parentRunId, this.tags, kwargs));
        } catch (err2) {
          console.error(`Error in handler ${handler.constructor.name}, handleChainError: ${err2}`);
        }
      }
    }, handler.awaitHandlers)));
  }
  async handleChainEnd(output, _runId, _parentRunId, _tags, kwargs) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      if (!handler.ignoreChain) {
        try {
          await ((_a = handler.handleChainEnd) == null ? void 0 : _a.call(handler, output, this.runId, this._parentRunId, this.tags, kwargs));
        } catch (err) {
          console.error(`Error in handler ${handler.constructor.name}, handleChainEnd: ${err}`);
        }
      }
    }, handler.awaitHandlers)));
  }
  async handleAgentAction(action) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      if (!handler.ignoreAgent) {
        try {
          await ((_a = handler.handleAgentAction) == null ? void 0 : _a.call(handler, action, this.runId, this._parentRunId, this.tags));
        } catch (err) {
          console.error(`Error in handler ${handler.constructor.name}, handleAgentAction: ${err}`);
        }
      }
    }, handler.awaitHandlers)));
  }
  async handleAgentEnd(action) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      if (!handler.ignoreAgent) {
        try {
          await ((_a = handler.handleAgentEnd) == null ? void 0 : _a.call(handler, action, this.runId, this._parentRunId, this.tags));
        } catch (err) {
          console.error(`Error in handler ${handler.constructor.name}, handleAgentEnd: ${err}`);
        }
      }
    }, handler.awaitHandlers)));
  }
};
var CallbackManagerForToolRun = class extends BaseRunManager {
  getChild(tag) {
    const manager = new CallbackManager(this.runId);
    manager.setHandlers(this.inheritableHandlers);
    manager.addTags(this.inheritableTags);
    manager.addMetadata(this.inheritableMetadata);
    if (tag) {
      manager.addTags([tag], false);
    }
    return manager;
  }
  async handleToolError(err) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      if (!handler.ignoreAgent) {
        try {
          await ((_a = handler.handleToolError) == null ? void 0 : _a.call(handler, err, this.runId, this._parentRunId, this.tags));
        } catch (err2) {
          console.error(`Error in handler ${handler.constructor.name}, handleToolError: ${err2}`);
        }
      }
    }, handler.awaitHandlers)));
  }
  async handleToolEnd(output) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      if (!handler.ignoreAgent) {
        try {
          await ((_a = handler.handleToolEnd) == null ? void 0 : _a.call(handler, output, this.runId, this._parentRunId, this.tags));
        } catch (err) {
          console.error(`Error in handler ${handler.constructor.name}, handleToolEnd: ${err}`);
        }
      }
    }, handler.awaitHandlers)));
  }
};
var CallbackManager = class _CallbackManager extends BaseCallbackManager {
  constructor(parentRunId, options) {
    var _a, _b, _c, _d, _e, _f;
    super();
    Object.defineProperty(this, "handlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "inheritableHandlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "tags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "inheritableTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "inheritableMetadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "callback_manager"
    });
    Object.defineProperty(this, "_parentRunId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.handlers = (_a = options == null ? void 0 : options.handlers) != null ? _a : this.handlers;
    this.inheritableHandlers = (_b = options == null ? void 0 : options.inheritableHandlers) != null ? _b : this.inheritableHandlers;
    this.tags = (_c = options == null ? void 0 : options.tags) != null ? _c : this.tags;
    this.inheritableTags = (_d = options == null ? void 0 : options.inheritableTags) != null ? _d : this.inheritableTags;
    this.metadata = (_e = options == null ? void 0 : options.metadata) != null ? _e : this.metadata;
    this.inheritableMetadata = (_f = options == null ? void 0 : options.inheritableMetadata) != null ? _f : this.inheritableMetadata;
    this._parentRunId = parentRunId;
  }
  /**
   * Gets the parent run ID, if any.
   *
   * @returns The parent run ID.
   */
  getParentRunId() {
    return this._parentRunId;
  }
  async handleLLMStart(llm2, prompts, _runId = void 0, _parentRunId = void 0, extraParams = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
    return Promise.all(prompts.map(async (prompt) => {
      const runId = v4_default();
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a;
        if (!handler.ignoreLLM) {
          try {
            await ((_a = handler.handleLLMStart) == null ? void 0 : _a.call(handler, llm2, [prompt], runId, this._parentRunId, extraParams, this.tags, this.metadata, runName));
          } catch (err) {
            console.error(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);
          }
        }
      }, handler.awaitHandlers)));
      return new CallbackManagerForLLMRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }));
  }
  async handleChatModelStart(llm2, messages, _runId = void 0, _parentRunId = void 0, extraParams = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
    return Promise.all(messages.map(async (messageGroup) => {
      const runId = v4_default();
      await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
        var _a, _b;
        if (!handler.ignoreLLM) {
          try {
            if (handler.handleChatModelStart) {
              await ((_a = handler.handleChatModelStart) == null ? void 0 : _a.call(handler, llm2, [messageGroup], runId, this._parentRunId, extraParams, this.tags, this.metadata, runName));
            } else if (handler.handleLLMStart) {
              const messageString = getBufferString(messageGroup);
              await ((_b = handler.handleLLMStart) == null ? void 0 : _b.call(handler, llm2, [messageString], runId, this._parentRunId, extraParams, this.tags, this.metadata, runName));
            }
          } catch (err) {
            console.error(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);
          }
        }
      }, handler.awaitHandlers)));
      return new CallbackManagerForLLMRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
    }));
  }
  async handleChainStart(chain, inputs, runId = v4_default(), runType = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      if (!handler.ignoreChain) {
        try {
          await ((_a = handler.handleChainStart) == null ? void 0 : _a.call(handler, chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName));
        } catch (err) {
          console.error(`Error in handler ${handler.constructor.name}, handleChainStart: ${err}`);
        }
      }
    }, handler.awaitHandlers)));
    return new CallbackManagerForChainRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleToolStart(tool, input, runId = v4_default(), _parentRunId = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      if (!handler.ignoreAgent) {
        try {
          await ((_a = handler.handleToolStart) == null ? void 0 : _a.call(handler, tool, input, runId, this._parentRunId, this.tags, this.metadata, runName));
        } catch (err) {
          console.error(`Error in handler ${handler.constructor.name}, handleToolStart: ${err}`);
        }
      }
    }, handler.awaitHandlers)));
    return new CallbackManagerForToolRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  async handleRetrieverStart(retriever, query, runId = v4_default(), _parentRunId = void 0, _tags = void 0, _metadata = void 0, runName = void 0) {
    await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {
      var _a;
      if (!handler.ignoreRetriever) {
        try {
          await ((_a = handler.handleRetrieverStart) == null ? void 0 : _a.call(handler, retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName));
        } catch (err) {
          console.error(`Error in handler ${handler.constructor.name}, handleRetrieverStart: ${err}`);
        }
      }
    }, handler.awaitHandlers)));
    return new CallbackManagerForRetrieverRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);
  }
  addHandler(handler, inherit = true) {
    this.handlers.push(handler);
    if (inherit) {
      this.inheritableHandlers.push(handler);
    }
  }
  removeHandler(handler) {
    this.handlers = this.handlers.filter((_handler) => _handler !== handler);
    this.inheritableHandlers = this.inheritableHandlers.filter((_handler) => _handler !== handler);
  }
  setHandlers(handlers, inherit = true) {
    this.handlers = [];
    this.inheritableHandlers = [];
    for (const handler of handlers) {
      this.addHandler(handler, inherit);
    }
  }
  addTags(tags, inherit = true) {
    this.removeTags(tags);
    this.tags.push(...tags);
    if (inherit) {
      this.inheritableTags.push(...tags);
    }
  }
  removeTags(tags) {
    this.tags = this.tags.filter((tag) => !tags.includes(tag));
    this.inheritableTags = this.inheritableTags.filter((tag) => !tags.includes(tag));
  }
  addMetadata(metadata, inherit = true) {
    this.metadata = { ...this.metadata, ...metadata };
    if (inherit) {
      this.inheritableMetadata = { ...this.inheritableMetadata, ...metadata };
    }
  }
  removeMetadata(metadata) {
    for (const key of Object.keys(metadata)) {
      delete this.metadata[key];
      delete this.inheritableMetadata[key];
    }
  }
  copy(additionalHandlers = [], inherit = true) {
    const manager = new _CallbackManager(this._parentRunId);
    for (const handler of this.handlers) {
      const inheritable = this.inheritableHandlers.includes(handler);
      manager.addHandler(handler, inheritable);
    }
    for (const tag of this.tags) {
      const inheritable = this.inheritableTags.includes(tag);
      manager.addTags([tag], inheritable);
    }
    for (const key of Object.keys(this.metadata)) {
      const inheritable = Object.keys(this.inheritableMetadata).includes(key);
      manager.addMetadata({ [key]: this.metadata[key] }, inheritable);
    }
    for (const handler of additionalHandlers) {
      if (
        // Prevent multiple copies of console_callback_handler
        manager.handlers.filter((h) => h.name === "console_callback_handler").some((h) => h.name === handler.name)
      ) {
        continue;
      }
      manager.addHandler(handler, inherit);
    }
    return manager;
  }
  static fromHandlers(handlers) {
    class Handler extends BaseCallbackHandler {
      constructor() {
        super();
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: v4_default()
        });
        Object.assign(this, handlers);
      }
    }
    const manager = new this();
    manager.addHandler(new Handler());
    return manager;
  }
  static async configure(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {
    var _a, _b;
    let callbackManager;
    if (inheritableHandlers || localHandlers) {
      if (Array.isArray(inheritableHandlers) || !inheritableHandlers) {
        callbackManager = new _CallbackManager();
        callbackManager.setHandlers((_a = inheritableHandlers == null ? void 0 : inheritableHandlers.map(ensureHandler)) != null ? _a : [], true);
      } else {
        callbackManager = inheritableHandlers;
      }
      callbackManager = callbackManager.copy(Array.isArray(localHandlers) ? localHandlers.map(ensureHandler) : localHandlers == null ? void 0 : localHandlers.handlers, false);
    }
    const verboseEnabled = getEnvironmentVariable("LANGCHAIN_VERBOSE") === "true" || (options == null ? void 0 : options.verbose);
    const tracingV2Enabled = getEnvironmentVariable("LANGCHAIN_TRACING_V2") === "true";
    const tracingEnabled = tracingV2Enabled || ((_b = getEnvironmentVariable("LANGCHAIN_TRACING")) != null ? _b : false);
    if (verboseEnabled || tracingEnabled) {
      if (!callbackManager) {
        callbackManager = new _CallbackManager();
      }
      if (verboseEnabled && !callbackManager.handlers.some((handler) => handler.name === ConsoleCallbackHandler.prototype.name)) {
        const consoleHandler = new ConsoleCallbackHandler();
        callbackManager.addHandler(consoleHandler, true);
      }
      if (tracingEnabled && !callbackManager.handlers.some((handler) => handler.name === "langchain_tracer")) {
        if (tracingV2Enabled) {
          callbackManager.addHandler(await getTracingV2CallbackHandler(), true);
        }
      }
    }
    if (inheritableTags || localTags) {
      if (callbackManager) {
        callbackManager.addTags(inheritableTags != null ? inheritableTags : []);
        callbackManager.addTags(localTags != null ? localTags : [], false);
      }
    }
    if (inheritableMetadata || localMetadata) {
      if (callbackManager) {
        callbackManager.addMetadata(inheritableMetadata != null ? inheritableMetadata : {});
        callbackManager.addMetadata(localMetadata != null ? localMetadata : {}, false);
      }
    }
    return callbackManager;
  }
};
function ensureHandler(handler) {
  if ("name" in handler) {
    return handler;
  }
  return BaseCallbackHandler.fromMethods(handler);
}

// ../../node_modules/@langchain/core/dist/outputs.js
var RUN_KEY = "__run";
var GenerationChunk = class _GenerationChunk {
  constructor(fields) {
    Object.defineProperty(this, "text", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "generationInfo", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.text = fields.text;
    this.generationInfo = fields.generationInfo;
  }
  concat(chunk) {
    return new _GenerationChunk({
      text: this.text + chunk.text,
      generationInfo: {
        ...this.generationInfo,
        ...chunk.generationInfo
      }
    });
  }
};

// ../../node_modules/@langchain/core/dist/utils/js-sha1/hash.js
var root = typeof window === "object" ? window : {};
var HEX_CHARS = "0123456789abcdef".split("");
var EXTRA = [-2147483648, 8388608, 32768, 128];
var SHIFT = [24, 16, 8, 0];
var blocks = [];
function Sha1(sharedMemory) {
  if (sharedMemory) {
    blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
    this.blocks = blocks;
  } else {
    this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  }
  this.h0 = 1732584193;
  this.h1 = 4023233417;
  this.h2 = 2562383102;
  this.h3 = 271733878;
  this.h4 = 3285377520;
  this.block = this.start = this.bytes = this.hBytes = 0;
  this.finalized = this.hashed = false;
  this.first = true;
}
Sha1.prototype.update = function(message) {
  if (this.finalized) {
    return;
  }
  var notString = typeof message !== "string";
  if (notString && message.constructor === root.ArrayBuffer) {
    message = new Uint8Array(message);
  }
  var code, index = 0, i, length = message.length || 0, blocks2 = this.blocks;
  while (index < length) {
    if (this.hashed) {
      this.hashed = false;
      blocks2[0] = this.block;
      blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
    }
    if (notString) {
      for (i = this.start; index < length && i < 64; ++index) {
        blocks2[i >> 2] |= message[index] << SHIFT[i++ & 3];
      }
    } else {
      for (i = this.start; index < length && i < 64; ++index) {
        code = message.charCodeAt(index);
        if (code < 128) {
          blocks2[i >> 2] |= code << SHIFT[i++ & 3];
        } else if (code < 2048) {
          blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
          blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
        } else if (code < 55296 || code >= 57344) {
          blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
          blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
          blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
        } else {
          code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
          blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
          blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
          blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
          blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
        }
      }
    }
    this.lastByteIndex = i;
    this.bytes += i - this.start;
    if (i >= 64) {
      this.block = blocks2[16];
      this.start = i - 64;
      this.hash();
      this.hashed = true;
    } else {
      this.start = i;
    }
  }
  if (this.bytes > 4294967295) {
    this.hBytes += this.bytes / 4294967296 << 0;
    this.bytes = this.bytes % 4294967296;
  }
  return this;
};
Sha1.prototype.finalize = function() {
  if (this.finalized) {
    return;
  }
  this.finalized = true;
  var blocks2 = this.blocks, i = this.lastByteIndex;
  blocks2[16] = this.block;
  blocks2[i >> 2] |= EXTRA[i & 3];
  this.block = blocks2[16];
  if (i >= 56) {
    if (!this.hashed) {
      this.hash();
    }
    blocks2[0] = this.block;
    blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
  }
  blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
  blocks2[15] = this.bytes << 3;
  this.hash();
};
Sha1.prototype.hash = function() {
  var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4;
  var f, j, t, blocks2 = this.blocks;
  for (j = 16; j < 80; ++j) {
    t = blocks2[j - 3] ^ blocks2[j - 8] ^ blocks2[j - 14] ^ blocks2[j - 16];
    blocks2[j] = t << 1 | t >>> 31;
  }
  for (j = 0; j < 20; j += 5) {
    f = b & c | ~b & d;
    t = a << 5 | a >>> 27;
    e = t + f + e + 1518500249 + blocks2[j] << 0;
    b = b << 30 | b >>> 2;
    f = a & b | ~a & c;
    t = e << 5 | e >>> 27;
    d = t + f + d + 1518500249 + blocks2[j + 1] << 0;
    a = a << 30 | a >>> 2;
    f = e & a | ~e & b;
    t = d << 5 | d >>> 27;
    c = t + f + c + 1518500249 + blocks2[j + 2] << 0;
    e = e << 30 | e >>> 2;
    f = d & e | ~d & a;
    t = c << 5 | c >>> 27;
    b = t + f + b + 1518500249 + blocks2[j + 3] << 0;
    d = d << 30 | d >>> 2;
    f = c & d | ~c & e;
    t = b << 5 | b >>> 27;
    a = t + f + a + 1518500249 + blocks2[j + 4] << 0;
    c = c << 30 | c >>> 2;
  }
  for (; j < 40; j += 5) {
    f = b ^ c ^ d;
    t = a << 5 | a >>> 27;
    e = t + f + e + 1859775393 + blocks2[j] << 0;
    b = b << 30 | b >>> 2;
    f = a ^ b ^ c;
    t = e << 5 | e >>> 27;
    d = t + f + d + 1859775393 + blocks2[j + 1] << 0;
    a = a << 30 | a >>> 2;
    f = e ^ a ^ b;
    t = d << 5 | d >>> 27;
    c = t + f + c + 1859775393 + blocks2[j + 2] << 0;
    e = e << 30 | e >>> 2;
    f = d ^ e ^ a;
    t = c << 5 | c >>> 27;
    b = t + f + b + 1859775393 + blocks2[j + 3] << 0;
    d = d << 30 | d >>> 2;
    f = c ^ d ^ e;
    t = b << 5 | b >>> 27;
    a = t + f + a + 1859775393 + blocks2[j + 4] << 0;
    c = c << 30 | c >>> 2;
  }
  for (; j < 60; j += 5) {
    f = b & c | b & d | c & d;
    t = a << 5 | a >>> 27;
    e = t + f + e - 1894007588 + blocks2[j] << 0;
    b = b << 30 | b >>> 2;
    f = a & b | a & c | b & c;
    t = e << 5 | e >>> 27;
    d = t + f + d - 1894007588 + blocks2[j + 1] << 0;
    a = a << 30 | a >>> 2;
    f = e & a | e & b | a & b;
    t = d << 5 | d >>> 27;
    c = t + f + c - 1894007588 + blocks2[j + 2] << 0;
    e = e << 30 | e >>> 2;
    f = d & e | d & a | e & a;
    t = c << 5 | c >>> 27;
    b = t + f + b - 1894007588 + blocks2[j + 3] << 0;
    d = d << 30 | d >>> 2;
    f = c & d | c & e | d & e;
    t = b << 5 | b >>> 27;
    a = t + f + a - 1894007588 + blocks2[j + 4] << 0;
    c = c << 30 | c >>> 2;
  }
  for (; j < 80; j += 5) {
    f = b ^ c ^ d;
    t = a << 5 | a >>> 27;
    e = t + f + e - 899497514 + blocks2[j] << 0;
    b = b << 30 | b >>> 2;
    f = a ^ b ^ c;
    t = e << 5 | e >>> 27;
    d = t + f + d - 899497514 + blocks2[j + 1] << 0;
    a = a << 30 | a >>> 2;
    f = e ^ a ^ b;
    t = d << 5 | d >>> 27;
    c = t + f + c - 899497514 + blocks2[j + 2] << 0;
    e = e << 30 | e >>> 2;
    f = d ^ e ^ a;
    t = c << 5 | c >>> 27;
    b = t + f + b - 899497514 + blocks2[j + 3] << 0;
    d = d << 30 | d >>> 2;
    f = c ^ d ^ e;
    t = b << 5 | b >>> 27;
    a = t + f + a - 899497514 + blocks2[j + 4] << 0;
    c = c << 30 | c >>> 2;
  }
  this.h0 = this.h0 + a << 0;
  this.h1 = this.h1 + b << 0;
  this.h2 = this.h2 + c << 0;
  this.h3 = this.h3 + d << 0;
  this.h4 = this.h4 + e << 0;
};
Sha1.prototype.hex = function() {
  this.finalize();
  var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4;
  return HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15];
};
Sha1.prototype.toString = Sha1.prototype.hex;
Sha1.prototype.digest = function() {
  this.finalize();
  var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4;
  return [
    h0 >> 24 & 255,
    h0 >> 16 & 255,
    h0 >> 8 & 255,
    h0 & 255,
    h1 >> 24 & 255,
    h1 >> 16 & 255,
    h1 >> 8 & 255,
    h1 & 255,
    h2 >> 24 & 255,
    h2 >> 16 & 255,
    h2 >> 8 & 255,
    h2 & 255,
    h3 >> 24 & 255,
    h3 >> 16 & 255,
    h3 >> 8 & 255,
    h3 & 255,
    h4 >> 24 & 255,
    h4 >> 16 & 255,
    h4 >> 8 & 255,
    h4 & 255
  ];
};
Sha1.prototype.array = Sha1.prototype.digest;
Sha1.prototype.arrayBuffer = function() {
  this.finalize();
  var buffer = new ArrayBuffer(20);
  var dataView = new DataView(buffer);
  dataView.setUint32(0, this.h0);
  dataView.setUint32(4, this.h1);
  dataView.setUint32(8, this.h2);
  dataView.setUint32(12, this.h3);
  dataView.setUint32(16, this.h4);
  return buffer;
};
var insecureHash = (message) => {
  return new Sha1(true).update(message)["hex"]();
};

// ../../node_modules/@langchain/core/dist/caches.js
var getCacheKey = (...strings) => insecureHash(strings.join("_"));
var BaseCache = class {
};
var GLOBAL_MAP = /* @__PURE__ */ new Map();
var InMemoryCache = class _InMemoryCache extends BaseCache {
  constructor(map) {
    super();
    Object.defineProperty(this, "cache", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.cache = map != null ? map : /* @__PURE__ */ new Map();
  }
  /**
   * Retrieves data from the cache using a prompt and an LLM key. If the
   * data is not found, it returns null.
   * @param prompt The prompt used to find the data.
   * @param llmKey The LLM key used to find the data.
   * @returns The data corresponding to the prompt and LLM key, or null if not found.
   */
  lookup(prompt, llmKey) {
    var _a;
    return Promise.resolve((_a = this.cache.get(getCacheKey(prompt, llmKey))) != null ? _a : null);
  }
  /**
   * Updates the cache with new data using a prompt and an LLM key.
   * @param prompt The prompt used to store the data.
   * @param llmKey The LLM key used to store the data.
   * @param value The data to be stored.
   */
  async update(prompt, llmKey, value) {
    this.cache.set(getCacheKey(prompt, llmKey), value);
  }
  /**
   * Returns a global instance of InMemoryCache using a predefined global
   * map as the initial cache.
   * @returns A global instance of InMemoryCache.
   */
  static global() {
    return new _InMemoryCache(GLOBAL_MAP);
  }
};

// ../../node_modules/@langchain/core/dist/prompt_values.js
var BasePromptValue = class extends Serializable {
};
var StringPromptValue = class extends BasePromptValue {
  static lc_name() {
    return "StringPromptValue";
  }
  constructor(value) {
    super({ value });
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "prompt_values"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "value", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.value = value;
  }
  toString() {
    return this.value;
  }
  toChatMessages() {
    return [new HumanMessage(this.value)];
  }
};
var ChatPromptValue = class extends BasePromptValue {
  static lc_name() {
    return "ChatPromptValue";
  }
  constructor(fields) {
    if (Array.isArray(fields)) {
      fields = { messages: fields };
    }
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "prompt_values"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "messages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.messages = fields.messages;
  }
  toString() {
    return getBufferString(this.messages);
  }
  toChatMessages() {
    return this.messages;
  }
};

// ../../node_modules/@langchain/core/dist/utils/async_caller.js
var import_p_retry2 = __toESM(require_p_retry(), 1);
var import_p_queue3 = __toESM(require_dist(), 1);
var STATUS_NO_RETRY2 = [
  400,
  401,
  402,
  403,
  404,
  405,
  406,
  407,
  408,
  409
  // Conflict
];
var defaultFailedAttemptHandler = (error) => {
  var _a, _b, _c;
  if (error.message.startsWith("Cancel") || error.message.startsWith("TimeoutError") || error.name === "TimeoutError" || error.message.startsWith("AbortError") || error.name === "AbortError") {
    throw error;
  }
  if ((error == null ? void 0 : error.code) === "ECONNABORTED") {
    throw error;
  }
  const status = (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (_b = (_a = error == null ? void 0 : error.response) == null ? void 0 : _a.status) != null ? _b : error == null ? void 0 : error.status
  );
  if (status && STATUS_NO_RETRY2.includes(+status)) {
    throw error;
  }
  if (((_c = error == null ? void 0 : error.error) == null ? void 0 : _c.code) === "insufficient_quota") {
    const err = new Error(error == null ? void 0 : error.message);
    err.name = "InsufficientQuotaError";
    throw err;
  }
};
var AsyncCaller2 = class {
  constructor(params) {
    var _a, _b, _c;
    Object.defineProperty(this, "maxConcurrency", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "maxRetries", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "onFailedAttempt", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "queue", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxConcurrency = (_a = params.maxConcurrency) != null ? _a : Infinity;
    this.maxRetries = (_b = params.maxRetries) != null ? _b : 6;
    this.onFailedAttempt = (_c = params.onFailedAttempt) != null ? _c : defaultFailedAttemptHandler;
    const PQueue = "default" in import_p_queue3.default ? import_p_queue3.default.default : import_p_queue3.default;
    this.queue = new PQueue({ concurrency: this.maxConcurrency });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  call(callable, ...args) {
    return this.queue.add(() => (0, import_p_retry2.default)(() => callable(...args).catch((error) => {
      if (error instanceof Error) {
        throw error;
      } else {
        throw new Error(error);
      }
    }), {
      onFailedAttempt: this.onFailedAttempt,
      retries: this.maxRetries,
      randomize: true
      // If needed we can change some of the defaults here,
      // but they're quite sensible.
    }), { throwOnTimeout: true });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  callWithOptions(options, callable, ...args) {
    if (options.signal) {
      return Promise.race([
        this.call(callable, ...args),
        new Promise((_, reject) => {
          var _a;
          (_a = options.signal) == null ? void 0 : _a.addEventListener("abort", () => {
            reject(new Error("AbortError"));
          });
        })
      ]);
    }
    return this.call(callable, ...args);
  }
  fetch(...args) {
    return this.call(() => fetch(...args).then((res) => res.ok ? res : Promise.reject(res)));
  }
};

// ../../node_modules/js-tiktoken/dist/chunk-HXW345QN.js
var import_base64_js = __toESM(require_base64_js(), 1);
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => {
  __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function bytePairMerge(piece, ranks) {
  let parts = Array.from(
    { length: piece.length },
    (_, i) => ({ start: i, end: i + 1 })
  );
  while (parts.length > 1) {
    let minRank = null;
    for (let i = 0; i < parts.length - 1; i++) {
      const slice = piece.slice(parts[i].start, parts[i + 1].end);
      const rank = ranks.get(slice.join(","));
      if (rank == null)
        continue;
      if (minRank == null || rank < minRank[0]) {
        minRank = [rank, i];
      }
    }
    if (minRank != null) {
      const i = minRank[1];
      parts[i] = { start: parts[i].start, end: parts[i + 1].end };
      parts.splice(i + 1, 1);
    } else {
      break;
    }
  }
  return parts;
}
function bytePairEncode(piece, ranks) {
  if (piece.length === 1)
    return [ranks.get(piece.join(","))];
  return bytePairMerge(piece, ranks).map((p) => ranks.get(piece.slice(p.start, p.end).join(","))).filter((x) => x != null);
}
function escapeRegex(str) {
  return str.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
}
var _Tiktoken = class {
  constructor(ranks, extendedSpecialTokens) {
    /** @internal */
    __publicField(this, "specialTokens");
    /** @internal */
    __publicField(this, "inverseSpecialTokens");
    /** @internal */
    __publicField(this, "patStr");
    /** @internal */
    __publicField(this, "textEncoder", new TextEncoder());
    /** @internal */
    __publicField(this, "textDecoder", new TextDecoder("utf-8"));
    /** @internal */
    __publicField(this, "rankMap", /* @__PURE__ */ new Map());
    /** @internal */
    __publicField(this, "textMap", /* @__PURE__ */ new Map());
    this.patStr = ranks.pat_str;
    const uncompressed = ranks.bpe_ranks.split("\n").filter(Boolean).reduce((memo, x) => {
      const [_, offsetStr, ...tokens] = x.split(" ");
      const offset = Number.parseInt(offsetStr, 10);
      tokens.forEach((token, i) => memo[token] = offset + i);
      return memo;
    }, {});
    for (const [token, rank] of Object.entries(uncompressed)) {
      const bytes = import_base64_js.default.toByteArray(token);
      this.rankMap.set(bytes.join(","), rank);
      this.textMap.set(rank, bytes);
    }
    this.specialTokens = { ...ranks.special_tokens, ...extendedSpecialTokens };
    this.inverseSpecialTokens = Object.entries(this.specialTokens).reduce((memo, [text2, rank]) => {
      memo[rank] = this.textEncoder.encode(text2);
      return memo;
    }, {});
  }
  encode(text2, allowedSpecial = [], disallowedSpecial = "all") {
    var _a;
    const regexes = new RegExp(this.patStr, "ug");
    const specialRegex = _Tiktoken.specialTokenRegex(
      Object.keys(this.specialTokens)
    );
    const ret = [];
    const allowedSpecialSet = new Set(
      allowedSpecial === "all" ? Object.keys(this.specialTokens) : allowedSpecial
    );
    const disallowedSpecialSet = new Set(
      disallowedSpecial === "all" ? Object.keys(this.specialTokens).filter(
        (x) => !allowedSpecialSet.has(x)
      ) : disallowedSpecial
    );
    if (disallowedSpecialSet.size > 0) {
      const disallowedSpecialRegex = _Tiktoken.specialTokenRegex([
        ...disallowedSpecialSet
      ]);
      const specialMatch = text2.match(disallowedSpecialRegex);
      if (specialMatch != null) {
        throw new Error(
          `The text contains a special token that is not allowed: ${specialMatch[0]}`
        );
      }
    }
    let start = 0;
    while (true) {
      let nextSpecial = null;
      let startFind = start;
      while (true) {
        specialRegex.lastIndex = startFind;
        nextSpecial = specialRegex.exec(text2);
        if (nextSpecial == null || allowedSpecialSet.has(nextSpecial[0]))
          break;
        startFind = nextSpecial.index + 1;
      }
      const end = (_a = nextSpecial == null ? void 0 : nextSpecial.index) != null ? _a : text2.length;
      for (const match of text2.substring(start, end).matchAll(regexes)) {
        const piece = this.textEncoder.encode(match[0]);
        const token2 = this.rankMap.get(piece.join(","));
        if (token2 != null) {
          ret.push(token2);
          continue;
        }
        ret.push(...bytePairEncode(piece, this.rankMap));
      }
      if (nextSpecial == null)
        break;
      let token = this.specialTokens[nextSpecial[0]];
      ret.push(token);
      start = nextSpecial.index + nextSpecial[0].length;
    }
    return ret;
  }
  decode(tokens) {
    var _a;
    const res = [];
    let length = 0;
    for (let i2 = 0; i2 < tokens.length; ++i2) {
      const token = tokens[i2];
      const bytes = (_a = this.textMap.get(token)) != null ? _a : this.inverseSpecialTokens[token];
      if (bytes != null) {
        res.push(bytes);
        length += bytes.length;
      }
    }
    const mergedArray = new Uint8Array(length);
    let i = 0;
    for (const bytes of res) {
      mergedArray.set(bytes, i);
      i += bytes.length;
    }
    return this.textDecoder.decode(mergedArray);
  }
};
var Tiktoken = _Tiktoken;
__publicField2(Tiktoken, "specialTokenRegex", (tokens) => {
  return new RegExp(tokens.map((i) => escapeRegex(i)).join("|"), "g");
});
function getEncodingNameForModel(model) {
  switch (model) {
    case "gpt2": {
      return "gpt2";
    }
    case "code-cushman-001":
    case "code-cushman-002":
    case "code-davinci-001":
    case "code-davinci-002":
    case "cushman-codex":
    case "davinci-codex":
    case "davinci-002":
    case "text-davinci-002":
    case "text-davinci-003": {
      return "p50k_base";
    }
    case "code-davinci-edit-001":
    case "text-davinci-edit-001": {
      return "p50k_edit";
    }
    case "ada":
    case "babbage":
    case "babbage-002":
    case "code-search-ada-code-001":
    case "code-search-babbage-code-001":
    case "curie":
    case "davinci":
    case "text-ada-001":
    case "text-babbage-001":
    case "text-curie-001":
    case "text-davinci-001":
    case "text-search-ada-doc-001":
    case "text-search-babbage-doc-001":
    case "text-search-curie-doc-001":
    case "text-search-davinci-doc-001":
    case "text-similarity-ada-001":
    case "text-similarity-babbage-001":
    case "text-similarity-curie-001":
    case "text-similarity-davinci-001": {
      return "r50k_base";
    }
    case "gpt-3.5-turbo-instruct-0914":
    case "gpt-3.5-turbo-instruct":
    case "gpt-3.5-turbo-16k-0613":
    case "gpt-3.5-turbo-16k":
    case "gpt-3.5-turbo-0613":
    case "gpt-3.5-turbo-0301":
    case "gpt-3.5-turbo":
    case "gpt-4-32k-0613":
    case "gpt-4-32k-0314":
    case "gpt-4-32k":
    case "gpt-4-0613":
    case "gpt-4-0314":
    case "gpt-4":
    case "gpt-3.5-turbo-1106":
    case "gpt-35-turbo":
    case "gpt-4-1106-preview":
    case "gpt-4-vision-preview":
    case "gpt-3.5-turbo-0125":
    case "gpt-4-turbo-preview":
    case "gpt-4-0125-preview":
    case "text-embedding-ada-002": {
      return "cl100k_base";
    }
    default:
      throw new Error("Unknown model");
  }
}

// ../../node_modules/@langchain/core/dist/utils/tiktoken.js
var cache = {};
var caller = /* @__PURE__ */ new AsyncCaller2({});
async function getEncoding(encoding) {
  if (!(encoding in cache)) {
    cache[encoding] = caller.fetch(`https://tiktoken.pages.dev/js/${encoding}.json`).then((res) => res.json()).then((data) => new Tiktoken(data)).catch((e) => {
      delete cache[encoding];
      throw e;
    });
  }
  return await cache[encoding];
}
async function encodingForModel(model) {
  return getEncoding(getEncodingNameForModel(model));
}

// ../../node_modules/@langchain/core/dist/runnables/base.js
var import_p_retry3 = __toESM(require_p_retry(), 1);

// ../../node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.js
var core_exports = {};
__export(core_exports, {
  JsonPatchError: () => JsonPatchError,
  _areEquals: () => _areEquals,
  applyOperation: () => applyOperation,
  applyPatch: () => applyPatch,
  applyReducer: () => applyReducer,
  deepClone: () => deepClone,
  getValueByPointer: () => getValueByPointer,
  validate: () => validate2,
  validator: () => validator
});

// ../../node_modules/@langchain/core/dist/utils/fast-json-patch/src/helpers.js
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key) {
  return _hasOwnProperty.call(obj, key);
}
function _objectKeys(obj) {
  if (Array.isArray(obj)) {
    const keys2 = new Array(obj.length);
    for (let k = 0; k < keys2.length; k++) {
      keys2[k] = "" + k;
    }
    return keys2;
  }
  if (Object.keys) {
    return Object.keys(obj);
  }
  let keys = [];
  for (let i in obj) {
    if (hasOwnProperty(obj, i)) {
      keys.push(i);
    }
  }
  return keys;
}
function _deepClone(obj) {
  switch (typeof obj) {
    case "object":
      return JSON.parse(JSON.stringify(obj));
    case "undefined":
      return null;
    default:
      return obj;
  }
}
function isInteger(str) {
  let i = 0;
  const len = str.length;
  let charCode;
  while (i < len) {
    charCode = str.charCodeAt(i);
    if (charCode >= 48 && charCode <= 57) {
      i++;
      continue;
    }
    return false;
  }
  return true;
}
function escapePathComponent(path) {
  if (path.indexOf("/") === -1 && path.indexOf("~") === -1)
    return path;
  return path.replace(/~/g, "~0").replace(/\//g, "~1");
}
function unescapePathComponent(path) {
  return path.replace(/~1/g, "/").replace(/~0/g, "~");
}
function hasUndefined(obj) {
  if (obj === void 0) {
    return true;
  }
  if (obj) {
    if (Array.isArray(obj)) {
      for (let i2 = 0, len = obj.length; i2 < len; i2++) {
        if (hasUndefined(obj[i2])) {
          return true;
        }
      }
    } else if (typeof obj === "object") {
      const objKeys = _objectKeys(obj);
      const objKeysLength = objKeys.length;
      for (var i = 0; i < objKeysLength; i++) {
        if (hasUndefined(obj[objKeys[i]])) {
          return true;
        }
      }
    }
  }
  return false;
}
function patchErrorMessageFormatter(message, args) {
  const messageParts = [message];
  for (const key in args) {
    const value = typeof args[key] === "object" ? JSON.stringify(args[key], null, 2) : args[key];
    if (typeof value !== "undefined") {
      messageParts.push(`${key}: ${value}`);
    }
  }
  return messageParts.join("\n");
}
var PatchError = class extends Error {
  constructor(message, name, index, operation, tree) {
    super(patchErrorMessageFormatter(message, { name, index, operation, tree }));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: name
    });
    Object.defineProperty(this, "index", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: index
    });
    Object.defineProperty(this, "operation", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: operation
    });
    Object.defineProperty(this, "tree", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: tree
    });
    Object.setPrototypeOf(this, new.target.prototype);
    this.message = patchErrorMessageFormatter(message, {
      name,
      index,
      operation,
      tree
    });
  }
};

// ../../node_modules/@langchain/core/dist/utils/fast-json-patch/src/core.js
var JsonPatchError = PatchError;
var deepClone = _deepClone;
var objOps = {
  add: function(obj, key, document2) {
    obj[key] = this.value;
    return { newDocument: document2 };
  },
  remove: function(obj, key, document2) {
    var removed = obj[key];
    delete obj[key];
    return { newDocument: document2, removed };
  },
  replace: function(obj, key, document2) {
    var removed = obj[key];
    obj[key] = this.value;
    return { newDocument: document2, removed };
  },
  move: function(obj, key, document2) {
    let removed = getValueByPointer(document2, this.path);
    if (removed) {
      removed = _deepClone(removed);
    }
    const originalValue = applyOperation(document2, {
      op: "remove",
      path: this.from
    }).removed;
    applyOperation(document2, {
      op: "add",
      path: this.path,
      value: originalValue
    });
    return { newDocument: document2, removed };
  },
  copy: function(obj, key, document2) {
    const valueToCopy = getValueByPointer(document2, this.from);
    applyOperation(document2, {
      op: "add",
      path: this.path,
      value: _deepClone(valueToCopy)
    });
    return { newDocument: document2 };
  },
  test: function(obj, key, document2) {
    return { newDocument: document2, test: _areEquals(obj[key], this.value) };
  },
  _get: function(obj, key, document2) {
    this.value = obj[key];
    return { newDocument: document2 };
  }
};
var arrOps = {
  add: function(arr, i, document2) {
    if (isInteger(i)) {
      arr.splice(i, 0, this.value);
    } else {
      arr[i] = this.value;
    }
    return { newDocument: document2, index: i };
  },
  remove: function(arr, i, document2) {
    var removedList = arr.splice(i, 1);
    return { newDocument: document2, removed: removedList[0] };
  },
  replace: function(arr, i, document2) {
    var removed = arr[i];
    arr[i] = this.value;
    return { newDocument: document2, removed };
  },
  move: objOps.move,
  copy: objOps.copy,
  test: objOps.test,
  _get: objOps._get
};
function getValueByPointer(document2, pointer) {
  if (pointer == "") {
    return document2;
  }
  var getOriginalDestination = { op: "_get", path: pointer };
  applyOperation(document2, getOriginalDestination);
  return getOriginalDestination.value;
}
function applyOperation(document2, operation, validateOperation = false, mutateDocument = true, banPrototypeModifications = true, index = 0) {
  if (validateOperation) {
    if (typeof validateOperation == "function") {
      validateOperation(operation, 0, document2, operation.path);
    } else {
      validator(operation, 0);
    }
  }
  if (operation.path === "") {
    let returnValue = { newDocument: document2 };
    if (operation.op === "add") {
      returnValue.newDocument = operation.value;
      return returnValue;
    } else if (operation.op === "replace") {
      returnValue.newDocument = operation.value;
      returnValue.removed = document2;
      return returnValue;
    } else if (operation.op === "move" || operation.op === "copy") {
      returnValue.newDocument = getValueByPointer(document2, operation.from);
      if (operation.op === "move") {
        returnValue.removed = document2;
      }
      return returnValue;
    } else if (operation.op === "test") {
      returnValue.test = _areEquals(document2, operation.value);
      if (returnValue.test === false) {
        throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
      }
      returnValue.newDocument = document2;
      return returnValue;
    } else if (operation.op === "remove") {
      returnValue.removed = document2;
      returnValue.newDocument = null;
      return returnValue;
    } else if (operation.op === "_get") {
      operation.value = document2;
      return returnValue;
    } else {
      if (validateOperation) {
        throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document2);
      } else {
        return returnValue;
      }
    }
  } else {
    if (!mutateDocument) {
      document2 = _deepClone(document2);
    }
    const path = operation.path || "";
    const keys = path.split("/");
    let obj = document2;
    let t = 1;
    let len = keys.length;
    let existingPathFragment = void 0;
    let key;
    let validateFunction;
    if (typeof validateOperation == "function") {
      validateFunction = validateOperation;
    } else {
      validateFunction = validator;
    }
    while (true) {
      key = keys[t];
      if (key && key.indexOf("~") != -1) {
        key = unescapePathComponent(key);
      }
      if (banPrototypeModifications && (key == "__proto__" || key == "prototype" && t > 0 && keys[t - 1] == "constructor")) {
        throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      }
      if (validateOperation) {
        if (existingPathFragment === void 0) {
          if (obj[key] === void 0) {
            existingPathFragment = keys.slice(0, t).join("/");
          } else if (t == len - 1) {
            existingPathFragment = operation.path;
          }
          if (existingPathFragment !== void 0) {
            validateFunction(operation, 0, document2, existingPathFragment);
          }
        }
      }
      t++;
      if (Array.isArray(obj)) {
        if (key === "-") {
          key = obj.length;
        } else {
          if (validateOperation && !isInteger(key)) {
            throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index, operation, document2);
          } else if (isInteger(key)) {
            key = ~~key;
          }
        }
        if (t >= len) {
          if (validateOperation && operation.op === "add" && key > obj.length) {
            throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index, operation, document2);
          }
          const returnValue = arrOps[operation.op].call(operation, obj, key, document2);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
          }
          return returnValue;
        }
      } else {
        if (t >= len) {
          const returnValue = objOps[operation.op].call(operation, obj, key, document2);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
          }
          return returnValue;
        }
      }
      obj = obj[key];
      if (validateOperation && t < len && (!obj || typeof obj !== "object")) {
        throw new JsonPatchError("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", index, operation, document2);
      }
    }
  }
}
function applyPatch(document2, patch, validateOperation, mutateDocument = true, banPrototypeModifications = true) {
  if (validateOperation) {
    if (!Array.isArray(patch)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
  }
  if (!mutateDocument) {
    document2 = _deepClone(document2);
  }
  const results = new Array(patch.length);
  for (let i = 0, length = patch.length; i < length; i++) {
    results[i] = applyOperation(document2, patch[i], validateOperation, true, banPrototypeModifications, i);
    document2 = results[i].newDocument;
  }
  results.newDocument = document2;
  return results;
}
function applyReducer(document2, operation, index) {
  const operationResult = applyOperation(document2, operation);
  if (operationResult.test === false) {
    throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
  }
  return operationResult.newDocument;
}
function validator(operation, index, document2, existingPathFragment) {
  if (typeof operation !== "object" || operation === null || Array.isArray(operation)) {
    throw new JsonPatchError("Operation is not an object", "OPERATION_NOT_AN_OBJECT", index, operation, document2);
  } else if (!objOps[operation.op]) {
    throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document2);
  } else if (typeof operation.path !== "string") {
    throw new JsonPatchError("Operation `path` property is not a string", "OPERATION_PATH_INVALID", index, operation, document2);
  } else if (operation.path.indexOf("/") !== 0 && operation.path.length > 0) {
    throw new JsonPatchError('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", index, operation, document2);
  } else if ((operation.op === "move" || operation.op === "copy") && typeof operation.from !== "string") {
    throw new JsonPatchError("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", index, operation, document2);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && operation.value === void 0) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", index, operation, document2);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && hasUndefined(operation.value)) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", index, operation, document2);
  } else if (document2) {
    if (operation.op == "add") {
      var pathLen = operation.path.split("/").length;
      var existingPathLen = existingPathFragment.split("/").length;
      if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
        throw new JsonPatchError("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", index, operation, document2);
      }
    } else if (operation.op === "replace" || operation.op === "remove" || operation.op === "_get") {
      if (operation.path !== existingPathFragment) {
        throw new JsonPatchError("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", index, operation, document2);
      }
    } else if (operation.op === "move" || operation.op === "copy") {
      var existingValue = {
        op: "_get",
        path: operation.from,
        value: void 0
      };
      var error = validate2([existingValue], document2);
      if (error && error.name === "OPERATION_PATH_UNRESOLVABLE") {
        throw new JsonPatchError("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", index, operation, document2);
      }
    }
  }
}
function validate2(sequence, document2, externalValidator) {
  try {
    if (!Array.isArray(sequence)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
    if (document2) {
      applyPatch(_deepClone(document2), _deepClone(sequence), externalValidator || true);
    } else {
      externalValidator = externalValidator || validator;
      for (var i = 0; i < sequence.length; i++) {
        externalValidator(sequence[i], i, document2, void 0);
      }
    }
  } catch (e) {
    if (e instanceof JsonPatchError) {
      return e;
    } else {
      throw e;
    }
  }
}
function _areEquals(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length, key;
    if (arrA && arrB) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; )
        if (!_areEquals(a[i], b[i]))
          return false;
      return true;
    }
    if (arrA != arrB)
      return false;
    var keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i = length; i-- !== 0; )
      if (!b.hasOwnProperty(keys[i]))
        return false;
    for (i = length; i-- !== 0; ) {
      key = keys[i];
      if (!_areEquals(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
}

// ../../node_modules/@langchain/core/dist/utils/fast-json-patch/index.js
var fast_json_patch_default = {
  ...core_exports,
  // ...duplex,
  JsonPatchError: PatchError,
  deepClone: _deepClone,
  escapePathComponent,
  unescapePathComponent
};

// ../../node_modules/@langchain/core/dist/utils/stream.js
var IterableReadableStream = class _IterableReadableStream extends ReadableStream {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "reader", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  ensureReader() {
    if (!this.reader) {
      this.reader = this.getReader();
    }
  }
  async next() {
    this.ensureReader();
    try {
      const result = await this.reader.read();
      if (result.done) {
        this.reader.releaseLock();
        return {
          done: true,
          value: void 0
        };
      } else {
        return {
          done: false,
          value: result.value
        };
      }
    } catch (e) {
      this.reader.releaseLock();
      throw e;
    }
  }
  async return() {
    this.ensureReader();
    if (this.locked) {
      const cancelPromise = this.reader.cancel();
      this.reader.releaseLock();
      await cancelPromise;
    }
    return { done: true, value: void 0 };
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async throw(e) {
    this.ensureReader();
    if (this.locked) {
      const cancelPromise = this.reader.cancel();
      this.reader.releaseLock();
      await cancelPromise;
    }
    throw e;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  static fromReadableStream(stream) {
    const reader = stream.getReader();
    return new _IterableReadableStream({
      start(controller) {
        return pump();
        function pump() {
          return reader.read().then(({ done, value }) => {
            if (done) {
              controller.close();
              return;
            }
            controller.enqueue(value);
            return pump();
          });
        }
      },
      cancel() {
        reader.releaseLock();
      }
    });
  }
  static fromAsyncGenerator(generator) {
    return new _IterableReadableStream({
      async pull(controller) {
        const { value, done } = await generator.next();
        if (done) {
          controller.close();
        }
        controller.enqueue(value);
      },
      async cancel(reason) {
        await generator.return(reason);
      }
    });
  }
};
function atee(iter, length = 2) {
  const buffers = Array.from({ length }, () => []);
  return buffers.map(async function* makeIter(buffer) {
    while (true) {
      if (buffer.length === 0) {
        const result = await iter.next();
        for (const buffer2 of buffers) {
          buffer2.push(result);
        }
      } else if (buffer[0].done) {
        return;
      } else {
        yield buffer.shift().value;
      }
    }
  });
}
function concat(first, second) {
  if (Array.isArray(first) && Array.isArray(second)) {
    return first.concat(second);
  } else if (typeof first === "string" && typeof second === "string") {
    return first + second;
  } else if (typeof first === "number" && typeof second === "number") {
    return first + second;
  } else if (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    "concat" in first && // eslint-disable-next-line @typescript-eslint/no-explicit-any
    typeof first.concat === "function"
  ) {
    return first.concat(second);
  } else if (typeof first === "object" && typeof second === "object") {
    const chunk = { ...first };
    for (const [key, value] of Object.entries(second)) {
      if (key in chunk && !Array.isArray(chunk[key])) {
        chunk[key] = concat(chunk[key], value);
      } else {
        chunk[key] = value;
      }
    }
    return chunk;
  } else {
    throw new Error(`Cannot concat ${typeof first} and ${typeof second}`);
  }
}
var AsyncGeneratorWithSetup = class {
  constructor(generator, startSetup) {
    Object.defineProperty(this, "generator", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "setup", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "firstResult", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "firstResultUsed", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    this.generator = generator;
    this.setup = new Promise((resolve, reject) => {
      this.firstResult = generator.next();
      if (startSetup) {
        this.firstResult.then(startSetup).then(resolve, reject);
      } else {
        this.firstResult.then((_result) => resolve(void 0), reject);
      }
    });
  }
  async next(...args) {
    if (!this.firstResultUsed) {
      this.firstResultUsed = true;
      return this.firstResult;
    }
    return this.generator.next(...args);
  }
  async return(value) {
    return this.generator.return(value);
  }
  async throw(e) {
    return this.generator.throw(e);
  }
  [Symbol.asyncIterator]() {
    return this;
  }
};
async function pipeGeneratorWithSetup(to, generator, startSetup, ...args) {
  const gen = new AsyncGeneratorWithSetup(generator, startSetup);
  const setup = await gen.setup;
  return { output: to(gen, setup, ...args), setup };
}

// ../../node_modules/@langchain/core/dist/tracers/log_stream.js
var RunLogPatch = class {
  constructor(fields) {
    var _a;
    Object.defineProperty(this, "ops", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.ops = (_a = fields.ops) != null ? _a : [];
  }
  concat(other) {
    const ops = this.ops.concat(other.ops);
    const states = applyPatch({}, ops);
    return new RunLog({
      ops,
      state: states[states.length - 1].newDocument
    });
  }
};
var RunLog = class _RunLog extends RunLogPatch {
  constructor(fields) {
    super(fields);
    Object.defineProperty(this, "state", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.state = fields.state;
  }
  concat(other) {
    const ops = this.ops.concat(other.ops);
    const states = applyPatch(this.state, other.ops);
    return new _RunLog({ ops, state: states[states.length - 1].newDocument });
  }
  static fromRunLogPatch(patch) {
    const states = applyPatch({}, patch.ops);
    return new _RunLog({
      ops: patch.ops,
      state: states[states.length - 1].newDocument
    });
  }
};
async function _getStandardizedInputs(run2, schemaFormat) {
  if (schemaFormat === "original") {
    throw new Error("Do not assign inputs with original schema drop the key for now. When inputs are added to streamLog they should be added with standardized schema for streaming events.");
  }
  const { inputs } = run2;
  if (["retriever", "llm", "prompt"].includes(run2.run_type)) {
    return inputs;
  }
  if (Object.keys(inputs).length === 1 && (inputs == null ? void 0 : inputs.input) === "") {
    return void 0;
  }
  return inputs.input;
}
async function _getStandardizedOutputs(run2, schemaFormat) {
  const { outputs } = run2;
  if (schemaFormat === "original") {
    return outputs;
  }
  if (["retriever", "llm", "prompt"].includes(run2.run_type)) {
    return outputs;
  }
  if (outputs !== void 0 && Object.keys(outputs).length === 1 && (outputs == null ? void 0 : outputs.output) !== void 0) {
    return outputs.output;
  }
  return outputs;
}
function isChatGenerationChunk(x) {
  return x !== void 0 && x.message !== void 0;
}
var LogStreamCallbackHandler = class extends BaseTracer {
  constructor(fields) {
    var _a, _b;
    super(fields);
    Object.defineProperty(this, "autoClose", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "includeNames", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "includeTypes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "includeTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "excludeNames", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "excludeTypes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "excludeTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_schemaFormat", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "original"
    });
    Object.defineProperty(this, "rootId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "keyMapByRunId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "counterMapByRunName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "transformStream", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "writer", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "receiveStream", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "log_stream_tracer"
    });
    this.autoClose = (_a = fields == null ? void 0 : fields.autoClose) != null ? _a : true;
    this.includeNames = fields == null ? void 0 : fields.includeNames;
    this.includeTypes = fields == null ? void 0 : fields.includeTypes;
    this.includeTags = fields == null ? void 0 : fields.includeTags;
    this.excludeNames = fields == null ? void 0 : fields.excludeNames;
    this.excludeTypes = fields == null ? void 0 : fields.excludeTypes;
    this.excludeTags = fields == null ? void 0 : fields.excludeTags;
    this._schemaFormat = (_b = fields == null ? void 0 : fields._schemaFormat) != null ? _b : this._schemaFormat;
    this.transformStream = new TransformStream();
    this.writer = this.transformStream.writable.getWriter();
    this.receiveStream = IterableReadableStream.fromReadableStream(this.transformStream.readable);
  }
  [Symbol.asyncIterator]() {
    return this.receiveStream;
  }
  async persistRun(_run) {
  }
  _includeRun(run2) {
    var _a;
    if (run2.id === this.rootId) {
      return false;
    }
    const runTags = (_a = run2.tags) != null ? _a : [];
    let include = this.includeNames === void 0 && this.includeTags === void 0 && this.includeTypes === void 0;
    if (this.includeNames !== void 0) {
      include = include || this.includeNames.includes(run2.name);
    }
    if (this.includeTypes !== void 0) {
      include = include || this.includeTypes.includes(run2.run_type);
    }
    if (this.includeTags !== void 0) {
      include = include || runTags.find((tag) => {
        var _a2;
        return (_a2 = this.includeTags) == null ? void 0 : _a2.includes(tag);
      }) !== void 0;
    }
    if (this.excludeNames !== void 0) {
      include = include && !this.excludeNames.includes(run2.name);
    }
    if (this.excludeTypes !== void 0) {
      include = include && !this.excludeTypes.includes(run2.run_type);
    }
    if (this.excludeTags !== void 0) {
      include = include && runTags.every((tag) => {
        var _a2;
        return !((_a2 = this.excludeTags) == null ? void 0 : _a2.includes(tag));
      });
    }
    return include;
  }
  async *tapOutputIterable(runId, output) {
    for await (const chunk of output) {
      if (runId !== this.rootId) {
        const key = this.keyMapByRunId[runId];
        if (key) {
          await this.writer.write(new RunLogPatch({
            ops: [
              {
                op: "add",
                path: `/logs/${key}/streamed_output/-`,
                value: chunk
              }
            ]
          }));
        }
      }
      yield chunk;
    }
  }
  async onRunCreate(run2) {
    var _a, _b, _c;
    if (this.rootId === void 0) {
      this.rootId = run2.id;
      await this.writer.write(new RunLogPatch({
        ops: [
          {
            op: "replace",
            path: "",
            value: {
              id: run2.id,
              name: run2.name,
              type: run2.run_type,
              streamed_output: [],
              final_output: void 0,
              logs: {}
            }
          }
        ]
      }));
    }
    if (!this._includeRun(run2)) {
      return;
    }
    if (this.counterMapByRunName[run2.name] === void 0) {
      this.counterMapByRunName[run2.name] = 0;
    }
    this.counterMapByRunName[run2.name] += 1;
    const count = this.counterMapByRunName[run2.name];
    this.keyMapByRunId[run2.id] = count === 1 ? run2.name : `${run2.name}:${count}`;
    const logEntry = {
      id: run2.id,
      name: run2.name,
      type: run2.run_type,
      tags: (_a = run2.tags) != null ? _a : [],
      metadata: (_c = (_b = run2.extra) == null ? void 0 : _b.metadata) != null ? _c : {},
      start_time: new Date(run2.start_time).toISOString(),
      streamed_output: [],
      streamed_output_str: [],
      final_output: void 0,
      end_time: void 0
    };
    if (this._schemaFormat === "streaming_events") {
      logEntry.inputs = await _getStandardizedInputs(run2, this._schemaFormat);
    }
    await this.writer.write(new RunLogPatch({
      ops: [
        {
          op: "add",
          path: `/logs/${this.keyMapByRunId[run2.id]}`,
          value: logEntry
        }
      ]
    }));
  }
  async onRunUpdate(run2) {
    try {
      const runName = this.keyMapByRunId[run2.id];
      if (runName === void 0) {
        return;
      }
      const ops = [];
      if (this._schemaFormat === "streaming_events") {
        ops.push({
          op: "replace",
          path: `/logs/${runName}/inputs`,
          value: await _getStandardizedInputs(run2, this._schemaFormat)
        });
      }
      ops.push({
        op: "add",
        path: `/logs/${runName}/final_output`,
        value: await _getStandardizedOutputs(run2, this._schemaFormat)
      });
      if (run2.end_time !== void 0) {
        ops.push({
          op: "add",
          path: `/logs/${runName}/end_time`,
          value: new Date(run2.end_time).toISOString()
        });
      }
      const patch = new RunLogPatch({ ops });
      await this.writer.write(patch);
    } finally {
      if (run2.id === this.rootId) {
        const patch = new RunLogPatch({
          ops: [
            {
              op: "replace",
              path: "/final_output",
              value: await _getStandardizedOutputs(run2, this._schemaFormat)
            }
          ]
        });
        await this.writer.write(patch);
        if (this.autoClose) {
          await this.writer.close();
        }
      }
    }
  }
  async onLLMNewToken(run2, token, kwargs) {
    const runName = this.keyMapByRunId[run2.id];
    if (runName === void 0) {
      return;
    }
    const isChatModel = run2.inputs.messages !== void 0;
    let streamedOutputValue;
    if (isChatModel) {
      if (isChatGenerationChunk(kwargs == null ? void 0 : kwargs.chunk)) {
        streamedOutputValue = kwargs == null ? void 0 : kwargs.chunk;
      } else {
        streamedOutputValue = new AIMessageChunk(token);
      }
    } else {
      streamedOutputValue = token;
    }
    const patch = new RunLogPatch({
      ops: [
        {
          op: "add",
          path: `/logs/${runName}/streamed_output_str/-`,
          value: token
        },
        {
          op: "add",
          path: `/logs/${runName}/streamed_output/-`,
          value: streamedOutputValue
        }
      ]
    });
    await this.writer.write(patch);
  }
};

// ../../node_modules/@langchain/core/dist/singletons/index.js
var MockAsyncLocalStorage = class {
  getStore() {
    return void 0;
  }
  run(_store, callback) {
    callback();
  }
};
var AsyncLocalStorageProvider = class {
  constructor() {
    Object.defineProperty(this, "asyncLocalStorage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new MockAsyncLocalStorage()
    });
    Object.defineProperty(this, "hasBeenInitialized", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
  }
  getInstance() {
    return this.asyncLocalStorage;
  }
  initializeGlobalInstance(instance) {
    if (!this.hasBeenInitialized) {
      this.hasBeenInitialized = true;
      this.asyncLocalStorage = instance;
    }
  }
};
var AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();

// ../../node_modules/@langchain/core/dist/runnables/config.js
var DEFAULT_RECURSION_LIMIT = 25;
async function getCallbackManagerForConfig(config) {
  return CallbackManager.configure(config == null ? void 0 : config.callbacks, void 0, config == null ? void 0 : config.tags, void 0, config == null ? void 0 : config.metadata);
}
function mergeConfigs(...configs) {
  var _a, _b;
  const copy = ensureConfig();
  for (const options of configs.filter((c) => !!c)) {
    for (const key of Object.keys(options)) {
      if (key === "metadata") {
        copy[key] = { ...copy[key], ...options[key] };
      } else if (key === "tags") {
        copy[key] = [...new Set(copy[key].concat((_a = options[key]) != null ? _a : []))];
      } else if (key === "configurable") {
        copy[key] = { ...copy[key], ...options[key] };
      } else if (key === "callbacks") {
        const baseCallbacks = copy.callbacks;
        const providedCallbacks = options.callbacks;
        if (Array.isArray(providedCallbacks)) {
          if (!baseCallbacks) {
            copy.callbacks = providedCallbacks;
          } else if (Array.isArray(baseCallbacks)) {
            copy.callbacks = baseCallbacks.concat(providedCallbacks);
          } else {
            const manager = baseCallbacks.copy();
            for (const callback of providedCallbacks) {
              manager.addHandler(ensureHandler(callback), true);
            }
            copy.callbacks = manager;
          }
        } else if (providedCallbacks) {
          if (!baseCallbacks) {
            copy.callbacks = providedCallbacks;
          } else if (Array.isArray(baseCallbacks)) {
            const manager = providedCallbacks.copy();
            for (const callback of baseCallbacks) {
              manager.addHandler(ensureHandler(callback), true);
            }
            copy.callbacks = manager;
          } else {
            copy.callbacks = new CallbackManager(providedCallbacks._parentRunId, {
              handlers: baseCallbacks.handlers.concat(providedCallbacks.handlers),
              inheritableHandlers: baseCallbacks.inheritableHandlers.concat(providedCallbacks.inheritableHandlers),
              tags: Array.from(new Set(baseCallbacks.tags.concat(providedCallbacks.tags))),
              inheritableTags: Array.from(new Set(baseCallbacks.inheritableTags.concat(providedCallbacks.inheritableTags))),
              metadata: {
                ...baseCallbacks.metadata,
                ...providedCallbacks.metadata
              }
            });
          }
        }
      } else {
        const typedKey = key;
        copy[typedKey] = (_b = options[typedKey]) != null ? _b : copy[typedKey];
      }
    }
  }
  return copy;
}
var PRIMITIVES = /* @__PURE__ */ new Set(["string", "number", "boolean"]);
function ensureConfig(config) {
  var _a;
  const loadedConfig = config != null ? config : AsyncLocalStorageProviderSingleton.getInstance().getStore();
  let empty = {
    tags: [],
    metadata: {},
    callbacks: void 0,
    recursionLimit: 25
  };
  if (loadedConfig) {
    empty = { ...empty, ...loadedConfig };
  }
  if (loadedConfig == null ? void 0 : loadedConfig.configurable) {
    for (const key of Object.keys(loadedConfig.configurable)) {
      if (PRIMITIVES.has(typeof loadedConfig.configurable[key]) && !((_a = empty.metadata) == null ? void 0 : _a[key])) {
        if (!empty.metadata) {
          empty.metadata = {};
        }
        empty.metadata[key] = loadedConfig.configurable[key];
      }
    }
  }
  return empty;
}
function patchConfig(config = {}, { callbacks, maxConcurrency, recursionLimit, runName, configurable } = {}) {
  const newConfig = ensureConfig(config);
  if (callbacks !== void 0) {
    delete newConfig.runName;
    newConfig.callbacks = callbacks;
  }
  if (recursionLimit !== void 0) {
    newConfig.recursionLimit = recursionLimit;
  }
  if (maxConcurrency !== void 0) {
    newConfig.maxConcurrency = maxConcurrency;
  }
  if (runName !== void 0) {
    newConfig.runName = runName;
  }
  if (configurable !== void 0) {
    newConfig.configurable = { ...newConfig.configurable, ...configurable };
  }
  return newConfig;
}

// ../../node_modules/@langchain/core/dist/tracers/root_listener.js
var RootListenersTracer = class extends BaseTracer {
  constructor({ config, onStart, onEnd, onError }) {
    super();
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RootListenersTracer"
    });
    Object.defineProperty(this, "rootId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "config", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "argOnStart", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "argOnEnd", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "argOnError", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.config = config;
    this.argOnStart = onStart;
    this.argOnEnd = onEnd;
    this.argOnError = onError;
  }
  /**
   * This is a legacy method only called once for an entire run tree
   * therefore not useful here
   * @param {Run} _ Not used
   */
  persistRun(_) {
    return Promise.resolve();
  }
  async onRunCreate(run2) {
    if (this.rootId) {
      return;
    }
    this.rootId = run2.id;
    if (this.argOnStart) {
      if (this.argOnStart.length === 1) {
        await this.argOnStart(run2);
      } else if (this.argOnStart.length === 2) {
        await this.argOnStart(run2, this.config);
      }
    }
  }
  async onRunUpdate(run2) {
    if (run2.id !== this.rootId) {
      return;
    }
    if (!run2.error) {
      if (this.argOnEnd) {
        if (this.argOnEnd.length === 1) {
          await this.argOnEnd(run2);
        } else if (this.argOnEnd.length === 2) {
          await this.argOnEnd(run2, this.config);
        }
      }
    } else if (this.argOnError) {
      if (this.argOnError.length === 1) {
        await this.argOnError(run2);
      } else if (this.argOnError.length === 2) {
        await this.argOnError(run2, this.config);
      }
    }
  }
};

// ../../node_modules/@langchain/core/dist/runnables/utils.js
var _RootEventFilter = class {
  constructor(fields) {
    Object.defineProperty(this, "includeNames", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "includeTypes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "includeTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "excludeNames", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "excludeTypes", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "excludeTags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.includeNames = fields.includeNames;
    this.includeTypes = fields.includeTypes;
    this.includeTags = fields.includeTags;
    this.excludeNames = fields.excludeNames;
    this.excludeTypes = fields.excludeTypes;
    this.excludeTags = fields.excludeTags;
  }
  includeEvent(event, rootType) {
    var _a;
    let include = this.includeNames === void 0 && this.includeTypes === void 0 && this.includeTags === void 0;
    const eventTags = (_a = event.tags) != null ? _a : [];
    if (this.includeNames !== void 0) {
      include = include || this.includeNames.includes(event.name);
    }
    if (this.includeTypes !== void 0) {
      include = include || this.includeTypes.includes(rootType);
    }
    if (this.includeTags !== void 0) {
      include = include || eventTags.some((tag) => {
        var _a2;
        return (_a2 = this.includeTags) == null ? void 0 : _a2.includes(tag);
      });
    }
    if (this.excludeNames !== void 0) {
      include = include && !this.excludeNames.includes(event.name);
    }
    if (this.excludeTypes !== void 0) {
      include = include && !this.excludeTypes.includes(rootType);
    }
    if (this.excludeTags !== void 0) {
      include = include && eventTags.every((tag) => {
        var _a2;
        return !((_a2 = this.excludeTags) == null ? void 0 : _a2.includes(tag));
      });
    }
    return include;
  }
};

// ../../node_modules/@langchain/core/dist/runnables/base.js
function _coerceToDict2(value, defaultKey) {
  return value && !Array.isArray(value) && // eslint-disable-next-line no-instanceof/no-instanceof
  !(value instanceof Date) && typeof value === "object" ? value : { [defaultKey]: value };
}
var Runnable = class extends Serializable {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "lc_runnable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
  }
  getName(suffix) {
    var _a, _b;
    const name = (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (_b = (_a = this.name) != null ? _a : this.constructor.lc_name()) != null ? _b : this.constructor.name
    );
    return suffix ? `${name}${suffix}` : name;
  }
  /**
   * Bind arguments to a Runnable, returning a new Runnable.
   * @param kwargs
   * @returns A new RunnableBinding that, when invoked, will apply the bound args.
   */
  bind(kwargs) {
    return new RunnableBinding({ bound: this, kwargs, config: {} });
  }
  /**
   * Return a new Runnable that maps a list of inputs to a list of outputs,
   * by calling invoke() with each input.
   */
  map() {
    return new RunnableEach({ bound: this });
  }
  /**
   * Add retry logic to an existing runnable.
   * @param kwargs
   * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.
   */
  withRetry(fields) {
    return new RunnableRetry({
      bound: this,
      kwargs: {},
      config: {},
      maxAttemptNumber: fields == null ? void 0 : fields.stopAfterAttempt,
      ...fields
    });
  }
  /**
   * Bind config to a Runnable, returning a new Runnable.
   * @param config New configuration parameters to attach to the new runnable.
   * @returns A new RunnableBinding with a config matching what's passed.
   */
  withConfig(config) {
    return new RunnableBinding({
      bound: this,
      config,
      kwargs: {}
    });
  }
  /**
   * Create a new runnable from the current one that will try invoking
   * other passed fallback runnables if the initial invocation fails.
   * @param fields.fallbacks Other runnables to call if the runnable errors.
   * @returns A new RunnableWithFallbacks.
   */
  withFallbacks(fields) {
    return new RunnableWithFallbacks({
      runnable: this,
      fallbacks: fields.fallbacks
    });
  }
  _getOptionsList(options, length = 0) {
    if (Array.isArray(options)) {
      if (options.length !== length) {
        throw new Error(`Passed "options" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);
      }
      return options.map(ensureConfig);
    }
    return Array.from({ length }, () => ensureConfig(options));
  }
  async batch(inputs, options, batchOptions) {
    var _a, _b;
    const configList = this._getOptionsList(options != null ? options : {}, inputs.length);
    const maxConcurrency = (_b = (_a = configList[0]) == null ? void 0 : _a.maxConcurrency) != null ? _b : batchOptions == null ? void 0 : batchOptions.maxConcurrency;
    const caller2 = new AsyncCaller2({
      maxConcurrency,
      onFailedAttempt: (e) => {
        throw e;
      }
    });
    const batchCalls = inputs.map((input, i) => caller2.call(async () => {
      try {
        const result = await this.invoke(input, configList[i]);
        return result;
      } catch (e) {
        if (batchOptions == null ? void 0 : batchOptions.returnExceptions) {
          return e;
        }
        throw e;
      }
    }));
    return Promise.all(batchCalls);
  }
  /**
   * Default streaming implementation.
   * Subclasses should override this method if they support streaming output.
   * @param input
   * @param options
   */
  async *_streamIterator(input, options) {
    yield this.invoke(input, options);
  }
  /**
   * Stream output in chunks.
   * @param input
   * @param options
   * @returns A readable stream that is also an iterable.
   */
  async stream(input, options) {
    const wrappedGenerator = new AsyncGeneratorWithSetup(this._streamIterator(input, ensureConfig(options)));
    await wrappedGenerator.setup;
    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
  }
  _separateRunnableConfigFromCallOptions(options = {}) {
    const runnableConfig = ensureConfig({
      callbacks: options.callbacks,
      tags: options.tags,
      metadata: options.metadata,
      runName: options.runName,
      configurable: options.configurable,
      recursionLimit: options.recursionLimit,
      maxConcurrency: options.maxConcurrency
    });
    const callOptions = { ...options };
    delete callOptions.callbacks;
    delete callOptions.tags;
    delete callOptions.metadata;
    delete callOptions.runName;
    delete callOptions.configurable;
    delete callOptions.recursionLimit;
    delete callOptions.maxConcurrency;
    return [runnableConfig, callOptions];
  }
  async _callWithConfig(func, input, options) {
    var _a;
    const config = ensureConfig(options);
    const callbackManager_ = await getCallbackManagerForConfig(config);
    const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict2(input, "input"), void 0, config == null ? void 0 : config.runType, void 0, void 0, (_a = config == null ? void 0 : config.runName) != null ? _a : this.getName()));
    let output;
    try {
      output = await func.call(this, input, config, runManager);
    } catch (e) {
      await (runManager == null ? void 0 : runManager.handleChainError(e));
      throw e;
    }
    await (runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict2(output, "output")));
    return output;
  }
  /**
   * Internal method that handles batching and configuration for a runnable
   * It takes a function, input values, and optional configuration, and
   * returns a promise that resolves to the output values.
   * @param func The function to be executed for each input value.
   * @param input The input values to be processed.
   * @param config Optional configuration for the function execution.
   * @returns A promise that resolves to the output values.
   */
  async _batchWithConfig(func, inputs, options, batchOptions) {
    const optionsList = this._getOptionsList(options != null ? options : {}, inputs.length);
    const callbackManagers = await Promise.all(optionsList.map(getCallbackManagerForConfig));
    const runManagers = await Promise.all(callbackManagers.map((callbackManager, i) => {
      var _a;
      return callbackManager == null ? void 0 : callbackManager.handleChainStart(this.toJSON(), _coerceToDict2(inputs[i], "input"), void 0, optionsList[i].runType, void 0, void 0, (_a = optionsList[i].runName) != null ? _a : this.getName());
    }));
    let outputs;
    try {
      outputs = await func.call(this, inputs, optionsList, runManagers, batchOptions);
    } catch (e) {
      await Promise.all(runManagers.map((runManager) => runManager == null ? void 0 : runManager.handleChainError(e)));
      throw e;
    }
    await Promise.all(runManagers.map((runManager) => runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict2(outputs, "output"))));
    return outputs;
  }
  /**
   * Helper method to transform an Iterator of Input values into an Iterator of
   * Output values, with callbacks.
   * Use this to implement `stream()` or `transform()` in Runnable subclasses.
   */
  async *_transformStreamWithConfig(inputGenerator, transformer, options) {
    let finalInput;
    let finalInputSupported = true;
    let finalOutput;
    let finalOutputSupported = true;
    const config = ensureConfig(options);
    const callbackManager_ = await getCallbackManagerForConfig(config);
    async function* wrapInputForTracing() {
      for await (const chunk of inputGenerator) {
        if (finalInputSupported) {
          if (finalInput === void 0) {
            finalInput = chunk;
          } else {
            try {
              finalInput = concat(finalInput, chunk);
            } catch (e) {
              finalInput = void 0;
              finalInputSupported = false;
            }
          }
        }
        yield chunk;
      }
    }
    let runManager;
    try {
      const pipe = await pipeGeneratorWithSetup(transformer.bind(this), wrapInputForTracing(), async () => {
        var _a;
        return callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), { input: "" }, void 0, config == null ? void 0 : config.runType, void 0, void 0, (_a = config == null ? void 0 : config.runName) != null ? _a : this.getName());
      }, config);
      runManager = pipe.setup;
      const isLogStreamHandler = (handler) => handler.name === "log_stream_tracer";
      const streamLogHandler = runManager == null ? void 0 : runManager.handlers.find(isLogStreamHandler);
      let iterator = pipe.output;
      if (streamLogHandler !== void 0 && runManager !== void 0) {
        iterator = await streamLogHandler.tapOutputIterable(runManager.runId, pipe.output);
      }
      for await (const chunk of iterator) {
        yield chunk;
        if (finalOutputSupported) {
          if (finalOutput === void 0) {
            finalOutput = chunk;
          } else {
            try {
              finalOutput = concat(finalOutput, chunk);
            } catch (e) {
              finalOutput = void 0;
              finalOutputSupported = false;
            }
          }
        }
      }
    } catch (e) {
      await (runManager == null ? void 0 : runManager.handleChainError(e, void 0, void 0, void 0, {
        inputs: _coerceToDict2(finalInput, "input")
      }));
      throw e;
    }
    await (runManager == null ? void 0 : runManager.handleChainEnd(finalOutput != null ? finalOutput : {}, void 0, void 0, void 0, { inputs: _coerceToDict2(finalInput, "input") }));
  }
  /**
   * Create a new runnable sequence that runs each individual runnable in series,
   * piping the output of one runnable into another runnable or runnable-like.
   * @param coerceable A runnable, function, or object whose values are functions or runnables.
   * @returns A new runnable sequence.
   */
  pipe(coerceable) {
    return new RunnableSequence({
      first: this,
      last: _coerceToRunnable(coerceable)
    });
  }
  /**
   * Pick keys from the dict output of this runnable. Returns a new runnable.
   */
  pick(keys) {
    return this.pipe(new RunnablePick(keys));
  }
  /**
   * Assigns new fields to the dict output of this runnable. Returns a new runnable.
   */
  assign(mapping) {
    return this.pipe(
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      new RunnableAssign(
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        new RunnableMap({ steps: mapping })
      )
    );
  }
  /**
   * Default implementation of transform, which buffers input and then calls stream.
   * Subclasses should override this method if they can start producing output while
   * input is still being generated.
   * @param generator
   * @param options
   */
  async *transform(generator, options) {
    let finalChunk;
    for await (const chunk of generator) {
      if (finalChunk === void 0) {
        finalChunk = chunk;
      } else {
        finalChunk = concat(finalChunk, chunk);
      }
    }
    yield* this._streamIterator(finalChunk, ensureConfig(options));
  }
  /**
   * Stream all output from a runnable, as reported to the callback system.
   * This includes all inner runs of LLMs, Retrievers, Tools, etc.
   * Output is streamed as Log objects, which include a list of
   * jsonpatch ops that describe how the state of the run has changed in each
   * step, and the final state of the run.
   * The jsonpatch ops can be applied in order to construct state.
   * @param input
   * @param options
   * @param streamOptions
   */
  async *streamLog(input, options, streamOptions) {
    const logStreamCallbackHandler = new LogStreamCallbackHandler({
      ...streamOptions,
      autoClose: false,
      _schemaFormat: "original"
    });
    const config = ensureConfig(options);
    yield* this._streamLog(input, logStreamCallbackHandler, config);
  }
  async *_streamLog(input, logStreamCallbackHandler, config) {
    const { callbacks } = config;
    if (callbacks === void 0) {
      config.callbacks = [logStreamCallbackHandler];
    } else if (Array.isArray(callbacks)) {
      config.callbacks = callbacks.concat([logStreamCallbackHandler]);
    } else {
      const copiedCallbacks = callbacks.copy();
      copiedCallbacks.inheritableHandlers.push(logStreamCallbackHandler);
      config.callbacks = copiedCallbacks;
    }
    const runnableStreamPromise = this.stream(input, config);
    async function consumeRunnableStream() {
      try {
        const runnableStream = await runnableStreamPromise;
        for await (const chunk of runnableStream) {
          const patch = new RunLogPatch({
            ops: [
              {
                op: "add",
                path: "/streamed_output/-",
                value: chunk
              }
            ]
          });
          await logStreamCallbackHandler.writer.write(patch);
        }
      } finally {
        await logStreamCallbackHandler.writer.close();
      }
    }
    const runnableStreamConsumePromise = consumeRunnableStream();
    try {
      for await (const log of logStreamCallbackHandler) {
        yield log;
      }
    } finally {
      await runnableStreamConsumePromise;
    }
  }
  /**
   * Generate a stream of events emitted by the internal steps of the runnable.
   *
   * Use to create an iterator over StreamEvents that provide real-time information
   * about the progress of the runnable, including StreamEvents from intermediate
   * results.
   *
   * A StreamEvent is a dictionary with the following schema:
   *
   * - `event`: string - Event names are of the format: on_[runnable_type]_(start|stream|end).
   * - `name`: string - The name of the runnable that generated the event.
   * - `run_id`: string - Randomly generated ID associated with the given execution of
   *   the runnable that emitted the event. A child runnable that gets invoked as part of the execution of a
   *   parent runnable is assigned its own unique ID.
   * - `tags`: string[] - The tags of the runnable that generated the event.
   * - `metadata`: Record<string, any> - The metadata of the runnable that generated the event.
   * - `data`: Record<string, any>
   *
   * Below is a table that illustrates some events that might be emitted by various
   * chains. Metadata fields have been omitted from the table for brevity.
   * Chain definitions have been included after the table.
   *
   * | event                | name             | chunk                              | input                                         | output                                          |
   * |----------------------|------------------|------------------------------------|-----------------------------------------------|-------------------------------------------------|
   * | on_llm_start         | [model name]     |                                    | {'input': 'hello'}                            |                                                 |
   * | on_llm_stream        | [model name]     | 'Hello' OR AIMessageChunk("hello") |                                               |                                                 |
   * | on_llm_end           | [model name]     |                                    | 'Hello human!'                                |
   * | on_chain_start       | format_docs      |                                    |                                               |                                                 |
   * | on_chain_stream      | format_docs      | "hello world!, goodbye world!"     |                                               |                                                 |
   * | on_chain_end         | format_docs      |                                    | [Document(...)]                               | "hello world!, goodbye world!"                  |
   * | on_tool_start        | some_tool        |                                    | {"x": 1, "y": "2"}                            |                                                 |
   * | on_tool_stream       | some_tool        |   {"x": 1, "y": "2"}               |                                               |                                                 |
   * | on_tool_end          | some_tool        |                                    |                                               | {"x": 1, "y": "2"}                              |
   * | on_retriever_start   | [retriever name] |                                    | {"query": "hello"}                            |                                                 |
   * | on_retriever_chunk   | [retriever name] |  {documents: [...]}                |                                               |                                                 |
   * | on_retriever_end     | [retriever name] |                                    | {"query": "hello"}                            | {documents: [...]}                              |
   * | on_prompt_start      | [template_name]  |                                    | {"question": "hello"}                         |                                                 |
   * | on_prompt_end        | [template_name]  |                                    | {"question": "hello"}                         | ChatPromptValue(messages: [SystemMessage, ...]) |
   */
  async *streamEvents(input, options, streamOptions) {
    var _a, _b, _c;
    if (options.version !== "v1") {
      throw new Error(`Only version "v1" of the events schema is currently supported.`);
    }
    let runLog;
    let hasEncounteredStartEvent = false;
    const config = ensureConfig(options);
    const rootTags = (_a = config.tags) != null ? _a : [];
    const rootMetadata = (_b = config.metadata) != null ? _b : {};
    const rootName = (_c = config.runName) != null ? _c : this.getName();
    const logStreamCallbackHandler = new LogStreamCallbackHandler({
      ...streamOptions,
      autoClose: false,
      _schemaFormat: "streaming_events"
    });
    const rootEventFilter = new _RootEventFilter({
      ...streamOptions
    });
    const logStream = this._streamLog(input, logStreamCallbackHandler, config);
    for await (const log of logStream) {
      if (!runLog) {
        runLog = RunLog.fromRunLogPatch(log);
      } else {
        runLog = runLog.concat(log);
      }
      if (runLog.state === void 0) {
        throw new Error(`Internal error: "streamEvents" state is missing. Please open a bug report.`);
      }
      if (!hasEncounteredStartEvent) {
        hasEncounteredStartEvent = true;
        const state3 = { ...runLog.state };
        const event = {
          run_id: state3.id,
          event: `on_${state3.type}_start`,
          name: rootName,
          tags: rootTags,
          metadata: rootMetadata,
          data: {
            input
          }
        };
        if (rootEventFilter.includeEvent(event, state3.type)) {
          yield event;
        }
      }
      const paths = log.ops.filter((op) => op.path.startsWith("/logs/")).map((op) => op.path.split("/")[2]);
      const dedupedPaths = [...new Set(paths)];
      for (const path of dedupedPaths) {
        let eventType;
        let data = {};
        const logEntry = runLog.state.logs[path];
        if (logEntry.end_time === void 0) {
          if (logEntry.streamed_output.length > 0) {
            eventType = "stream";
          } else {
            eventType = "start";
          }
        } else {
          eventType = "end";
        }
        if (eventType === "start") {
          if (logEntry.inputs !== void 0) {
            data.input = logEntry.inputs;
          }
        } else if (eventType === "end") {
          if (logEntry.inputs !== void 0) {
            data.input = logEntry.inputs;
          }
          data.output = logEntry.final_output;
        } else if (eventType === "stream") {
          const chunkCount = logEntry.streamed_output.length;
          if (chunkCount !== 1) {
            throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: "${logEntry.name}"`);
          }
          data = { chunk: logEntry.streamed_output[0] };
          logEntry.streamed_output = [];
        }
        yield {
          event: `on_${logEntry.type}_${eventType}`,
          name: logEntry.name,
          run_id: logEntry.id,
          tags: logEntry.tags,
          metadata: logEntry.metadata,
          data
        };
      }
      const { state: state2 } = runLog;
      if (state2.streamed_output.length > 0) {
        const chunkCount = state2.streamed_output.length;
        if (chunkCount !== 1) {
          throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: "${state2.name}"`);
        }
        const data = { chunk: state2.streamed_output[0] };
        state2.streamed_output = [];
        const event = {
          event: `on_${state2.type}_stream`,
          run_id: state2.id,
          tags: rootTags,
          metadata: rootMetadata,
          name: rootName,
          data
        };
        if (rootEventFilter.includeEvent(event, state2.type)) {
          yield event;
        }
      }
    }
    const state = runLog == null ? void 0 : runLog.state;
    if (state !== void 0) {
      const event = {
        event: `on_${state.type}_end`,
        name: rootName,
        run_id: state.id,
        tags: rootTags,
        metadata: rootMetadata,
        data: {
          output: state.final_output
        }
      };
      if (rootEventFilter.includeEvent(event, state.type))
        yield event;
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static isRunnable(thing) {
    return thing ? thing.lc_runnable : false;
  }
  /**
   * Bind lifecycle listeners to a Runnable, returning a new Runnable.
   * The Run object contains information about the run, including its id,
   * type, input, output, error, startTime, endTime, and any tags or metadata
   * added to the run.
   *
   * @param {Object} params - The object containing the callback functions.
   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
   */
  withListeners({ onStart, onEnd, onError }) {
    return new RunnableBinding({
      bound: this,
      config: {},
      configFactories: [
        (config) => ({
          callbacks: [
            new RootListenersTracer({
              config,
              onStart,
              onEnd,
              onError
            })
          ]
        })
      ]
    });
  }
};
var RunnableBinding = class _RunnableBinding extends Runnable {
  static lc_name() {
    return "RunnableBinding";
  }
  constructor(fields) {
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "bound", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "config", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "kwargs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "configFactories", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.bound = fields.bound;
    this.kwargs = fields.kwargs;
    this.config = fields.config;
    this.configFactories = fields.configFactories;
  }
  getName(suffix) {
    return this.bound.getName(suffix);
  }
  async _mergeConfig(...options) {
    const config = mergeConfigs(this.config, ...options);
    return mergeConfigs(config, ...this.configFactories ? await Promise.all(this.configFactories.map(async (configFactory) => await configFactory(config))) : []);
  }
  bind(kwargs) {
    return new this.constructor({
      bound: this.bound,
      kwargs: { ...this.kwargs, ...kwargs },
      config: this.config
    });
  }
  withConfig(config) {
    return new this.constructor({
      bound: this.bound,
      kwargs: this.kwargs,
      config: { ...this.config, ...config }
    });
  }
  withRetry(fields) {
    return new this.constructor({
      bound: this.bound.withRetry(fields),
      kwargs: this.kwargs,
      config: this.config
    });
  }
  async invoke(input, options) {
    return this.bound.invoke(input, await this._mergeConfig(options, this.kwargs));
  }
  async batch(inputs, options, batchOptions) {
    const mergedOptions = Array.isArray(options) ? await Promise.all(options.map(async (individualOption) => this._mergeConfig(individualOption, this.kwargs))) : await this._mergeConfig(options, this.kwargs);
    return this.bound.batch(inputs, mergedOptions, batchOptions);
  }
  async *_streamIterator(input, options) {
    yield* this.bound._streamIterator(input, await this._mergeConfig(options, this.kwargs));
  }
  async stream(input, options) {
    return this.bound.stream(input, await this._mergeConfig(options, this.kwargs));
  }
  async *transform(generator, options) {
    yield* this.bound.transform(generator, await this._mergeConfig(options, this.kwargs));
  }
  async *streamEvents(input, options, streamOptions) {
    yield* this.bound.streamEvents(input, {
      ...await this._mergeConfig(options, this.kwargs),
      version: options.version
    }, streamOptions);
  }
  static isRunnableBinding(thing) {
    return thing.bound && Runnable.isRunnable(thing.bound);
  }
  /**
   * Bind lifecycle listeners to a Runnable, returning a new Runnable.
   * The Run object contains information about the run, including its id,
   * type, input, output, error, startTime, endTime, and any tags or metadata
   * added to the run.
   *
   * @param {Object} params - The object containing the callback functions.
   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
   */
  withListeners({ onStart, onEnd, onError }) {
    return new _RunnableBinding({
      bound: this.bound,
      kwargs: this.kwargs,
      config: this.config,
      configFactories: [
        (config) => ({
          callbacks: [
            new RootListenersTracer({
              config,
              onStart,
              onEnd,
              onError
            })
          ]
        })
      ]
    });
  }
};
var RunnableEach = class _RunnableEach extends Runnable {
  static lc_name() {
    return "RunnableEach";
  }
  constructor(fields) {
    super(fields);
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    Object.defineProperty(this, "bound", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.bound = fields.bound;
  }
  /**
   * Binds the runnable with the specified arguments.
   * @param kwargs The arguments to bind the runnable with.
   * @returns A new instance of the `RunnableEach` class that is bound with the specified arguments.
   */
  bind(kwargs) {
    return new _RunnableEach({
      bound: this.bound.bind(kwargs)
    });
  }
  /**
   * Invokes the runnable with the specified input and configuration.
   * @param input The input to invoke the runnable with.
   * @param config The configuration to invoke the runnable with.
   * @returns A promise that resolves to the output of the runnable.
   */
  async invoke(inputs, config) {
    return this._callWithConfig(this._invoke, inputs, config);
  }
  /**
   * A helper method that is used to invoke the runnable with the specified input and configuration.
   * @param input The input to invoke the runnable with.
   * @param config The configuration to invoke the runnable with.
   * @returns A promise that resolves to the output of the runnable.
   */
  async _invoke(inputs, config, runManager) {
    return this.bound.batch(inputs, patchConfig(config, { callbacks: runManager == null ? void 0 : runManager.getChild() }));
  }
  /**
   * Bind lifecycle listeners to a Runnable, returning a new Runnable.
   * The Run object contains information about the run, including its id,
   * type, input, output, error, startTime, endTime, and any tags or metadata
   * added to the run.
   *
   * @param {Object} params - The object containing the callback functions.
   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.
   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.
   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.
   */
  withListeners({ onStart, onEnd, onError }) {
    return new _RunnableEach({
      bound: this.bound.withListeners({ onStart, onEnd, onError })
    });
  }
};
var RunnableRetry = class extends RunnableBinding {
  static lc_name() {
    return "RunnableRetry";
  }
  constructor(fields) {
    var _a, _b;
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    Object.defineProperty(this, "maxAttemptNumber", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 3
    });
    Object.defineProperty(this, "onFailedAttempt", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: () => {
      }
    });
    this.maxAttemptNumber = (_a = fields.maxAttemptNumber) != null ? _a : this.maxAttemptNumber;
    this.onFailedAttempt = (_b = fields.onFailedAttempt) != null ? _b : this.onFailedAttempt;
  }
  _patchConfigForRetry(attempt, config, runManager) {
    const tag = attempt > 1 ? `retry:attempt:${attempt}` : void 0;
    return patchConfig(config, { callbacks: runManager == null ? void 0 : runManager.getChild(tag) });
  }
  async _invoke(input, config, runManager) {
    return (0, import_p_retry3.default)((attemptNumber) => super.invoke(input, this._patchConfigForRetry(attemptNumber, config, runManager)), {
      onFailedAttempt: this.onFailedAttempt,
      retries: Math.max(this.maxAttemptNumber - 1, 0),
      randomize: true
    });
  }
  /**
   * Method that invokes the runnable with the specified input, run manager,
   * and config. It handles the retry logic by catching any errors and
   * recursively invoking itself with the updated config for the next retry
   * attempt.
   * @param input The input for the runnable.
   * @param runManager The run manager for the runnable.
   * @param config The config for the runnable.
   * @returns A promise that resolves to the output of the runnable.
   */
  async invoke(input, config) {
    return this._callWithConfig(this._invoke, input, config);
  }
  async _batch(inputs, configs, runManagers, batchOptions) {
    const resultsMap = {};
    try {
      await (0, import_p_retry3.default)(async (attemptNumber) => {
        const remainingIndexes = inputs.map((_, i) => i).filter((i) => resultsMap[i.toString()] === void 0 || // eslint-disable-next-line no-instanceof/no-instanceof
        resultsMap[i.toString()] instanceof Error);
        const remainingInputs = remainingIndexes.map((i) => inputs[i]);
        const patchedConfigs = remainingIndexes.map((i) => this._patchConfigForRetry(attemptNumber, configs == null ? void 0 : configs[i], runManagers == null ? void 0 : runManagers[i]));
        const results = await super.batch(remainingInputs, patchedConfigs, {
          ...batchOptions,
          returnExceptions: true
        });
        let firstException;
        for (let i = 0; i < results.length; i += 1) {
          const result = results[i];
          const resultMapIndex = remainingIndexes[i];
          if (result instanceof Error) {
            if (firstException === void 0) {
              firstException = result;
            }
          }
          resultsMap[resultMapIndex.toString()] = result;
        }
        if (firstException) {
          throw firstException;
        }
        return results;
      }, {
        onFailedAttempt: this.onFailedAttempt,
        retries: Math.max(this.maxAttemptNumber - 1, 0),
        randomize: true
      });
    } catch (e) {
      if ((batchOptions == null ? void 0 : batchOptions.returnExceptions) !== true) {
        throw e;
      }
    }
    return Object.keys(resultsMap).sort((a, b) => parseInt(a, 10) - parseInt(b, 10)).map((key) => resultsMap[parseInt(key, 10)]);
  }
  async batch(inputs, options, batchOptions) {
    return this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions);
  }
};
var RunnableSequence = class _RunnableSequence extends Runnable {
  static lc_name() {
    return "RunnableSequence";
  }
  constructor(fields) {
    var _a;
    super(fields);
    Object.defineProperty(this, "first", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "middle", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "last", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    this.first = fields.first;
    this.middle = (_a = fields.middle) != null ? _a : this.middle;
    this.last = fields.last;
    this.name = fields.name;
  }
  get steps() {
    return [this.first, ...this.middle, this.last];
  }
  async invoke(input, options) {
    const config = ensureConfig(options);
    const callbackManager_ = await getCallbackManagerForConfig(config);
    const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict2(input, "input"), void 0, void 0, void 0, void 0, config == null ? void 0 : config.runName));
    let nextStepInput = input;
    let finalOutput;
    try {
      const initialSteps = [this.first, ...this.middle];
      for (let i = 0; i < initialSteps.length; i += 1) {
        const step = initialSteps[i];
        nextStepInput = await step.invoke(nextStepInput, patchConfig(config, {
          callbacks: runManager == null ? void 0 : runManager.getChild(`seq:step:${i + 1}`)
        }));
      }
      finalOutput = await this.last.invoke(nextStepInput, patchConfig(config, {
        callbacks: runManager == null ? void 0 : runManager.getChild(`seq:step:${this.steps.length}`)
      }));
    } catch (e) {
      await (runManager == null ? void 0 : runManager.handleChainError(e));
      throw e;
    }
    await (runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict2(finalOutput, "output")));
    return finalOutput;
  }
  async batch(inputs, options, batchOptions) {
    const configList = this._getOptionsList(options != null ? options : {}, inputs.length);
    const callbackManagers = await Promise.all(configList.map(getCallbackManagerForConfig));
    const runManagers = await Promise.all(callbackManagers.map((callbackManager, i) => callbackManager == null ? void 0 : callbackManager.handleChainStart(this.toJSON(), _coerceToDict2(inputs[i], "input"), void 0, void 0, void 0, void 0, configList[i].runName)));
    let nextStepInputs = inputs;
    try {
      for (let i = 0; i < this.steps.length; i += 1) {
        const step = this.steps[i];
        nextStepInputs = await step.batch(nextStepInputs, runManagers.map((runManager, j) => {
          const childRunManager = runManager == null ? void 0 : runManager.getChild(`seq:step:${i + 1}`);
          return patchConfig(configList[j], { callbacks: childRunManager });
        }), batchOptions);
      }
    } catch (e) {
      await Promise.all(runManagers.map((runManager) => runManager == null ? void 0 : runManager.handleChainError(e)));
      throw e;
    }
    await Promise.all(runManagers.map((runManager) => runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict2(nextStepInputs, "output"))));
    return nextStepInputs;
  }
  async *_streamIterator(input, options) {
    const callbackManager_ = await getCallbackManagerForConfig(options);
    const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict2(input, "input"), void 0, void 0, void 0, void 0, options == null ? void 0 : options.runName));
    const steps = [this.first, ...this.middle, this.last];
    let concatSupported = true;
    let finalOutput;
    async function* inputGenerator() {
      yield input;
    }
    try {
      let finalGenerator = steps[0].transform(inputGenerator(), patchConfig(options, {
        callbacks: runManager == null ? void 0 : runManager.getChild(`seq:step:1`)
      }));
      for (let i = 1; i < steps.length; i += 1) {
        const step = steps[i];
        finalGenerator = await step.transform(finalGenerator, patchConfig(options, {
          callbacks: runManager == null ? void 0 : runManager.getChild(`seq:step:${i + 1}`)
        }));
      }
      for await (const chunk of finalGenerator) {
        yield chunk;
        if (concatSupported) {
          if (finalOutput === void 0) {
            finalOutput = chunk;
          } else {
            try {
              finalOutput = concat(finalOutput, chunk);
            } catch (e) {
              finalOutput = void 0;
              concatSupported = false;
            }
          }
        }
      }
    } catch (e) {
      await (runManager == null ? void 0 : runManager.handleChainError(e));
      throw e;
    }
    await (runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict2(finalOutput, "output")));
  }
  pipe(coerceable) {
    var _a;
    if (_RunnableSequence.isRunnableSequence(coerceable)) {
      return new _RunnableSequence({
        first: this.first,
        middle: this.middle.concat([
          this.last,
          coerceable.first,
          ...coerceable.middle
        ]),
        last: coerceable.last,
        name: (_a = this.name) != null ? _a : coerceable.name
      });
    } else {
      return new _RunnableSequence({
        first: this.first,
        middle: [...this.middle, this.last],
        last: _coerceToRunnable(coerceable),
        name: this.name
      });
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static isRunnableSequence(thing) {
    return Array.isArray(thing.middle) && Runnable.isRunnable(thing);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static from([first, ...runnables], name) {
    return new _RunnableSequence({
      first: _coerceToRunnable(first),
      middle: runnables.slice(0, -1).map(_coerceToRunnable),
      last: _coerceToRunnable(runnables[runnables.length - 1]),
      name
    });
  }
};
var RunnableMap = class _RunnableMap extends Runnable {
  static lc_name() {
    return "RunnableMap";
  }
  getStepsKeys() {
    return Object.keys(this.steps);
  }
  constructor(fields) {
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "steps", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.steps = {};
    for (const [key, value] of Object.entries(fields.steps)) {
      this.steps[key] = _coerceToRunnable(value);
    }
  }
  static from(steps) {
    return new _RunnableMap({ steps });
  }
  async invoke(input, options) {
    const config = ensureConfig(options);
    const callbackManager_ = await getCallbackManagerForConfig(config);
    const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), {
      input
    }, void 0, void 0, void 0, void 0, config == null ? void 0 : config.runName));
    const output = {};
    try {
      await Promise.all(Object.entries(this.steps).map(async ([key, runnable]) => {
        output[key] = await runnable.invoke(input, patchConfig(config, {
          callbacks: runManager == null ? void 0 : runManager.getChild(`map:key:${key}`)
        }));
      }));
    } catch (e) {
      await (runManager == null ? void 0 : runManager.handleChainError(e));
      throw e;
    }
    await (runManager == null ? void 0 : runManager.handleChainEnd(output));
    return output;
  }
  async *_transform(generator, runManager, options) {
    const steps = { ...this.steps };
    const inputCopies = atee(generator, Object.keys(steps).length);
    const tasks = new Map(Object.entries(steps).map(([key, runnable], i) => {
      const gen = runnable.transform(inputCopies[i], patchConfig(options, {
        callbacks: runManager == null ? void 0 : runManager.getChild(`map:key:${key}`)
      }));
      return [key, gen.next().then((result) => ({ key, gen, result }))];
    }));
    while (tasks.size) {
      const { key, result, gen } = await Promise.race(tasks.values());
      tasks.delete(key);
      if (!result.done) {
        yield { [key]: result.value };
        tasks.set(key, gen.next().then((result2) => ({ key, gen, result: result2 })));
      }
    }
  }
  transform(generator, options) {
    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
  }
  async stream(input, options) {
    async function* generator() {
      yield input;
    }
    const wrappedGenerator = new AsyncGeneratorWithSetup(this.transform(generator(), options));
    await wrappedGenerator.setup;
    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
  }
};
var RunnableLambda = class _RunnableLambda extends Runnable {
  static lc_name() {
    return "RunnableLambda";
  }
  constructor(fields) {
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    Object.defineProperty(this, "func", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.func = fields.func;
  }
  static from(func) {
    return new _RunnableLambda({
      func
    });
  }
  async _invoke(input, config, runManager) {
    return new Promise((resolve, reject) => {
      var _a;
      const childConfig = patchConfig(config, {
        callbacks: runManager == null ? void 0 : runManager.getChild(),
        recursionLimit: ((_a = config == null ? void 0 : config.recursionLimit) != null ? _a : DEFAULT_RECURSION_LIMIT) - 1
      });
      void AsyncLocalStorageProviderSingleton.getInstance().run(childConfig, async () => {
        var _a2;
        try {
          let output = await this.func(input, {
            ...childConfig,
            config: childConfig
          });
          if (output && Runnable.isRunnable(output)) {
            if ((config == null ? void 0 : config.recursionLimit) === 0) {
              throw new Error("Recursion limit reached.");
            }
            output = await output.invoke(input, {
              ...childConfig,
              recursionLimit: ((_a2 = childConfig.recursionLimit) != null ? _a2 : DEFAULT_RECURSION_LIMIT) - 1
            });
          }
          resolve(output);
        } catch (e) {
          reject(e);
        }
      });
    });
  }
  async invoke(input, options) {
    return this._callWithConfig(this._invoke, input, options);
  }
  async *_transform(generator, runManager, config) {
    var _a;
    let finalChunk;
    for await (const chunk of generator) {
      if (finalChunk === void 0) {
        finalChunk = chunk;
      } else {
        try {
          finalChunk = concat(finalChunk, chunk);
        } catch (e) {
          finalChunk = chunk;
        }
      }
    }
    const output = await new Promise((resolve, reject) => {
      void AsyncLocalStorageProviderSingleton.getInstance().run(config, async () => {
        try {
          const res = await this.func(finalChunk, {
            ...config,
            config
          });
          resolve(res);
        } catch (e) {
          reject(e);
        }
      });
    });
    if (output && Runnable.isRunnable(output)) {
      if ((config == null ? void 0 : config.recursionLimit) === 0) {
        throw new Error("Recursion limit reached.");
      }
      const stream = await output.stream(finalChunk, patchConfig(config, {
        callbacks: runManager == null ? void 0 : runManager.getChild(),
        recursionLimit: ((_a = config == null ? void 0 : config.recursionLimit) != null ? _a : DEFAULT_RECURSION_LIMIT) - 1
      }));
      for await (const chunk of stream) {
        yield chunk;
      }
    } else {
      yield output;
    }
  }
  transform(generator, options) {
    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
  }
  async stream(input, options) {
    async function* generator() {
      yield input;
    }
    const wrappedGenerator = new AsyncGeneratorWithSetup(this.transform(generator(), options));
    await wrappedGenerator.setup;
    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
  }
};
var RunnableWithFallbacks = class extends Runnable {
  static lc_name() {
    return "RunnableWithFallbacks";
  }
  constructor(fields) {
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "runnable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "fallbacks", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.runnable = fields.runnable;
    this.fallbacks = fields.fallbacks;
  }
  *runnables() {
    yield this.runnable;
    for (const fallback of this.fallbacks) {
      yield fallback;
    }
  }
  async invoke(input, options) {
    const callbackManager_ = await CallbackManager.configure(options == null ? void 0 : options.callbacks, void 0, options == null ? void 0 : options.tags, void 0, options == null ? void 0 : options.metadata);
    const runManager = await (callbackManager_ == null ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict2(input, "input"), void 0, void 0, void 0, void 0, options == null ? void 0 : options.runName));
    let firstError;
    for (const runnable of this.runnables()) {
      try {
        const output = await runnable.invoke(input, patchConfig(options, { callbacks: runManager == null ? void 0 : runManager.getChild() }));
        await (runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict2(output, "output")));
        return output;
      } catch (e) {
        if (firstError === void 0) {
          firstError = e;
        }
      }
    }
    if (firstError === void 0) {
      throw new Error("No error stored at end of fallback.");
    }
    await (runManager == null ? void 0 : runManager.handleChainError(firstError));
    throw firstError;
  }
  async batch(inputs, options, batchOptions) {
    if (batchOptions == null ? void 0 : batchOptions.returnExceptions) {
      throw new Error("Not implemented.");
    }
    const configList = this._getOptionsList(options != null ? options : {}, inputs.length);
    const callbackManagers = await Promise.all(configList.map((config) => CallbackManager.configure(config == null ? void 0 : config.callbacks, void 0, config == null ? void 0 : config.tags, void 0, config == null ? void 0 : config.metadata)));
    const runManagers = await Promise.all(callbackManagers.map((callbackManager, i) => callbackManager == null ? void 0 : callbackManager.handleChainStart(this.toJSON(), _coerceToDict2(inputs[i], "input"), void 0, void 0, void 0, void 0, configList[i].runName)));
    let firstError;
    for (const runnable of this.runnables()) {
      try {
        const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => patchConfig(configList[j], {
          callbacks: runManager == null ? void 0 : runManager.getChild()
        })), batchOptions);
        await Promise.all(runManagers.map((runManager, i) => runManager == null ? void 0 : runManager.handleChainEnd(_coerceToDict2(outputs[i], "output"))));
        return outputs;
      } catch (e) {
        if (firstError === void 0) {
          firstError = e;
        }
      }
    }
    if (!firstError) {
      throw new Error("No error stored at end of fallbacks.");
    }
    await Promise.all(runManagers.map((runManager) => runManager == null ? void 0 : runManager.handleChainError(firstError)));
    throw firstError;
  }
};
function _coerceToRunnable(coerceable) {
  if (typeof coerceable === "function") {
    return new RunnableLambda({ func: coerceable });
  } else if (Runnable.isRunnable(coerceable)) {
    return coerceable;
  } else if (!Array.isArray(coerceable) && typeof coerceable === "object") {
    const runnables = {};
    for (const [key, value] of Object.entries(coerceable)) {
      runnables[key] = _coerceToRunnable(value);
    }
    return new RunnableMap({
      steps: runnables
    });
  } else {
    throw new Error(`Expected a Runnable, function or object.
Instead got an unsupported type.`);
  }
}
var RunnableAssign = class extends Runnable {
  static lc_name() {
    return "RunnableAssign";
  }
  constructor(fields) {
    if (fields instanceof RunnableMap) {
      fields = { mapper: fields };
    }
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "mapper", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.mapper = fields.mapper;
  }
  async invoke(input, options) {
    const mapperResult = await this.mapper.invoke(input, options);
    return {
      ...input,
      ...mapperResult
    };
  }
  async *_transform(generator, runManager, options) {
    const mapperKeys = this.mapper.getStepsKeys();
    const [forPassthrough, forMapper] = atee(generator);
    const mapperOutput = this.mapper.transform(forMapper, patchConfig(options, { callbacks: runManager == null ? void 0 : runManager.getChild() }));
    const firstMapperChunkPromise = mapperOutput.next();
    for await (const chunk of forPassthrough) {
      if (typeof chunk !== "object" || Array.isArray(chunk)) {
        throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof chunk}`);
      }
      const filtered = Object.fromEntries(Object.entries(chunk).filter(([key]) => !mapperKeys.includes(key)));
      if (Object.keys(filtered).length > 0) {
        yield filtered;
      }
    }
    yield (await firstMapperChunkPromise).value;
    for await (const chunk of mapperOutput) {
      yield chunk;
    }
  }
  transform(generator, options) {
    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
  }
  async stream(input, options) {
    async function* generator() {
      yield input;
    }
    const wrappedGenerator = new AsyncGeneratorWithSetup(this.transform(generator(), options));
    await wrappedGenerator.setup;
    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
  }
};
var RunnablePick = class extends Runnable {
  static lc_name() {
    return "RunnablePick";
  }
  constructor(fields) {
    if (typeof fields === "string" || Array.isArray(fields)) {
      fields = { keys: fields };
    }
    super(fields);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain_core", "runnables"]
    });
    Object.defineProperty(this, "lc_serializable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: true
    });
    Object.defineProperty(this, "keys", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.keys = fields.keys;
  }
  async _pick(input) {
    if (typeof this.keys === "string") {
      return input[this.keys];
    } else {
      const picked = this.keys.map((key) => [key, input[key]]).filter((v) => v[1] !== void 0);
      return picked.length === 0 ? void 0 : Object.fromEntries(picked);
    }
  }
  async invoke(input, options) {
    return this._callWithConfig(this._pick.bind(this), input, options);
  }
  async *_transform(generator) {
    for await (const chunk of generator) {
      const picked = await this._pick(chunk);
      if (picked !== void 0) {
        yield picked;
      }
    }
  }
  transform(generator, options) {
    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);
  }
  async stream(input, options) {
    async function* generator() {
      yield input;
    }
    const wrappedGenerator = new AsyncGeneratorWithSetup(this.transform(generator(), options));
    await wrappedGenerator.setup;
    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);
  }
};

// ../../node_modules/@langchain/core/dist/language_models/base.js
var getModelNameForTiktoken = (modelName) => {
  if (modelName.startsWith("gpt-3.5-turbo-16k")) {
    return "gpt-3.5-turbo-16k";
  }
  if (modelName.startsWith("gpt-3.5-turbo-")) {
    return "gpt-3.5-turbo";
  }
  if (modelName.startsWith("gpt-4-32k")) {
    return "gpt-4-32k";
  }
  if (modelName.startsWith("gpt-4-")) {
    return "gpt-4";
  }
  return modelName;
};
var getVerbosity = () => false;
var BaseLangChain = class extends Runnable {
  get lc_attributes() {
    return {
      callbacks: void 0,
      verbose: void 0
    };
  }
  constructor(params) {
    var _a, _b, _c;
    super(params);
    Object.defineProperty(this, "verbose", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "callbacks", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "tags", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "metadata", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.verbose = (_a = params.verbose) != null ? _a : getVerbosity();
    this.callbacks = params.callbacks;
    this.tags = (_b = params.tags) != null ? _b : [];
    this.metadata = (_c = params.metadata) != null ? _c : {};
  }
};
var BaseLanguageModel = class extends BaseLangChain {
  /**
   * Keys that the language model accepts as call options.
   */
  get callKeys() {
    return ["stop", "timeout", "signal", "tags", "metadata", "callbacks"];
  }
  constructor({ callbacks, callbackManager, ...params }) {
    super({
      callbacks: callbacks != null ? callbacks : callbackManager,
      ...params
    });
    Object.defineProperty(this, "caller", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "cache", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_encoding", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    if (typeof params.cache === "object") {
      this.cache = params.cache;
    } else if (params.cache) {
      this.cache = InMemoryCache.global();
    } else {
      this.cache = void 0;
    }
    this.caller = new AsyncCaller2(params != null ? params : {});
  }
  async getNumTokens(content) {
    if (typeof content !== "string") {
      return 0;
    }
    let numTokens = Math.ceil(content.length / 4);
    if (!this._encoding) {
      try {
        this._encoding = await encodingForModel("modelName" in this ? getModelNameForTiktoken(this.modelName) : "gpt2");
      } catch (error) {
        console.warn("Failed to calculate number of tokens, falling back to approximate count", error);
      }
    }
    if (this._encoding) {
      try {
        numTokens = this._encoding.encode(content).length;
      } catch (error) {
        console.warn("Failed to calculate number of tokens, falling back to approximate count", error);
      }
    }
    return numTokens;
  }
  static _convertInputToPromptValue(input) {
    if (typeof input === "string") {
      return new StringPromptValue(input);
    } else if (Array.isArray(input)) {
      return new ChatPromptValue(input.map(coerceMessageLikeToMessage));
    } else {
      return input;
    }
  }
  /**
   * Get the identifying parameters of the LLM.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  _identifyingParams() {
    return {};
  }
  /**
   * Create a unique cache key for a specific call to a specific language model.
   * @param callOptions Call options for the model
   * @returns A unique cache key.
   */
  _getSerializedCacheKeyParametersForCall(callOptions) {
    const params = {
      ...this._identifyingParams(),
      ...callOptions,
      _type: this._llmType(),
      _model: this._modelType()
    };
    const filteredEntries = Object.entries(params).filter(([_, value]) => value !== void 0);
    const serializedEntries = filteredEntries.map(([key, value]) => `${key}:${JSON.stringify(value)}`).sort().join(",");
    return serializedEntries;
  }
  /**
   * @deprecated
   * Return a json-like object representing this LLM.
   */
  serialize() {
    return {
      ...this._identifyingParams(),
      _type: this._llmType(),
      _model: this._modelType()
    };
  }
  /**
   * @deprecated
   * Load an LLM from a json-like object describing it.
   */
  static async deserialize(_data) {
    throw new Error("Use .toJSON() instead");
  }
};

// ../../node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/dereference.js
var initialBaseURI = (
  // @ts-ignore
  typeof self !== "undefined" && self.location && self.location.origin !== "null" ? (
    //@ts-ignore
    /* @__PURE__ */ new URL(self.location.origin + self.location.pathname + location.search)
  ) : /* @__PURE__ */ new URL("https://github.com/cfworker")
);

// ../../node_modules/@langchain/core/dist/utils/@cfworker/json-schema/src/format.js
var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
var URL_ = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu;
var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
var FASTDATE = /^\d\d\d\d-[0-1]\d-[0-3]\d$/;
var FASTTIME = /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i;
var FASTDATETIME = /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i;
var FASTURIREFERENCE = /^(?:(?:[a-z][a-z0-9+-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i;
var EMAIL = (input) => {
  if (input[0] === '"')
    return false;
  const [name, host, ...rest] = input.split("@");
  if (!name || !host || rest.length !== 0 || name.length > 64 || host.length > 253)
    return false;
  if (name[0] === "." || name.endsWith(".") || name.includes(".."))
    return false;
  if (!/^[a-z0-9.-]+$/i.test(host) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(name))
    return false;
  return host.split(".").every((part) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(part));
};
var IPV4 = /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/;
var IPV6 = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i;
var DURATION = (input) => input.length > 1 && input.length < 80 && (/^P\d+([.,]\d+)?W$/.test(input) || /^P[\dYMDTHS]*(\d[.,]\d+)?[YMDHS]$/.test(input) && /^P([.,\d]+Y)?([.,\d]+M)?([.,\d]+D)?(T([.,\d]+H)?([.,\d]+M)?([.,\d]+S)?)?$/.test(input));
function bind(r) {
  return r.test.bind(r);
}
var fullFormat = {
  date,
  time: /* @__PURE__ */ time.bind(void 0, false),
  "date-time": date_time,
  duration: DURATION,
  uri,
  "uri-reference": /* @__PURE__ */ bind(URIREF),
  "uri-template": /* @__PURE__ */ bind(URITEMPLATE),
  url: /* @__PURE__ */ bind(URL_),
  email: EMAIL,
  hostname: /* @__PURE__ */ bind(HOSTNAME),
  ipv4: /* @__PURE__ */ bind(IPV4),
  ipv6: /* @__PURE__ */ bind(IPV6),
  regex,
  uuid: /* @__PURE__ */ bind(UUID),
  "json-pointer": /* @__PURE__ */ bind(JSON_POINTER),
  "json-pointer-uri-fragment": /* @__PURE__ */ bind(JSON_POINTER_URI_FRAGMENT),
  "relative-json-pointer": /* @__PURE__ */ bind(RELATIVE_JSON_POINTER)
};
var fastFormat = {
  ...fullFormat,
  date: /* @__PURE__ */ bind(FASTDATE),
  time: /* @__PURE__ */ bind(FASTTIME),
  "date-time": /* @__PURE__ */ bind(FASTDATETIME),
  "uri-reference": /* @__PURE__ */ bind(FASTURIREFERENCE)
};
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function date(str) {
  const matches = str.match(DATE);
  if (!matches)
    return false;
  const year = +matches[1];
  const month = +matches[2];
  const day = +matches[3];
  return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
}
function time(full, str) {
  const matches = str.match(TIME);
  if (!matches)
    return false;
  const hour = +matches[1];
  const minute = +matches[2];
  const second = +matches[3];
  const timeZone = !!matches[5];
  return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
}
var DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str) {
  const dateTime = str.split(DATE_TIME_SEPARATOR);
  return dateTime.length == 2 && date(dateTime[0]) && time(true, dateTime[1]);
}
var NOT_URI_FRAGMENT = /\/|:/;
var URI_PATTERN = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
function uri(str) {
  return NOT_URI_FRAGMENT.test(str) && URI_PATTERN.test(str);
}
var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
  if (Z_ANCHOR.test(str))
    return false;
  try {
    new RegExp(str);
    return true;
  } catch (e) {
    return false;
  }
}

// ../../node_modules/@langchain/core/dist/language_models/llms.js
var BaseLLM = class _BaseLLM extends BaseLanguageModel {
  constructor({ concurrency, ...rest }) {
    super(concurrency ? { maxConcurrency: concurrency, ...rest } : rest);
    Object.defineProperty(this, "lc_namespace", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ["langchain", "llms", this._llmType()]
    });
  }
  /**
   * This method takes an input and options, and returns a string. It
   * converts the input to a prompt value and generates a result based on
   * the prompt.
   * @param input Input for the LLM.
   * @param options Options for the LLM call.
   * @returns A string result based on the prompt.
   */
  async invoke(input, options) {
    const promptValue = _BaseLLM._convertInputToPromptValue(input);
    const result = await this.generatePrompt([promptValue], options, options == null ? void 0 : options.callbacks);
    return result.generations[0][0].text;
  }
  // eslint-disable-next-line require-yield
  async *_streamResponseChunks(_input, _options, _runManager) {
    throw new Error("Not implemented.");
  }
  _separateRunnableConfigFromCallOptions(options) {
    const [runnableConfig, callOptions] = super._separateRunnableConfigFromCallOptions(options);
    if ((callOptions == null ? void 0 : callOptions.timeout) && !callOptions.signal) {
      callOptions.signal = AbortSignal.timeout(callOptions.timeout);
    }
    return [runnableConfig, callOptions];
  }
  async *_streamIterator(input, options) {
    if (this._streamResponseChunks === _BaseLLM.prototype._streamResponseChunks) {
      yield this.invoke(input, options);
    } else {
      const prompt = _BaseLLM._convertInputToPromptValue(input);
      const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptions(options);
      const callbackManager_ = await CallbackManager.configure(runnableConfig.callbacks, this.callbacks, runnableConfig.tags, this.tags, runnableConfig.metadata, this.metadata, { verbose: this.verbose });
      const extra = {
        options: callOptions,
        invocation_params: this == null ? void 0 : this.invocationParams(callOptions),
        batch_size: 1
      };
      const runManagers = await (callbackManager_ == null ? void 0 : callbackManager_.handleLLMStart(this.toJSON(), [prompt.toString()], void 0, void 0, extra, void 0, void 0, runnableConfig.runName));
      let generation = new GenerationChunk({
        text: ""
      });
      try {
        for await (const chunk of this._streamResponseChunks(input.toString(), callOptions, runManagers == null ? void 0 : runManagers[0])) {
          if (!generation) {
            generation = chunk;
          } else {
            generation = generation.concat(chunk);
          }
          if (typeof chunk.text === "string") {
            yield chunk.text;
          }
        }
      } catch (err) {
        await Promise.all((runManagers != null ? runManagers : []).map((runManager) => runManager == null ? void 0 : runManager.handleLLMError(err)));
        throw err;
      }
      await Promise.all((runManagers != null ? runManagers : []).map((runManager) => runManager == null ? void 0 : runManager.handleLLMEnd({
        generations: [[generation]]
      })));
    }
  }
  /**
   * This method takes prompt values, options, and callbacks, and generates
   * a result based on the prompts.
   * @param promptValues Prompt values for the LLM.
   * @param options Options for the LLM call.
   * @param callbacks Callbacks for the LLM call.
   * @returns An LLMResult based on the prompts.
   */
  async generatePrompt(promptValues, options, callbacks) {
    const prompts = promptValues.map((promptValue) => promptValue.toString());
    return this.generate(prompts, options, callbacks);
  }
  /**
   * Get the parameters used to invoke the model
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  invocationParams(_options) {
    return {};
  }
  _flattenLLMResult(llmResult) {
    const llmResults = [];
    for (let i = 0; i < llmResult.generations.length; i += 1) {
      const genList = llmResult.generations[i];
      if (i === 0) {
        llmResults.push({
          generations: [genList],
          llmOutput: llmResult.llmOutput
        });
      } else {
        const llmOutput = llmResult.llmOutput ? { ...llmResult.llmOutput, tokenUsage: {} } : void 0;
        llmResults.push({
          generations: [genList],
          llmOutput
        });
      }
    }
    return llmResults;
  }
  /** @ignore */
  async _generateUncached(prompts, parsedOptions, handledOptions) {
    const callbackManager_ = await CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, handledOptions.metadata, this.metadata, { verbose: this.verbose });
    const extra = {
      options: parsedOptions,
      invocation_params: this == null ? void 0 : this.invocationParams(parsedOptions),
      batch_size: prompts.length
    };
    const runManagers = await (callbackManager_ == null ? void 0 : callbackManager_.handleLLMStart(this.toJSON(), prompts, void 0, void 0, extra, void 0, void 0, handledOptions == null ? void 0 : handledOptions.runName));
    let output;
    try {
      output = await this._generate(prompts, parsedOptions, runManagers == null ? void 0 : runManagers[0]);
    } catch (err) {
      await Promise.all((runManagers != null ? runManagers : []).map((runManager) => runManager == null ? void 0 : runManager.handleLLMError(err)));
      throw err;
    }
    const flattenedOutputs = this._flattenLLMResult(output);
    await Promise.all((runManagers != null ? runManagers : []).map((runManager, i) => runManager == null ? void 0 : runManager.handleLLMEnd(flattenedOutputs[i])));
    const runIds = (runManagers == null ? void 0 : runManagers.map((manager) => manager.runId)) || void 0;
    Object.defineProperty(output, RUN_KEY, {
      value: runIds ? { runIds } : void 0,
      configurable: true
    });
    return output;
  }
  async _generateCached({ prompts, cache: cache2, llmStringKey, parsedOptions, handledOptions }) {
    const callbackManager_ = await CallbackManager.configure(handledOptions.callbacks, this.callbacks, handledOptions.tags, this.tags, handledOptions.metadata, this.metadata, { verbose: this.verbose });
    const extra = {
      options: parsedOptions,
      invocation_params: this == null ? void 0 : this.invocationParams(parsedOptions),
      batch_size: prompts.length,
      cached: true
    };
    const runManagers = await (callbackManager_ == null ? void 0 : callbackManager_.handleLLMStart(this.toJSON(), prompts, void 0, void 0, extra, void 0, void 0, handledOptions == null ? void 0 : handledOptions.runName));
    const missingPromptIndices = [];
    const results = await Promise.allSettled(prompts.map(async (prompt, index) => {
      const result = await cache2.lookup(prompt, llmStringKey);
      if (result == null) {
        missingPromptIndices.push(index);
      }
      return result;
    }));
    const cachedResults = results.map((result, index) => ({ result, runManager: runManagers == null ? void 0 : runManagers[index] })).filter(({ result }) => result.status === "fulfilled" && result.value != null || result.status === "rejected");
    const generations = [];
    await Promise.all(cachedResults.map(async ({ result: promiseResult, runManager }, i) => {
      if (promiseResult.status === "fulfilled") {
        const result = promiseResult.value;
        generations[i] = result;
        if (result.length) {
          await (runManager == null ? void 0 : runManager.handleLLMNewToken(result[0].text));
        }
        return runManager == null ? void 0 : runManager.handleLLMEnd({
          generations: [result]
        });
      } else {
        await (runManager == null ? void 0 : runManager.handleLLMError(promiseResult.reason));
        return Promise.reject(promiseResult.reason);
      }
    }));
    const output = {
      generations,
      missingPromptIndices
    };
    Object.defineProperty(output, RUN_KEY, {
      value: runManagers ? { runIds: runManagers == null ? void 0 : runManagers.map((manager) => manager.runId) } : void 0,
      configurable: true
    });
    return output;
  }
  /**
   * Run the LLM on the given prompts and input, handling caching.
   */
  async generate(prompts, options, callbacks) {
    var _a, _b;
    if (!Array.isArray(prompts)) {
      throw new Error("Argument 'prompts' is expected to be a string[]");
    }
    let parsedOptions;
    if (Array.isArray(options)) {
      parsedOptions = { stop: options };
    } else {
      parsedOptions = options;
    }
    const [runnableConfig, callOptions] = this._separateRunnableConfigFromCallOptions(parsedOptions);
    runnableConfig.callbacks = (_a = runnableConfig.callbacks) != null ? _a : callbacks;
    if (!this.cache) {
      return this._generateUncached(prompts, callOptions, runnableConfig);
    }
    const { cache: cache2 } = this;
    const llmStringKey = this._getSerializedCacheKeyParametersForCall(callOptions);
    const { generations, missingPromptIndices } = await this._generateCached({
      prompts,
      cache: cache2,
      llmStringKey,
      parsedOptions: callOptions,
      handledOptions: runnableConfig
    });
    let llmOutput = {};
    if (missingPromptIndices.length > 0) {
      const results = await this._generateUncached(missingPromptIndices.map((i) => prompts[i]), callOptions, runnableConfig);
      await Promise.all(results.generations.map(async (generation, index) => {
        const promptIndex = missingPromptIndices[index];
        generations[promptIndex] = generation;
        return cache2.update(prompts[promptIndex], llmStringKey, generation);
      }));
      llmOutput = (_b = results.llmOutput) != null ? _b : {};
    }
    return { generations, llmOutput };
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
   * Convenience wrapper for {@link generate} that takes in a single string prompt and returns a single string output.
   */
  async call(prompt, options, callbacks) {
    const { generations } = await this.generate([prompt], options, callbacks);
    return generations[0][0].text;
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
   *
   * This method is similar to `call`, but it's used for making predictions
   * based on the input text.
   * @param text Input text for the prediction.
   * @param options Options for the LLM call.
   * @param callbacks Callbacks for the LLM call.
   * @returns A prediction based on the input text.
   */
  async predict(text2, options, callbacks) {
    return this.call(text2, options, callbacks);
  }
  /**
   * @deprecated Use .invoke() instead. Will be removed in 0.2.0.
   *
   * This method takes a list of messages, options, and callbacks, and
   * returns a predicted message.
   * @param messages A list of messages for the prediction.
   * @param options Options for the LLM call.
   * @param callbacks Callbacks for the LLM call.
   * @returns A predicted message based on the list of messages.
   */
  async predictMessages(messages, options, callbacks) {
    const text2 = getBufferString(messages);
    const prediction = await this.call(text2, options, callbacks);
    return new AIMessage(prediction);
  }
  /**
   * Get the identifying parameters of the LLM.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  _identifyingParams() {
    return {};
  }
  /**
   * @deprecated
   * Return a json-like object representing this LLM.
   */
  serialize() {
    return {
      ...this._identifyingParams(),
      _type: this._llmType(),
      _model: this._modelType()
    };
  }
  _modelType() {
    return "base_llm";
  }
};
var LLM = class extends BaseLLM {
  async _generate(prompts, options, runManager) {
    const generations = await Promise.all(prompts.map((prompt, promptIndex) => this._call(prompt, { ...options, promptIndex }, runManager).then((text2) => [{ text: text2 }])));
    return { generations };
  }
};

// ../../node_modules/langchain/dist/llms/fake.js
var FakeListLLM = class extends LLM {
  static lc_name() {
    return "FakeListLLM";
  }
  constructor({ responses, sleep }) {
    super({});
    Object.defineProperty(this, "responses", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "i", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
    Object.defineProperty(this, "sleep", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.responses = responses;
    this.sleep = sleep;
  }
  _llmType() {
    return "fake-list";
  }
  async _call(_prompt, _options, _runManager) {
    const response = this._currentResponse();
    this._incrementResponse();
    await this._sleepIfRequested();
    return response;
  }
  _currentResponse() {
    return this.responses[this.i];
  }
  _incrementResponse() {
    if (this.i < this.responses.length - 1) {
      this.i += 1;
    } else {
      this.i = 0;
    }
  }
  async *_streamResponseChunks(_input, _options, _runManager) {
    const response = this._currentResponse();
    this._incrementResponse();
    for await (const text2 of response) {
      await this._sleepIfRequested();
      yield this._createResponseChunk(text2);
    }
  }
  async _sleepIfRequested() {
    if (this.sleep !== void 0) {
      await this._sleep();
    }
  }
  async _sleep() {
    return new Promise((resolve) => {
      setTimeout(() => resolve(), this.sleep);
    });
  }
  _createResponseChunk(text2) {
    return new GenerationChunk({
      text: text2,
      generationInfo: {}
    });
  }
};

// src/llm.ts
var store = {
  settings: DEFAULT_SETTINGS
};
function updateLLM(settings) {
  store.settings = settings;
  store.tracer = settings.LANGCHAIN_TRACING_V2 ? new LangChainTracer({
    projectName: settings.LANGCHAIN_PROJECT || DEFAULT_SETTINGS.LANGCHAIN_PROJECT,
    client: new Client({
      apiUrl: settings.LANGCHAIN_ENDPOINT || DEFAULT_SETTINGS.LANGCHAIN_ENDPOINT,
      apiKey: settings.LANGCHAIN_API_KEY || DEFAULT_SETTINGS.LANGCHAIN_API_KEY
    })
  }) : void 0;
}
var llm = new FakeListLLM({
  responses: [
    "Because Oct 31 equals Dec 25",
    "You 'console' them!"
  ],
  sleep: 100
});
async function* chat(prompt) {
  const stream = await llm.stream(
    [
      ["human", prompt]
    ],
    store.tracer ? { callbacks: [store.tracer] } : {}
  );
  for await (const chunk of stream) {
    yield chunk;
  }
}

// ../../node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}

// ../../node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// ../../node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class _ResizeObserverSingleton {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    var _a;
    return (_a = this._observer) != null ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        _ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) == null ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// ../../node_modules/svelte/src/runtime/internal/dom.js
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function element(name) {
  return document.createElement(name);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}

// ../../node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// ../../node_modules/svelte/src/runtime/internal/Component.js
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a;
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a = this.$$c) == null ? void 0 : _a.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  var _a;
  const type = (_a = props_definition[prop]) == null ? void 0 : _a.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}

// ../../node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// ../../node_modules/svelte/src/runtime/store/index.js
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set, update) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update, subscribe: subscribe2 };
}

// src/store.ts
var plugin = writable();

// ../../node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// src/main.ts
var ObsidianChatGPTPlugin = class extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new SettingTab(this.app, this));
    this.addCommand({
      id: "summary",
      name: "Summary Current Note",
      async editorCallback(editor, _view) {
        editor.replaceSelection("> ");
        const chunks = chat(editor.getValue());
        for await (const content of chunks) {
          editor.replaceSelection(String(content));
        }
      }
      /*
      checkCallback: (checking) => {
        const markdownView = this.app.workspace.getActiveViewOfType(
          MarkdownView,
        );
        if (markdownView) {
          if (!checking) {
            new ChatModal(this.app, this, markdownView.contentEl.textContent)
              .open();
          }
          return true;
        }
      },
      */
    });
  }
  onunload() {
  }
  updateStatus() {
    updateLLM(this.settings);
    this.statusBarItemEl.setText(this.settings.OPENAI_API_KEY ? "on" : "off");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.statusBarItemEl = this.addStatusBarItem();
    this.updateStatus();
  }
  async saveSettings() {
    this.updateStatus();
    await this.saveData(this.settings);
  }
};
/*! Bundled license information:

@langchain/core/dist/utils/js-sha1/hash.js:
  (*
   * [js-sha1]{@link https://github.com/emn178/js-sha1}
   *
   * @version 0.6.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2017
   * @license MIT
   *)

@langchain/core/dist/utils/fast-json-patch/src/helpers.js:
  (*!
   * https://github.com/Starcounter-Jack/JSON-Patch
   * (c) 2017-2022 Joachim Wester
   * MIT licensed
   *)

@langchain/core/dist/utils/fast-json-patch/src/duplex.js:
  (*!
   * https://github.com/Starcounter-Jack/JSON-Patch
   * (c) 2013-2021 Joachim Wester
   * MIT license
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2RlY2FtZWxpemUvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhbWVsY2FzZS9pbmRleC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYW5zaS1zdHlsZXMvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JldHJ5L2xpYi9yZXRyeV9vcGVyYXRpb24uanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JldHJ5L2xpYi9yZXRyeS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcmV0cnkvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3AtcmV0cnkvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3AtZmluYWxseS9pbmRleC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcC10aW1lb3V0L2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9wLXF1ZXVlL2Rpc3QvbG93ZXItYm91bmQuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3AtcXVldWUvZGlzdC9wcmlvcml0eS1xdWV1ZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvcC1xdWV1ZS9kaXN0L2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCAiLi4vc3JjL21haW4udHMiLCAiLi4vc3JjL3NldHRpbmdzLnRzIiwgIi4uL3NyYy9TZXR0aW5nVGFiLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9lbnYuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9ybmcuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9yZWdleC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3ZhbGlkYXRlLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvc3RyaW5naWZ5LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvbmF0aXZlLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjQuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L2xvYWQvbWFwX2tleXMuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L2xvYWQvc2VyaWFsaXphYmxlLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9jYWxsYmFja3MvYmFzZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9iYXNlLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC90cmFjZXJzL2NvbnNvbGUuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3V0aWxzL2FzeW5jX2NhbGxlci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvbWVzc2FnZXMuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3V0aWxzL2Vudi5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvY2xpZW50LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9pbmRleC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy90cmFjZXJfbGFuZ2NoYWluLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9tZXNzYWdlcy9pbmRleC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9pbml0aWFsaXplLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9jYWxsYmFja3MvcHJvbWlzZXMuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L2NhbGxiYWNrcy9tYW5hZ2VyLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9vdXRwdXRzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9qcy1zaGExL2hhc2guanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L2NhY2hlcy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcHJvbXB0X3ZhbHVlcy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qcy10aWt0b2tlbi9kaXN0L2NodW5rLUhYVzM0NVFOLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy90aWt0b2tlbi5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvcnVubmFibGVzL2Jhc2UuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL2Zhc3QtanNvbi1wYXRjaC9zcmMvY29yZS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdXRpbHMvZmFzdC1qc29uLXBhdGNoL3NyYy9oZWxwZXJzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC91dGlscy9mYXN0LWpzb24tcGF0Y2gvaW5kZXguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL3N0cmVhbS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvdHJhY2Vycy9sb2dfc3RyZWFtLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9zaW5nbGV0b25zL2luZGV4LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9ydW5uYWJsZXMvY29uZmlnLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC90cmFjZXJzL3Jvb3RfbGlzdGVuZXIuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3J1bm5hYmxlcy91dGlscy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQGxhbmdjaGFpbi9jb3JlL2Rpc3QvbGFuZ3VhZ2VfbW9kZWxzL2Jhc2UuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL0BjZndvcmtlci9qc29uLXNjaGVtYS9zcmMvZGVyZWZlcmVuY2UuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BsYW5nY2hhaW4vY29yZS9kaXN0L3V0aWxzL0BjZndvcmtlci9qc29uLXNjaGVtYS9zcmMvZm9ybWF0LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AbGFuZ2NoYWluL2NvcmUvZGlzdC9sYW5ndWFnZV9tb2RlbHMvbGxtcy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFuZ2NoYWluL2Rpc3QvbGxtcy9mYWtlLmpzIiwgIi4uL3NyYy9sbG0udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC91dGlscy5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL2dsb2JhbHMuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvcnVudGltZS9pbnRlcm5hbC9SZXNpemVPYnNlcnZlclNpbmdsZXRvbi5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9ydW50aW1lL2ludGVybmFsL2RvbS5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9zaGFyZWQvYm9vbGVhbl9hdHRyaWJ1dGVzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvQ29tcG9uZW50LmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3NoYXJlZC92ZXJzaW9uLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvc3RvcmUvaW5kZXguanMiLCAiLi4vc3JjL3N0b3JlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL3J1bnRpbWUvaW50ZXJuYWwvZGlzY2xvc2UtdmVyc2lvbi9pbmRleC5qcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyLCBzZXApIHtcblx0aWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcnKTtcblx0fVxuXG5cdHNlcCA9IHR5cGVvZiBzZXAgPT09ICd1bmRlZmluZWQnID8gJ18nIDogc2VwO1xuXG5cdHJldHVybiBzdHJcblx0XHQucmVwbGFjZSgvKFthLXpcXGRdKShbQS1aXSkvZywgJyQxJyArIHNlcCArICckMicpXG5cdFx0LnJlcGxhY2UoLyhbQS1aXSspKFtBLVpdW2EtelxcZF0rKS9nLCAnJDEnICsgc2VwICsgJyQyJylcblx0XHQudG9Mb3dlckNhc2UoKTtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBVUFBFUkNBU0UgPSAvW1xccHtMdX1dL3U7XG5jb25zdCBMT1dFUkNBU0UgPSAvW1xccHtMbH1dL3U7XG5jb25zdCBMRUFESU5HX0NBUElUQUwgPSAvXltcXHB7THV9XSg/IVtcXHB7THV9XSkvZ3U7XG5jb25zdCBJREVOVElGSUVSID0gLyhbXFxwe0FscGhhfVxccHtOfV9dfCQpL3U7XG5jb25zdCBTRVBBUkFUT1JTID0gL1tfLlxcLSBdKy87XG5cbmNvbnN0IExFQURJTkdfU0VQQVJBVE9SUyA9IG5ldyBSZWdFeHAoJ14nICsgU0VQQVJBVE9SUy5zb3VyY2UpO1xuY29uc3QgU0VQQVJBVE9SU19BTkRfSURFTlRJRklFUiA9IG5ldyBSZWdFeHAoU0VQQVJBVE9SUy5zb3VyY2UgKyBJREVOVElGSUVSLnNvdXJjZSwgJ2d1Jyk7XG5jb25zdCBOVU1CRVJTX0FORF9JREVOVElGSUVSID0gbmV3IFJlZ0V4cCgnXFxcXGQrJyArIElERU5USUZJRVIuc291cmNlLCAnZ3UnKTtcblxuY29uc3QgcHJlc2VydmVDYW1lbENhc2UgPSAoc3RyaW5nLCB0b0xvd2VyQ2FzZSwgdG9VcHBlckNhc2UpID0+IHtcblx0bGV0IGlzTGFzdENoYXJMb3dlciA9IGZhbHNlO1xuXHRsZXQgaXNMYXN0Q2hhclVwcGVyID0gZmFsc2U7XG5cdGxldCBpc0xhc3RMYXN0Q2hhclVwcGVyID0gZmFsc2U7XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcblx0XHRjb25zdCBjaGFyYWN0ZXIgPSBzdHJpbmdbaV07XG5cblx0XHRpZiAoaXNMYXN0Q2hhckxvd2VyICYmIFVQUEVSQ0FTRS50ZXN0KGNoYXJhY3RlcikpIHtcblx0XHRcdHN0cmluZyA9IHN0cmluZy5zbGljZSgwLCBpKSArICctJyArIHN0cmluZy5zbGljZShpKTtcblx0XHRcdGlzTGFzdENoYXJMb3dlciA9IGZhbHNlO1xuXHRcdFx0aXNMYXN0TGFzdENoYXJVcHBlciA9IGlzTGFzdENoYXJVcHBlcjtcblx0XHRcdGlzTGFzdENoYXJVcHBlciA9IHRydWU7XG5cdFx0XHRpKys7XG5cdFx0fSBlbHNlIGlmIChpc0xhc3RDaGFyVXBwZXIgJiYgaXNMYXN0TGFzdENoYXJVcHBlciAmJiBMT1dFUkNBU0UudGVzdChjaGFyYWN0ZXIpKSB7XG5cdFx0XHRzdHJpbmcgPSBzdHJpbmcuc2xpY2UoMCwgaSAtIDEpICsgJy0nICsgc3RyaW5nLnNsaWNlKGkgLSAxKTtcblx0XHRcdGlzTGFzdExhc3RDaGFyVXBwZXIgPSBpc0xhc3RDaGFyVXBwZXI7XG5cdFx0XHRpc0xhc3RDaGFyVXBwZXIgPSBmYWxzZTtcblx0XHRcdGlzTGFzdENoYXJMb3dlciA9IHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlzTGFzdENoYXJMb3dlciA9IHRvTG93ZXJDYXNlKGNoYXJhY3RlcikgPT09IGNoYXJhY3RlciAmJiB0b1VwcGVyQ2FzZShjaGFyYWN0ZXIpICE9PSBjaGFyYWN0ZXI7XG5cdFx0XHRpc0xhc3RMYXN0Q2hhclVwcGVyID0gaXNMYXN0Q2hhclVwcGVyO1xuXHRcdFx0aXNMYXN0Q2hhclVwcGVyID0gdG9VcHBlckNhc2UoY2hhcmFjdGVyKSA9PT0gY2hhcmFjdGVyICYmIHRvTG93ZXJDYXNlKGNoYXJhY3RlcikgIT09IGNoYXJhY3Rlcjtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gc3RyaW5nO1xufTtcblxuY29uc3QgcHJlc2VydmVDb25zZWN1dGl2ZVVwcGVyY2FzZSA9IChpbnB1dCwgdG9Mb3dlckNhc2UpID0+IHtcblx0TEVBRElOR19DQVBJVEFMLmxhc3RJbmRleCA9IDA7XG5cblx0cmV0dXJuIGlucHV0LnJlcGxhY2UoTEVBRElOR19DQVBJVEFMLCBtMSA9PiB0b0xvd2VyQ2FzZShtMSkpO1xufTtcblxuY29uc3QgcG9zdFByb2Nlc3MgPSAoaW5wdXQsIHRvVXBwZXJDYXNlKSA9PiB7XG5cdFNFUEFSQVRPUlNfQU5EX0lERU5USUZJRVIubGFzdEluZGV4ID0gMDtcblx0TlVNQkVSU19BTkRfSURFTlRJRklFUi5sYXN0SW5kZXggPSAwO1xuXG5cdHJldHVybiBpbnB1dC5yZXBsYWNlKFNFUEFSQVRPUlNfQU5EX0lERU5USUZJRVIsIChfLCBpZGVudGlmaWVyKSA9PiB0b1VwcGVyQ2FzZShpZGVudGlmaWVyKSlcblx0XHQucmVwbGFjZShOVU1CRVJTX0FORF9JREVOVElGSUVSLCBtID0+IHRvVXBwZXJDYXNlKG0pKTtcbn07XG5cbmNvbnN0IGNhbWVsQ2FzZSA9IChpbnB1dCwgb3B0aW9ucykgPT4ge1xuXHRpZiAoISh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkoaW5wdXQpKSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHRoZSBpbnB1dCB0byBiZSBgc3RyaW5nIHwgc3RyaW5nW11gJyk7XG5cdH1cblxuXHRvcHRpb25zID0ge1xuXHRcdHBhc2NhbENhc2U6IGZhbHNlLFxuXHRcdHByZXNlcnZlQ29uc2VjdXRpdmVVcHBlcmNhc2U6IGZhbHNlLFxuXHRcdC4uLm9wdGlvbnNcblx0fTtcblxuXHRpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcblx0XHRpbnB1dCA9IGlucHV0Lm1hcCh4ID0+IHgudHJpbSgpKVxuXHRcdFx0LmZpbHRlcih4ID0+IHgubGVuZ3RoKVxuXHRcdFx0LmpvaW4oJy0nKTtcblx0fSBlbHNlIHtcblx0XHRpbnB1dCA9IGlucHV0LnRyaW0oKTtcblx0fVxuXG5cdGlmIChpbnB1dC5sZW5ndGggPT09IDApIHtcblx0XHRyZXR1cm4gJyc7XG5cdH1cblxuXHRjb25zdCB0b0xvd2VyQ2FzZSA9IG9wdGlvbnMubG9jYWxlID09PSBmYWxzZSA/XG5cdFx0c3RyaW5nID0+IHN0cmluZy50b0xvd2VyQ2FzZSgpIDpcblx0XHRzdHJpbmcgPT4gc3RyaW5nLnRvTG9jYWxlTG93ZXJDYXNlKG9wdGlvbnMubG9jYWxlKTtcblx0Y29uc3QgdG9VcHBlckNhc2UgPSBvcHRpb25zLmxvY2FsZSA9PT0gZmFsc2UgP1xuXHRcdHN0cmluZyA9PiBzdHJpbmcudG9VcHBlckNhc2UoKSA6XG5cdFx0c3RyaW5nID0+IHN0cmluZy50b0xvY2FsZVVwcGVyQ2FzZShvcHRpb25zLmxvY2FsZSk7XG5cblx0aWYgKGlucHV0Lmxlbmd0aCA9PT0gMSkge1xuXHRcdHJldHVybiBvcHRpb25zLnBhc2NhbENhc2UgPyB0b1VwcGVyQ2FzZShpbnB1dCkgOiB0b0xvd2VyQ2FzZShpbnB1dCk7XG5cdH1cblxuXHRjb25zdCBoYXNVcHBlckNhc2UgPSBpbnB1dCAhPT0gdG9Mb3dlckNhc2UoaW5wdXQpO1xuXG5cdGlmIChoYXNVcHBlckNhc2UpIHtcblx0XHRpbnB1dCA9IHByZXNlcnZlQ2FtZWxDYXNlKGlucHV0LCB0b0xvd2VyQ2FzZSwgdG9VcHBlckNhc2UpO1xuXHR9XG5cblx0aW5wdXQgPSBpbnB1dC5yZXBsYWNlKExFQURJTkdfU0VQQVJBVE9SUywgJycpO1xuXG5cdGlmIChvcHRpb25zLnByZXNlcnZlQ29uc2VjdXRpdmVVcHBlcmNhc2UpIHtcblx0XHRpbnB1dCA9IHByZXNlcnZlQ29uc2VjdXRpdmVVcHBlcmNhc2UoaW5wdXQsIHRvTG93ZXJDYXNlKTtcblx0fSBlbHNlIHtcblx0XHRpbnB1dCA9IHRvTG93ZXJDYXNlKGlucHV0KTtcblx0fVxuXG5cdGlmIChvcHRpb25zLnBhc2NhbENhc2UpIHtcblx0XHRpbnB1dCA9IHRvVXBwZXJDYXNlKGlucHV0LmNoYXJBdCgwKSkgKyBpbnB1dC5zbGljZSgxKTtcblx0fVxuXG5cdHJldHVybiBwb3N0UHJvY2VzcyhpbnB1dCwgdG9VcHBlckNhc2UpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbENhc2U7XG4vLyBUT0RPOiBSZW1vdmUgdGhpcyBmb3IgdGhlIG5leHQgbWFqb3IgcmVsZWFzZVxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGNhbWVsQ2FzZTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFOU0lfQkFDS0dST1VORF9PRkZTRVQgPSAxMDtcblxuY29uc3Qgd3JhcEFuc2kyNTYgPSAob2Zmc2V0ID0gMCkgPT4gY29kZSA9PiBgXFx1MDAxQlskezM4ICsgb2Zmc2V0fTs1OyR7Y29kZX1tYDtcblxuY29uc3Qgd3JhcEFuc2kxNm0gPSAob2Zmc2V0ID0gMCkgPT4gKHJlZCwgZ3JlZW4sIGJsdWUpID0+IGBcXHUwMDFCWyR7MzggKyBvZmZzZXR9OzI7JHtyZWR9OyR7Z3JlZW59OyR7Ymx1ZX1tYDtcblxuZnVuY3Rpb24gYXNzZW1ibGVTdHlsZXMoKSB7XG5cdGNvbnN0IGNvZGVzID0gbmV3IE1hcCgpO1xuXHRjb25zdCBzdHlsZXMgPSB7XG5cdFx0bW9kaWZpZXI6IHtcblx0XHRcdHJlc2V0OiBbMCwgMF0sXG5cdFx0XHQvLyAyMSBpc24ndCB3aWRlbHkgc3VwcG9ydGVkIGFuZCAyMiBkb2VzIHRoZSBzYW1lIHRoaW5nXG5cdFx0XHRib2xkOiBbMSwgMjJdLFxuXHRcdFx0ZGltOiBbMiwgMjJdLFxuXHRcdFx0aXRhbGljOiBbMywgMjNdLFxuXHRcdFx0dW5kZXJsaW5lOiBbNCwgMjRdLFxuXHRcdFx0b3ZlcmxpbmU6IFs1MywgNTVdLFxuXHRcdFx0aW52ZXJzZTogWzcsIDI3XSxcblx0XHRcdGhpZGRlbjogWzgsIDI4XSxcblx0XHRcdHN0cmlrZXRocm91Z2g6IFs5LCAyOV1cblx0XHR9LFxuXHRcdGNvbG9yOiB7XG5cdFx0XHRibGFjazogWzMwLCAzOV0sXG5cdFx0XHRyZWQ6IFszMSwgMzldLFxuXHRcdFx0Z3JlZW46IFszMiwgMzldLFxuXHRcdFx0eWVsbG93OiBbMzMsIDM5XSxcblx0XHRcdGJsdWU6IFszNCwgMzldLFxuXHRcdFx0bWFnZW50YTogWzM1LCAzOV0sXG5cdFx0XHRjeWFuOiBbMzYsIDM5XSxcblx0XHRcdHdoaXRlOiBbMzcsIDM5XSxcblxuXHRcdFx0Ly8gQnJpZ2h0IGNvbG9yXG5cdFx0XHRibGFja0JyaWdodDogWzkwLCAzOV0sXG5cdFx0XHRyZWRCcmlnaHQ6IFs5MSwgMzldLFxuXHRcdFx0Z3JlZW5CcmlnaHQ6IFs5MiwgMzldLFxuXHRcdFx0eWVsbG93QnJpZ2h0OiBbOTMsIDM5XSxcblx0XHRcdGJsdWVCcmlnaHQ6IFs5NCwgMzldLFxuXHRcdFx0bWFnZW50YUJyaWdodDogWzk1LCAzOV0sXG5cdFx0XHRjeWFuQnJpZ2h0OiBbOTYsIDM5XSxcblx0XHRcdHdoaXRlQnJpZ2h0OiBbOTcsIDM5XVxuXHRcdH0sXG5cdFx0YmdDb2xvcjoge1xuXHRcdFx0YmdCbGFjazogWzQwLCA0OV0sXG5cdFx0XHRiZ1JlZDogWzQxLCA0OV0sXG5cdFx0XHRiZ0dyZWVuOiBbNDIsIDQ5XSxcblx0XHRcdGJnWWVsbG93OiBbNDMsIDQ5XSxcblx0XHRcdGJnQmx1ZTogWzQ0LCA0OV0sXG5cdFx0XHRiZ01hZ2VudGE6IFs0NSwgNDldLFxuXHRcdFx0YmdDeWFuOiBbNDYsIDQ5XSxcblx0XHRcdGJnV2hpdGU6IFs0NywgNDldLFxuXG5cdFx0XHQvLyBCcmlnaHQgY29sb3Jcblx0XHRcdGJnQmxhY2tCcmlnaHQ6IFsxMDAsIDQ5XSxcblx0XHRcdGJnUmVkQnJpZ2h0OiBbMTAxLCA0OV0sXG5cdFx0XHRiZ0dyZWVuQnJpZ2h0OiBbMTAyLCA0OV0sXG5cdFx0XHRiZ1llbGxvd0JyaWdodDogWzEwMywgNDldLFxuXHRcdFx0YmdCbHVlQnJpZ2h0OiBbMTA0LCA0OV0sXG5cdFx0XHRiZ01hZ2VudGFCcmlnaHQ6IFsxMDUsIDQ5XSxcblx0XHRcdGJnQ3lhbkJyaWdodDogWzEwNiwgNDldLFxuXHRcdFx0YmdXaGl0ZUJyaWdodDogWzEwNywgNDldXG5cdFx0fVxuXHR9O1xuXG5cdC8vIEFsaWFzIGJyaWdodCBibGFjayBhcyBncmF5IChhbmQgZ3JleSlcblx0c3R5bGVzLmNvbG9yLmdyYXkgPSBzdHlsZXMuY29sb3IuYmxhY2tCcmlnaHQ7XG5cdHN0eWxlcy5iZ0NvbG9yLmJnR3JheSA9IHN0eWxlcy5iZ0NvbG9yLmJnQmxhY2tCcmlnaHQ7XG5cdHN0eWxlcy5jb2xvci5ncmV5ID0gc3R5bGVzLmNvbG9yLmJsYWNrQnJpZ2h0O1xuXHRzdHlsZXMuYmdDb2xvci5iZ0dyZXkgPSBzdHlsZXMuYmdDb2xvci5iZ0JsYWNrQnJpZ2h0O1xuXG5cdGZvciAoY29uc3QgW2dyb3VwTmFtZSwgZ3JvdXBdIG9mIE9iamVjdC5lbnRyaWVzKHN0eWxlcykpIHtcblx0XHRmb3IgKGNvbnN0IFtzdHlsZU5hbWUsIHN0eWxlXSBvZiBPYmplY3QuZW50cmllcyhncm91cCkpIHtcblx0XHRcdHN0eWxlc1tzdHlsZU5hbWVdID0ge1xuXHRcdFx0XHRvcGVuOiBgXFx1MDAxQlske3N0eWxlWzBdfW1gLFxuXHRcdFx0XHRjbG9zZTogYFxcdTAwMUJbJHtzdHlsZVsxXX1tYFxuXHRcdFx0fTtcblxuXHRcdFx0Z3JvdXBbc3R5bGVOYW1lXSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuXG5cdFx0XHRjb2Rlcy5zZXQoc3R5bGVbMF0sIHN0eWxlWzFdKTtcblx0XHR9XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoc3R5bGVzLCBncm91cE5hbWUsIHtcblx0XHRcdHZhbHVlOiBncm91cCxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlXG5cdFx0fSk7XG5cdH1cblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoc3R5bGVzLCAnY29kZXMnLCB7XG5cdFx0dmFsdWU6IGNvZGVzLFxuXHRcdGVudW1lcmFibGU6IGZhbHNlXG5cdH0pO1xuXG5cdHN0eWxlcy5jb2xvci5jbG9zZSA9ICdcXHUwMDFCWzM5bSc7XG5cdHN0eWxlcy5iZ0NvbG9yLmNsb3NlID0gJ1xcdTAwMUJbNDltJztcblxuXHRzdHlsZXMuY29sb3IuYW5zaTI1NiA9IHdyYXBBbnNpMjU2KCk7XG5cdHN0eWxlcy5jb2xvci5hbnNpMTZtID0gd3JhcEFuc2kxNm0oKTtcblx0c3R5bGVzLmJnQ29sb3IuYW5zaTI1NiA9IHdyYXBBbnNpMjU2KEFOU0lfQkFDS0dST1VORF9PRkZTRVQpO1xuXHRzdHlsZXMuYmdDb2xvci5hbnNpMTZtID0gd3JhcEFuc2kxNm0oQU5TSV9CQUNLR1JPVU5EX09GRlNFVCk7XG5cblx0Ly8gRnJvbSBodHRwczovL2dpdGh1Yi5jb20vUWl4LS9jb2xvci1jb252ZXJ0L2Jsb2IvM2YwZTBkNGU5MmUyMzU3OTZjY2IxN2Y2ZTg1YzcyMDk0YTY1MWY0OS9jb252ZXJzaW9ucy5qc1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzdHlsZXMsIHtcblx0XHRyZ2JUb0Fuc2kyNTY6IHtcblx0XHRcdHZhbHVlOiAocmVkLCBncmVlbiwgYmx1ZSkgPT4ge1xuXHRcdFx0XHQvLyBXZSB1c2UgdGhlIGV4dGVuZGVkIGdyZXlzY2FsZSBwYWxldHRlIGhlcmUsIHdpdGggdGhlIGV4Y2VwdGlvbiBvZlxuXHRcdFx0XHQvLyBibGFjayBhbmQgd2hpdGUuIG5vcm1hbCBwYWxldHRlIG9ubHkgaGFzIDQgZ3JleXNjYWxlIHNoYWRlcy5cblx0XHRcdFx0aWYgKHJlZCA9PT0gZ3JlZW4gJiYgZ3JlZW4gPT09IGJsdWUpIHtcblx0XHRcdFx0XHRpZiAocmVkIDwgOCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIDE2O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChyZWQgPiAyNDgpIHtcblx0XHRcdFx0XHRcdHJldHVybiAyMzE7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgucm91bmQoKChyZWQgLSA4KSAvIDI0NykgKiAyNCkgKyAyMzI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gMTYgK1xuXHRcdFx0XHRcdCgzNiAqIE1hdGgucm91bmQocmVkIC8gMjU1ICogNSkpICtcblx0XHRcdFx0XHQoNiAqIE1hdGgucm91bmQoZ3JlZW4gLyAyNTUgKiA1KSkgK1xuXHRcdFx0XHRcdE1hdGgucm91bmQoYmx1ZSAvIDI1NSAqIDUpO1xuXHRcdFx0fSxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlXG5cdFx0fSxcblx0XHRoZXhUb1JnYjoge1xuXHRcdFx0dmFsdWU6IGhleCA9PiB7XG5cdFx0XHRcdGNvbnN0IG1hdGNoZXMgPSAvKD88Y29sb3JTdHJpbmc+W2EtZlxcZF17Nn18W2EtZlxcZF17M30pL2kuZXhlYyhoZXgudG9TdHJpbmcoMTYpKTtcblx0XHRcdFx0aWYgKCFtYXRjaGVzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFswLCAwLCAwXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCB7Y29sb3JTdHJpbmd9ID0gbWF0Y2hlcy5ncm91cHM7XG5cblx0XHRcdFx0aWYgKGNvbG9yU3RyaW5nLmxlbmd0aCA9PT0gMykge1xuXHRcdFx0XHRcdGNvbG9yU3RyaW5nID0gY29sb3JTdHJpbmcuc3BsaXQoJycpLm1hcChjaGFyYWN0ZXIgPT4gY2hhcmFjdGVyICsgY2hhcmFjdGVyKS5qb2luKCcnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IGludGVnZXIgPSBOdW1iZXIucGFyc2VJbnQoY29sb3JTdHJpbmcsIDE2KTtcblxuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdChpbnRlZ2VyID4+IDE2KSAmIDB4RkYsXG5cdFx0XHRcdFx0KGludGVnZXIgPj4gOCkgJiAweEZGLFxuXHRcdFx0XHRcdGludGVnZXIgJiAweEZGXG5cdFx0XHRcdF07XG5cdFx0XHR9LFxuXHRcdFx0ZW51bWVyYWJsZTogZmFsc2Vcblx0XHR9LFxuXHRcdGhleFRvQW5zaTI1Njoge1xuXHRcdFx0dmFsdWU6IGhleCA9PiBzdHlsZXMucmdiVG9BbnNpMjU2KC4uLnN0eWxlcy5oZXhUb1JnYihoZXgpKSxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlXG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG4vLyBNYWtlIHRoZSBleHBvcnQgaW1tdXRhYmxlXG5PYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnZXhwb3J0cycsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0Z2V0OiBhc3NlbWJsZVN0eWxlc1xufSk7XG4iLCAiZnVuY3Rpb24gUmV0cnlPcGVyYXRpb24odGltZW91dHMsIG9wdGlvbnMpIHtcbiAgLy8gQ29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCAodGltZW91dHMsIHJldHJ5Rm9yZXZlcikgc2lnbmF0dXJlXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucyA9IHsgZm9yZXZlcjogb3B0aW9ucyB9O1xuICB9XG5cbiAgdGhpcy5fb3JpZ2luYWxUaW1lb3V0cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGltZW91dHMpKTtcbiAgdGhpcy5fdGltZW91dHMgPSB0aW1lb3V0cztcbiAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuX21heFJldHJ5VGltZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5tYXhSZXRyeVRpbWUgfHwgSW5maW5pdHk7XG4gIHRoaXMuX2ZuID0gbnVsbDtcbiAgdGhpcy5fZXJyb3JzID0gW107XG4gIHRoaXMuX2F0dGVtcHRzID0gMTtcbiAgdGhpcy5fb3BlcmF0aW9uVGltZW91dCA9IG51bGw7XG4gIHRoaXMuX29wZXJhdGlvblRpbWVvdXRDYiA9IG51bGw7XG4gIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xuICB0aGlzLl9vcGVyYXRpb25TdGFydCA9IG51bGw7XG4gIHRoaXMuX3RpbWVyID0gbnVsbDtcblxuICBpZiAodGhpcy5fb3B0aW9ucy5mb3JldmVyKSB7XG4gICAgdGhpcy5fY2FjaGVkVGltZW91dHMgPSB0aGlzLl90aW1lb3V0cy5zbGljZSgwKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBSZXRyeU9wZXJhdGlvbjtcblxuUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2F0dGVtcHRzID0gMTtcbiAgdGhpcy5fdGltZW91dHMgPSB0aGlzLl9vcmlnaW5hbFRpbWVvdXRzLnNsaWNlKDApO1xufVxuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fdGltZW91dCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgfVxuICBpZiAodGhpcy5fdGltZXIpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICB9XG5cbiAgdGhpcy5fdGltZW91dHMgICAgICAgPSBbXTtcbiAgdGhpcy5fY2FjaGVkVGltZW91dHMgPSBudWxsO1xufTtcblxuUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLnJldHJ5ID0gZnVuY3Rpb24oZXJyKSB7XG4gIGlmICh0aGlzLl90aW1lb3V0KSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICB9XG5cbiAgaWYgKCFlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIGlmIChlcnIgJiYgY3VycmVudFRpbWUgLSB0aGlzLl9vcGVyYXRpb25TdGFydCA+PSB0aGlzLl9tYXhSZXRyeVRpbWUpIHtcbiAgICB0aGlzLl9lcnJvcnMucHVzaChlcnIpO1xuICAgIHRoaXMuX2Vycm9ycy51bnNoaWZ0KG5ldyBFcnJvcignUmV0cnlPcGVyYXRpb24gdGltZW91dCBvY2N1cnJlZCcpKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0aGlzLl9lcnJvcnMucHVzaChlcnIpO1xuXG4gIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dHMuc2hpZnQoKTtcbiAgaWYgKHRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRUaW1lb3V0cykge1xuICAgICAgLy8gcmV0cnkgZm9yZXZlciwgb25seSBrZWVwIGxhc3QgZXJyb3JcbiAgICAgIHRoaXMuX2Vycm9ycy5zcGxpY2UoMCwgdGhpcy5fZXJyb3JzLmxlbmd0aCAtIDEpO1xuICAgICAgdGltZW91dCA9IHRoaXMuX2NhY2hlZFRpbWVvdXRzLnNsaWNlKC0xKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX2F0dGVtcHRzKys7XG5cbiAgICBpZiAoc2VsZi5fb3BlcmF0aW9uVGltZW91dENiKSB7XG4gICAgICBzZWxmLl90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5fb3BlcmF0aW9uVGltZW91dENiKHNlbGYuX2F0dGVtcHRzKTtcbiAgICAgIH0sIHNlbGYuX29wZXJhdGlvblRpbWVvdXQpO1xuXG4gICAgICBpZiAoc2VsZi5fb3B0aW9ucy51bnJlZikge1xuICAgICAgICAgIHNlbGYuX3RpbWVvdXQudW5yZWYoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmLl9mbihzZWxmLl9hdHRlbXB0cyk7XG4gIH0sIHRpbWVvdXQpO1xuXG4gIGlmICh0aGlzLl9vcHRpb25zLnVucmVmKSB7XG4gICAgICB0aGlzLl90aW1lci51bnJlZigpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuYXR0ZW1wdCA9IGZ1bmN0aW9uKGZuLCB0aW1lb3V0T3BzKSB7XG4gIHRoaXMuX2ZuID0gZm47XG5cbiAgaWYgKHRpbWVvdXRPcHMpIHtcbiAgICBpZiAodGltZW91dE9wcy50aW1lb3V0KSB7XG4gICAgICB0aGlzLl9vcGVyYXRpb25UaW1lb3V0ID0gdGltZW91dE9wcy50aW1lb3V0O1xuICAgIH1cbiAgICBpZiAodGltZW91dE9wcy5jYikge1xuICAgICAgdGhpcy5fb3BlcmF0aW9uVGltZW91dENiID0gdGltZW91dE9wcy5jYjtcbiAgICB9XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0aGlzLl9vcGVyYXRpb25UaW1lb3V0Q2IpIHtcbiAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuX29wZXJhdGlvblRpbWVvdXRDYigpO1xuICAgIH0sIHNlbGYuX29wZXJhdGlvblRpbWVvdXQpO1xuICB9XG5cbiAgdGhpcy5fb3BlcmF0aW9uU3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICB0aGlzLl9mbih0aGlzLl9hdHRlbXB0cyk7XG59O1xuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUudHJ5ID0gZnVuY3Rpb24oZm4pIHtcbiAgY29uc29sZS5sb2coJ1VzaW5nIFJldHJ5T3BlcmF0aW9uLnRyeSgpIGlzIGRlcHJlY2F0ZWQnKTtcbiAgdGhpcy5hdHRlbXB0KGZuKTtcbn07XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKGZuKSB7XG4gIGNvbnNvbGUubG9nKCdVc2luZyBSZXRyeU9wZXJhdGlvbi5zdGFydCgpIGlzIGRlcHJlY2F0ZWQnKTtcbiAgdGhpcy5hdHRlbXB0KGZuKTtcbn07XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5zdGFydCA9IFJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS50cnk7XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5lcnJvcnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2Vycm9ycztcbn07XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5hdHRlbXB0cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fYXR0ZW1wdHM7XG59O1xuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUubWFpbkVycm9yID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9lcnJvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgY291bnRzID0ge307XG4gIHZhciBtYWluRXJyb3IgPSBudWxsO1xuICB2YXIgbWFpbkVycm9yQ291bnQgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVycm9yID0gdGhpcy5fZXJyb3JzW2ldO1xuICAgIHZhciBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICB2YXIgY291bnQgPSAoY291bnRzW21lc3NhZ2VdIHx8IDApICsgMTtcblxuICAgIGNvdW50c1ttZXNzYWdlXSA9IGNvdW50O1xuXG4gICAgaWYgKGNvdW50ID49IG1haW5FcnJvckNvdW50KSB7XG4gICAgICBtYWluRXJyb3IgPSBlcnJvcjtcbiAgICAgIG1haW5FcnJvckNvdW50ID0gY291bnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1haW5FcnJvcjtcbn07XG4iLCAidmFyIFJldHJ5T3BlcmF0aW9uID0gcmVxdWlyZSgnLi9yZXRyeV9vcGVyYXRpb24nKTtcblxuZXhwb3J0cy5vcGVyYXRpb24gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciB0aW1lb3V0cyA9IGV4cG9ydHMudGltZW91dHMob3B0aW9ucyk7XG4gIHJldHVybiBuZXcgUmV0cnlPcGVyYXRpb24odGltZW91dHMsIHtcbiAgICAgIGZvcmV2ZXI6IG9wdGlvbnMgJiYgKG9wdGlvbnMuZm9yZXZlciB8fCBvcHRpb25zLnJldHJpZXMgPT09IEluZmluaXR5KSxcbiAgICAgIHVucmVmOiBvcHRpb25zICYmIG9wdGlvbnMudW5yZWYsXG4gICAgICBtYXhSZXRyeVRpbWU6IG9wdGlvbnMgJiYgb3B0aW9ucy5tYXhSZXRyeVRpbWVcbiAgfSk7XG59O1xuXG5leHBvcnRzLnRpbWVvdXRzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChvcHRpb25zKTtcbiAgfVxuXG4gIHZhciBvcHRzID0ge1xuICAgIHJldHJpZXM6IDEwLFxuICAgIGZhY3RvcjogMixcbiAgICBtaW5UaW1lb3V0OiAxICogMTAwMCxcbiAgICBtYXhUaW1lb3V0OiBJbmZpbml0eSxcbiAgICByYW5kb21pemU6IGZhbHNlXG4gIH07XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgb3B0c1trZXldID0gb3B0aW9uc1trZXldO1xuICB9XG5cbiAgaWYgKG9wdHMubWluVGltZW91dCA+IG9wdHMubWF4VGltZW91dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbWluVGltZW91dCBpcyBncmVhdGVyIHRoYW4gbWF4VGltZW91dCcpO1xuICB9XG5cbiAgdmFyIHRpbWVvdXRzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0cy5yZXRyaWVzOyBpKyspIHtcbiAgICB0aW1lb3V0cy5wdXNoKHRoaXMuY3JlYXRlVGltZW91dChpLCBvcHRzKSk7XG4gIH1cblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZvcmV2ZXIgJiYgIXRpbWVvdXRzLmxlbmd0aCkge1xuICAgIHRpbWVvdXRzLnB1c2godGhpcy5jcmVhdGVUaW1lb3V0KGksIG9wdHMpKTtcbiAgfVxuXG4gIC8vIHNvcnQgdGhlIGFycmF5IG51bWVyaWNhbGx5IGFzY2VuZGluZ1xuICB0aW1lb3V0cy5zb3J0KGZ1bmN0aW9uKGEsYikge1xuICAgIHJldHVybiBhIC0gYjtcbiAgfSk7XG5cbiAgcmV0dXJuIHRpbWVvdXRzO1xufTtcblxuZXhwb3J0cy5jcmVhdGVUaW1lb3V0ID0gZnVuY3Rpb24oYXR0ZW1wdCwgb3B0cykge1xuICB2YXIgcmFuZG9tID0gKG9wdHMucmFuZG9taXplKVxuICAgID8gKE1hdGgucmFuZG9tKCkgKyAxKVxuICAgIDogMTtcblxuICB2YXIgdGltZW91dCA9IE1hdGgucm91bmQocmFuZG9tICogTWF0aC5tYXgob3B0cy5taW5UaW1lb3V0LCAxKSAqIE1hdGgucG93KG9wdHMuZmFjdG9yLCBhdHRlbXB0KSk7XG4gIHRpbWVvdXQgPSBNYXRoLm1pbih0aW1lb3V0LCBvcHRzLm1heFRpbWVvdXQpO1xuXG4gIHJldHVybiB0aW1lb3V0O1xufTtcblxuZXhwb3J0cy53cmFwID0gZnVuY3Rpb24ob2JqLCBvcHRpb25zLCBtZXRob2RzKSB7XG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICBtZXRob2RzID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuXG4gIGlmICghbWV0aG9kcykge1xuICAgIG1ldGhvZHMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9ialtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG1ldGhvZHMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtZXRob2QgICA9IG1ldGhvZHNbaV07XG4gICAgdmFyIG9yaWdpbmFsID0gb2JqW21ldGhvZF07XG5cbiAgICBvYmpbbWV0aG9kXSA9IGZ1bmN0aW9uIHJldHJ5V3JhcHBlcihvcmlnaW5hbCkge1xuICAgICAgdmFyIG9wICAgICAgID0gZXhwb3J0cy5vcGVyYXRpb24ob3B0aW9ucyk7XG4gICAgICB2YXIgYXJncyAgICAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcblxuICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgICBpZiAob3AucmV0cnkoZXJyKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgYXJndW1lbnRzWzBdID0gb3AubWFpbkVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgICBvcC5hdHRlbXB0KGZ1bmN0aW9uKCkge1xuICAgICAgICBvcmlnaW5hbC5hcHBseShvYmosIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfS5iaW5kKG9iaiwgb3JpZ2luYWwpO1xuICAgIG9ialttZXRob2RdLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG59O1xuIiwgIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvcmV0cnknKTsiLCAiJ3VzZSBzdHJpY3QnO1xuY29uc3QgcmV0cnkgPSByZXF1aXJlKCdyZXRyeScpO1xuXG5jb25zdCBuZXR3b3JrRXJyb3JNc2dzID0gW1xuXHQnRmFpbGVkIHRvIGZldGNoJywgLy8gQ2hyb21lXG5cdCdOZXR3b3JrRXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIGZldGNoIHJlc291cmNlLicsIC8vIEZpcmVmb3hcblx0J1RoZSBJbnRlcm5ldCBjb25uZWN0aW9uIGFwcGVhcnMgdG8gYmUgb2ZmbGluZS4nLCAvLyBTYWZhcmlcblx0J05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnIC8vIGBjcm9zcy1mZXRjaGBcbl07XG5cbmNsYXNzIEFib3J0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcblx0XHRzdXBlcigpO1xuXG5cdFx0aWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0dGhpcy5vcmlnaW5hbEVycm9yID0gbWVzc2FnZTtcblx0XHRcdCh7bWVzc2FnZX0gPSBtZXNzYWdlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5vcmlnaW5hbEVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuXHRcdFx0dGhpcy5vcmlnaW5hbEVycm9yLnN0YWNrID0gdGhpcy5zdGFjaztcblx0XHR9XG5cblx0XHR0aGlzLm5hbWUgPSAnQWJvcnRFcnJvcic7XG5cdFx0dGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblx0fVxufVxuXG5jb25zdCBkZWNvcmF0ZUVycm9yV2l0aENvdW50cyA9IChlcnJvciwgYXR0ZW1wdE51bWJlciwgb3B0aW9ucykgPT4ge1xuXHQvLyBNaW51cyAxIGZyb20gYXR0ZW1wdE51bWJlciBiZWNhdXNlIHRoZSBmaXJzdCBhdHRlbXB0IGRvZXMgbm90IGNvdW50IGFzIGEgcmV0cnlcblx0Y29uc3QgcmV0cmllc0xlZnQgPSBvcHRpb25zLnJldHJpZXMgLSAoYXR0ZW1wdE51bWJlciAtIDEpO1xuXG5cdGVycm9yLmF0dGVtcHROdW1iZXIgPSBhdHRlbXB0TnVtYmVyO1xuXHRlcnJvci5yZXRyaWVzTGVmdCA9IHJldHJpZXNMZWZ0O1xuXHRyZXR1cm4gZXJyb3I7XG59O1xuXG5jb25zdCBpc05ldHdvcmtFcnJvciA9IGVycm9yTWVzc2FnZSA9PiBuZXR3b3JrRXJyb3JNc2dzLmluY2x1ZGVzKGVycm9yTWVzc2FnZSk7XG5cbmNvbnN0IHBSZXRyeSA9IChpbnB1dCwgb3B0aW9ucykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRvcHRpb25zID0ge1xuXHRcdG9uRmFpbGVkQXR0ZW1wdDogKCkgPT4ge30sXG5cdFx0cmV0cmllczogMTAsXG5cdFx0Li4ub3B0aW9uc1xuXHR9O1xuXG5cdGNvbnN0IG9wZXJhdGlvbiA9IHJldHJ5Lm9wZXJhdGlvbihvcHRpb25zKTtcblxuXHRvcGVyYXRpb24uYXR0ZW1wdChhc3luYyBhdHRlbXB0TnVtYmVyID0+IHtcblx0XHR0cnkge1xuXHRcdFx0cmVzb2x2ZShhd2FpdCBpbnB1dChhdHRlbXB0TnVtYmVyKSk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmICghKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG5cdFx0XHRcdHJlamVjdChuZXcgVHlwZUVycm9yKGBOb24tZXJyb3Igd2FzIHRocm93bjogXCIke2Vycm9yfVwiLiBZb3Ugc2hvdWxkIG9ubHkgdGhyb3cgZXJyb3JzLmApKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZXJyb3IgaW5zdGFuY2VvZiBBYm9ydEVycm9yKSB7XG5cdFx0XHRcdG9wZXJhdGlvbi5zdG9wKCk7XG5cdFx0XHRcdHJlamVjdChlcnJvci5vcmlnaW5hbEVycm9yKTtcblx0XHRcdH0gZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgIWlzTmV0d29ya0Vycm9yKGVycm9yLm1lc3NhZ2UpKSB7XG5cdFx0XHRcdG9wZXJhdGlvbi5zdG9wKCk7XG5cdFx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWNvcmF0ZUVycm9yV2l0aENvdW50cyhlcnJvciwgYXR0ZW1wdE51bWJlciwgb3B0aW9ucyk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRhd2FpdCBvcHRpb25zLm9uRmFpbGVkQXR0ZW1wdChlcnJvcik7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIW9wZXJhdGlvbi5yZXRyeShlcnJvcikpIHtcblx0XHRcdFx0XHRyZWplY3Qob3BlcmF0aW9uLm1haW5FcnJvcigpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwUmV0cnk7XG4vLyBUT0RPOiByZW1vdmUgdGhpcyBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gcFJldHJ5O1xuXG5tb2R1bGUuZXhwb3J0cy5BYm9ydEVycm9yID0gQWJvcnRFcnJvcjtcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgcHJlZml4ID0gJ34nO1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIHN0b3JhZ2UgZm9yIG91ciBgRUVgIG9iamVjdHMuXG4gKiBBbiBgRXZlbnRzYCBpbnN0YW5jZSBpcyBhIHBsYWluIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGFyZSBldmVudCBuYW1lcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEV2ZW50cygpIHt9XG5cbi8vXG4vLyBXZSB0cnkgdG8gbm90IGluaGVyaXQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuIEluIHNvbWUgZW5naW5lcyBjcmVhdGluZyBhblxuLy8gaW5zdGFuY2UgaW4gdGhpcyB3YXkgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZGlyZWN0bHkuXG4vLyBJZiBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaXMgbm90IHN1cHBvcnRlZCB3ZSBwcmVmaXggdGhlIGV2ZW50IG5hbWVzIHdpdGggYVxuLy8gY2hhcmFjdGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90XG4vLyBvdmVycmlkZGVuIG9yIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cbi8vXG5pZiAoT2JqZWN0LmNyZWF0ZSkge1xuICBFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvL1xuICAvLyBUaGlzIGhhY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGBfX3Byb3RvX19gIHByb3BlcnR5IGlzIHN0aWxsIGluaGVyaXRlZCBpblxuICAvLyBzb21lIG9sZCBicm93c2VycyBsaWtlIEFuZHJvaWQgNCwgaVBob25lIDUuMSwgT3BlcmEgMTEgYW5kIFNhZmFyaSA1LlxuICAvL1xuICBpZiAoIW5ldyBFdmVudHMoKS5fX3Byb3RvX18pIHByZWZpeCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFRShmbiwgY29udGV4dCwgb25jZSkge1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMub25jZSA9IG9uY2UgfHwgZmFsc2U7XG59XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCBlbWl0dGVyLCBvbmNlKVxuICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdKSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCBlbWl0dGVyLl9ldmVudHNDb3VudCsrO1xuICBlbHNlIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0uZm4pIGVtaXR0ZXIuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gW2VtaXR0ZXIuX2V2ZW50c1tldnRdLCBsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIGVtaXR0ZXI7XG59XG5cbi8qKlxuICogQ2xlYXIgZXZlbnQgYnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2dCBUaGUgRXZlbnQgbmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyRXZlbnQoZW1pdHRlciwgZXZ0KSB7XG4gIGlmICgtLWVtaXR0ZXIuX2V2ZW50c0NvdW50ID09PSAwKSBlbWl0dGVyLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIGVsc2UgZGVsZXRlIGVtaXR0ZXIuX2V2ZW50c1tldnRdO1xufVxuXG4vKipcbiAqIE1pbmltYWwgYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlIHRoYXQgaXMgbW9sZGVkIGFnYWluc3QgdGhlIE5vZGUuanNcbiAqIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgbGlzdGluZyB0aGUgZXZlbnRzIGZvciB3aGljaCB0aGUgZW1pdHRlciBoYXMgcmVnaXN0ZXJlZFxuICogbGlzdGVuZXJzLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgdmFyIG5hbWVzID0gW11cbiAgICAsIGV2ZW50c1xuICAgICwgbmFtZTtcblxuICBpZiAodGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHJldHVybiBuYW1lcztcblxuICBmb3IgKG5hbWUgaW4gKGV2ZW50cyA9IHRoaXMuX2V2ZW50cykpIHtcbiAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHJldHVybiBuYW1lcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhldmVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lcztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSByZWdpc3RlcmVkIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGhhbmRsZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFoYW5kbGVycykgcmV0dXJuIFtdO1xuICBpZiAoaGFuZGxlcnMuZm4pIHJldHVybiBbaGFuZGxlcnMuZm5dO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKykge1xuICAgIGVlW2ldID0gaGFuZGxlcnNbaV0uZm47XG4gIH1cblxuICByZXR1cm4gZWU7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gbGlzdGVuZXJDb3VudChldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiAwO1xuICBpZiAobGlzdGVuZXJzLmZuKSByZXR1cm4gMTtcbiAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGVsc2UgYGZhbHNlYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cbiAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGFyZ3NcbiAgICAsIGk7XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChsaXN0ZW5lcnMub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG4gICAgICBjYXNlIDM6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG4gICAgICBjYXNlIDY6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tpXS5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAxOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcbiAgICAgICAgY2FzZSA0OiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyLCBhMyk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghYXJncykgZm9yIChqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIHRydWUpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGxpc3RlbmVycyBvZiBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBoYXZlIHRoaXMgY29udGV4dC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IHJlbW92ZSBvbmUtdGltZSBsaXN0ZW5lcnMuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIHRoaXM7XG4gIGlmICghZm4pIHtcbiAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChcbiAgICAgIGxpc3RlbmVycy5mbiA9PT0gZm4gJiZcbiAgICAgICghb25jZSB8fCBsaXN0ZW5lcnMub25jZSkgJiZcbiAgICAgICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dClcbiAgICApIHtcbiAgICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGV2ZW50cyA9IFtdLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChcbiAgICAgICAgbGlzdGVuZXJzW2ldLmZuICE9PSBmbiB8fFxuICAgICAgICAob25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UpIHx8XG4gICAgICAgIChjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KVxuICAgICAgKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gICAgLy9cbiAgICBpZiAoZXZlbnRzLmxlbmd0aCkgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuICAgIGVsc2UgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBbZXZlbnRdIFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0O1xuXG4gIGlmIChldmVudCkge1xuICAgIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG4gICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEFsaWFzIG1ldGhvZHMgbmFtZXMgYmVjYXVzZSBwZW9wbGUgcm9sbCBsaWtlIHRoYXQuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbi8vXG4vLyBFeHBvc2UgdGhlIHByZWZpeC5cbi8vXG5FdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG5cbi8vXG4vLyBBbGxvdyBgRXZlbnRFbWl0dGVyYCB0byBiZSBpbXBvcnRlZCBhcyBtb2R1bGUgbmFtZXNwYWNlLlxuLy9cbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5pZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBtb2R1bGUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSAocHJvbWlzZSwgb25GaW5hbGx5KSA9PiB7XG5cdG9uRmluYWxseSA9IG9uRmluYWxseSB8fCAoKCkgPT4ge30pO1xuXG5cdHJldHVybiBwcm9taXNlLnRoZW4oXG5cdFx0dmFsID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuXHRcdFx0cmVzb2x2ZShvbkZpbmFsbHkoKSk7XG5cdFx0fSkudGhlbigoKSA9PiB2YWwpLFxuXHRcdGVyciA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcblx0XHRcdHJlc29sdmUob25GaW5hbGx5KCkpO1xuXHRcdH0pLnRoZW4oKCkgPT4ge1xuXHRcdFx0dGhyb3cgZXJyO1xuXHRcdH0pXG5cdCk7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgcEZpbmFsbHkgPSByZXF1aXJlKCdwLWZpbmFsbHknKTtcblxuY2xhc3MgVGltZW91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG5cdFx0c3VwZXIobWVzc2FnZSk7XG5cdFx0dGhpcy5uYW1lID0gJ1RpbWVvdXRFcnJvcic7XG5cdH1cbn1cblxuY29uc3QgcFRpbWVvdXQgPSAocHJvbWlzZSwgbWlsbGlzZWNvbmRzLCBmYWxsYmFjaykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRpZiAodHlwZW9mIG1pbGxpc2Vjb25kcyAhPT0gJ251bWJlcicgfHwgbWlsbGlzZWNvbmRzIDwgMCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBtaWxsaXNlY29uZHNgIHRvIGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG5cdH1cblxuXHRpZiAobWlsbGlzZWNvbmRzID09PSBJbmZpbml0eSkge1xuXHRcdHJlc29sdmUocHJvbWlzZSk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRpZiAodHlwZW9mIGZhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXNvbHZlKGZhbGxiYWNrKCkpO1xuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IG1lc3NhZ2UgPSB0eXBlb2YgZmFsbGJhY2sgPT09ICdzdHJpbmcnID8gZmFsbGJhY2sgOiBgUHJvbWlzZSB0aW1lZCBvdXQgYWZ0ZXIgJHttaWxsaXNlY29uZHN9IG1pbGxpc2Vjb25kc2A7XG5cdFx0Y29uc3QgdGltZW91dEVycm9yID0gZmFsbGJhY2sgaW5zdGFuY2VvZiBFcnJvciA/IGZhbGxiYWNrIDogbmV3IFRpbWVvdXRFcnJvcihtZXNzYWdlKTtcblxuXHRcdGlmICh0eXBlb2YgcHJvbWlzZS5jYW5jZWwgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHByb21pc2UuY2FuY2VsKCk7XG5cdFx0fVxuXG5cdFx0cmVqZWN0KHRpbWVvdXRFcnJvcik7XG5cdH0sIG1pbGxpc2Vjb25kcyk7XG5cblx0Ly8gVE9ETzogVXNlIG5hdGl2ZSBgZmluYWxseWAga2V5d29yZCB3aGVuIHRhcmdldGluZyBOb2RlLmpzIDEwXG5cdHBGaW5hbGx5KFxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcm9taXNlL3ByZWZlci1hd2FpdC10by10aGVuXG5cdFx0cHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCksXG5cdFx0KCkgPT4ge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0XHR9XG5cdCk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwVGltZW91dDtcbi8vIFRPRE86IFJlbW92ZSB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gcFRpbWVvdXQ7XG5cbm1vZHVsZS5leHBvcnRzLlRpbWVvdXRFcnJvciA9IFRpbWVvdXRFcnJvcjtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIFBvcnQgb2YgbG93ZXJfYm91bmQgZnJvbSBodHRwczovL2VuLmNwcHJlZmVyZW5jZS5jb20vdy9jcHAvYWxnb3JpdGhtL2xvd2VyX2JvdW5kXG4vLyBVc2VkIHRvIGNvbXB1dGUgaW5zZXJ0aW9uIGluZGV4IHRvIGtlZXAgcXVldWUgc29ydGVkIGFmdGVyIGluc2VydGlvblxuZnVuY3Rpb24gbG93ZXJCb3VuZChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgICBsZXQgZmlyc3QgPSAwO1xuICAgIGxldCBjb3VudCA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAoY291bnQgPiAwKSB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSAoY291bnQgLyAyKSB8IDA7XG4gICAgICAgIGxldCBpdCA9IGZpcnN0ICsgc3RlcDtcbiAgICAgICAgaWYgKGNvbXBhcmF0b3IoYXJyYXlbaXRdLCB2YWx1ZSkgPD0gMCkge1xuICAgICAgICAgICAgZmlyc3QgPSArK2l0O1xuICAgICAgICAgICAgY291bnQgLT0gc3RlcCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb3VudCA9IHN0ZXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gbG93ZXJCb3VuZDtcbiIsICJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGxvd2VyX2JvdW5kXzEgPSByZXF1aXJlKFwiLi9sb3dlci1ib3VuZFwiKTtcbmNsYXNzIFByaW9yaXR5UXVldWUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgIH1cbiAgICBlbnF1ZXVlKHJ1biwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IHByaW9yaXR5OiAwIH0sIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0ge1xuICAgICAgICAgICAgcHJpb3JpdHk6IG9wdGlvbnMucHJpb3JpdHksXG4gICAgICAgICAgICBydW5cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSAmJiB0aGlzLl9xdWV1ZVt0aGlzLnNpemUgLSAxXS5wcmlvcml0eSA+PSBvcHRpb25zLnByaW9yaXR5KSB7XG4gICAgICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbG93ZXJfYm91bmRfMS5kZWZhdWx0KHRoaXMuX3F1ZXVlLCBlbGVtZW50LCAoYSwgYikgPT4gYi5wcmlvcml0eSAtIGEucHJpb3JpdHkpO1xuICAgICAgICB0aGlzLl9xdWV1ZS5zcGxpY2UoaW5kZXgsIDAsIGVsZW1lbnQpO1xuICAgIH1cbiAgICBkZXF1ZXVlKCkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIGl0ZW0gPT09IG51bGwgfHwgaXRlbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaXRlbS5ydW47XG4gICAgfVxuICAgIGZpbHRlcihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9xdWV1ZS5maWx0ZXIoKGVsZW1lbnQpID0+IGVsZW1lbnQucHJpb3JpdHkgPT09IG9wdGlvbnMucHJpb3JpdHkpLm1hcCgoZWxlbWVudCkgPT4gZWxlbWVudC5ydW4pO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXVlLmxlbmd0aDtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQcmlvcml0eVF1ZXVlO1xuIiwgIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcImV2ZW50ZW1pdHRlcjNcIik7XG5jb25zdCBwX3RpbWVvdXRfMSA9IHJlcXVpcmUoXCJwLXRpbWVvdXRcIik7XG5jb25zdCBwcmlvcml0eV9xdWV1ZV8xID0gcmVxdWlyZShcIi4vcHJpb3JpdHktcXVldWVcIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG5jb25zdCBlbXB0eSA9ICgpID0+IHsgfTtcbmNvbnN0IHRpbWVvdXRFcnJvciA9IG5ldyBwX3RpbWVvdXRfMS5UaW1lb3V0RXJyb3IoKTtcbi8qKlxuUHJvbWlzZSBxdWV1ZSB3aXRoIGNvbmN1cnJlbmN5IGNvbnRyb2wuXG4qL1xuY2xhc3MgUFF1ZXVlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5faW50ZXJ2YWxDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX2ludGVydmFsRW5kID0gMDtcbiAgICAgICAgdGhpcy5fcGVuZGluZ0NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUVtcHR5ID0gZW1wdHk7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVJZGxlID0gZW1wdHk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvY29uc2lzdGVudC10eXBlLWFzc2VydGlvbnNcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBjYXJyeW92ZXJDb25jdXJyZW5jeUNvdW50OiBmYWxzZSwgaW50ZXJ2YWxDYXA6IEluZmluaXR5LCBpbnRlcnZhbDogMCwgY29uY3VycmVuY3k6IEluZmluaXR5LCBhdXRvU3RhcnQ6IHRydWUsIHF1ZXVlQ2xhc3M6IHByaW9yaXR5X3F1ZXVlXzEuZGVmYXVsdCB9LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCEodHlwZW9mIG9wdGlvbnMuaW50ZXJ2YWxDYXAgPT09ICdudW1iZXInICYmIG9wdGlvbnMuaW50ZXJ2YWxDYXAgPj0gMSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFxcYGludGVydmFsQ2FwXFxgIHRvIGJlIGEgbnVtYmVyIGZyb20gMSBhbmQgdXAsIGdvdCBcXGAkeyhfYiA9IChfYSA9IG9wdGlvbnMuaW50ZXJ2YWxDYXApID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b1N0cmluZygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJ31cXGAgKCR7dHlwZW9mIG9wdGlvbnMuaW50ZXJ2YWxDYXB9KWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmludGVydmFsID09PSB1bmRlZmluZWQgfHwgIShOdW1iZXIuaXNGaW5pdGUob3B0aW9ucy5pbnRlcnZhbCkgJiYgb3B0aW9ucy5pbnRlcnZhbCA+PSAwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgaW50ZXJ2YWxcXGAgdG8gYmUgYSBmaW5pdGUgbnVtYmVyID49IDAsIGdvdCBcXGAkeyhfZCA9IChfYyA9IG9wdGlvbnMuaW50ZXJ2YWwpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b1N0cmluZygpKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAnJ31cXGAgKCR7dHlwZW9mIG9wdGlvbnMuaW50ZXJ2YWx9KWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhcnJ5b3ZlckNvbmN1cnJlbmN5Q291bnQgPSBvcHRpb25zLmNhcnJ5b3ZlckNvbmN1cnJlbmN5Q291bnQ7XG4gICAgICAgIHRoaXMuX2lzSW50ZXJ2YWxJZ25vcmVkID0gb3B0aW9ucy5pbnRlcnZhbENhcCA9PT0gSW5maW5pdHkgfHwgb3B0aW9ucy5pbnRlcnZhbCA9PT0gMDtcbiAgICAgICAgdGhpcy5faW50ZXJ2YWxDYXAgPSBvcHRpb25zLmludGVydmFsQ2FwO1xuICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IG9wdGlvbnMuaW50ZXJ2YWw7XG4gICAgICAgIHRoaXMuX3F1ZXVlID0gbmV3IG9wdGlvbnMucXVldWVDbGFzcygpO1xuICAgICAgICB0aGlzLl9xdWV1ZUNsYXNzID0gb3B0aW9ucy5xdWV1ZUNsYXNzO1xuICAgICAgICB0aGlzLmNvbmN1cnJlbmN5ID0gb3B0aW9ucy5jb25jdXJyZW5jeTtcbiAgICAgICAgdGhpcy5fdGltZW91dCA9IG9wdGlvbnMudGltZW91dDtcbiAgICAgICAgdGhpcy5fdGhyb3dPblRpbWVvdXQgPSBvcHRpb25zLnRocm93T25UaW1lb3V0ID09PSB0cnVlO1xuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IG9wdGlvbnMuYXV0b1N0YXJ0ID09PSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IF9kb2VzSW50ZXJ2YWxBbGxvd0Fub3RoZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0ludGVydmFsSWdub3JlZCB8fCB0aGlzLl9pbnRlcnZhbENvdW50IDwgdGhpcy5faW50ZXJ2YWxDYXA7XG4gICAgfVxuICAgIGdldCBfZG9lc0NvbmN1cnJlbnRBbGxvd0Fub3RoZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQ291bnQgPCB0aGlzLl9jb25jdXJyZW5jeTtcbiAgICB9XG4gICAgX25leHQoKSB7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdDb3VudC0tO1xuICAgICAgICB0aGlzLl90cnlUb1N0YXJ0QW5vdGhlcigpO1xuICAgICAgICB0aGlzLmVtaXQoJ25leHQnKTtcbiAgICB9XG4gICAgX3Jlc29sdmVQcm9taXNlcygpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUVtcHR5KCk7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVFbXB0eSA9IGVtcHR5O1xuICAgICAgICBpZiAodGhpcy5fcGVuZGluZ0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlSWRsZSgpO1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZUlkbGUgPSBlbXB0eTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnaWRsZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9vblJlc3VtZUludGVydmFsKCkge1xuICAgICAgICB0aGlzLl9vbkludGVydmFsKCk7XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVJbnRlcnZhbElmTmVlZGVkKCk7XG4gICAgICAgIHRoaXMuX3RpbWVvdXRJZCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgX2lzSW50ZXJ2YWxQYXVzZWQoKSB7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcnZhbElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gdGhpcy5faW50ZXJ2YWxFbmQgLSBub3c7XG4gICAgICAgICAgICBpZiAoZGVsYXkgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQWN0IGFzIHRoZSBpbnRlcnZhbCB3YXMgZG9uZVxuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gcmVzdW1lIGl0IGhlcmUgYmVjYXVzZSBpdCB3aWxsIGJlIHJlc3VtZWQgb24gbGluZSAxNjBcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcnZhbENvdW50ID0gKHRoaXMuX2NhcnJ5b3ZlckNvbmN1cnJlbmN5Q291bnQpID8gdGhpcy5fcGVuZGluZ0NvdW50IDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFjdCBhcyB0aGUgaW50ZXJ2YWwgaXMgcGVuZGluZ1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90aW1lb3V0SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29uUmVzdW1lSW50ZXJ2YWwoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF90cnlUb1N0YXJ0QW5vdGhlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3F1ZXVlLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIC8vIFdlIGNhbiBjbGVhciB0aGUgaW50ZXJ2YWwgKFwicGF1c2VcIilcbiAgICAgICAgICAgIC8vIEJlY2F1c2Ugd2UgY2FuIHJlZG8gaXQgbGF0ZXIgKFwicmVzdW1lXCIpXG4gICAgICAgICAgICBpZiAodGhpcy5faW50ZXJ2YWxJZCkge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWxJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pbnRlcnZhbElkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZVByb21pc2VzKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pc1BhdXNlZCkge1xuICAgICAgICAgICAgY29uc3QgY2FuSW5pdGlhbGl6ZUludGVydmFsID0gIXRoaXMuX2lzSW50ZXJ2YWxQYXVzZWQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kb2VzSW50ZXJ2YWxBbGxvd0Fub3RoZXIgJiYgdGhpcy5fZG9lc0NvbmN1cnJlbnRBbGxvd0Fub3RoZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBqb2IgPSB0aGlzLl9xdWV1ZS5kZXF1ZXVlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFqb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgIGpvYigpO1xuICAgICAgICAgICAgICAgIGlmIChjYW5Jbml0aWFsaXplSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZUludGVydmFsSWZOZWVkZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfaW5pdGlhbGl6ZUludGVydmFsSWZOZWVkZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0ludGVydmFsSWdub3JlZCB8fCB0aGlzLl9pbnRlcnZhbElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fb25JbnRlcnZhbCgpO1xuICAgICAgICB9LCB0aGlzLl9pbnRlcnZhbCk7XG4gICAgICAgIHRoaXMuX2ludGVydmFsRW5kID0gRGF0ZS5ub3coKSArIHRoaXMuX2ludGVydmFsO1xuICAgIH1cbiAgICBfb25JbnRlcnZhbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ludGVydmFsQ291bnQgPT09IDAgJiYgdGhpcy5fcGVuZGluZ0NvdW50ID09PSAwICYmIHRoaXMuX2ludGVydmFsSWQpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWxJZCk7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcnZhbElkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ludGVydmFsQ291bnQgPSB0aGlzLl9jYXJyeW92ZXJDb25jdXJyZW5jeUNvdW50ID8gdGhpcy5fcGVuZGluZ0NvdW50IDogMDtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc1F1ZXVlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEV4ZWN1dGVzIGFsbCBxdWV1ZWQgZnVuY3Rpb25zIHVudGlsIGl0IHJlYWNoZXMgdGhlIGxpbWl0LlxuICAgICovXG4gICAgX3Byb2Nlc3NRdWV1ZSgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgIHdoaWxlICh0aGlzLl90cnlUb1N0YXJ0QW5vdGhlcigpKSB7IH1cbiAgICB9XG4gICAgZ2V0IGNvbmN1cnJlbmN5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29uY3VycmVuY3k7XG4gICAgfVxuICAgIHNldCBjb25jdXJyZW5jeShuZXdDb25jdXJyZW5jeSkge1xuICAgICAgICBpZiAoISh0eXBlb2YgbmV3Q29uY3VycmVuY3kgPT09ICdudW1iZXInICYmIG5ld0NvbmN1cnJlbmN5ID49IDEpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBjb25jdXJyZW5jeVxcYCB0byBiZSBhIG51bWJlciBmcm9tIDEgYW5kIHVwLCBnb3QgXFxgJHtuZXdDb25jdXJyZW5jeX1cXGAgKCR7dHlwZW9mIG5ld0NvbmN1cnJlbmN5fSlgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb25jdXJyZW5jeSA9IG5ld0NvbmN1cnJlbmN5O1xuICAgICAgICB0aGlzLl9wcm9jZXNzUXVldWUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkcyBhIHN5bmMgb3IgYXN5bmMgdGFzayB0byB0aGUgcXVldWUuIEFsd2F5cyByZXR1cm5zIGEgcHJvbWlzZS5cbiAgICAqL1xuICAgIGFzeW5jIGFkZChmbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBydW4gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0NvdW50Kys7XG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJ2YWxDb3VudCsrO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9ICh0aGlzLl90aW1lb3V0ID09PSB1bmRlZmluZWQgJiYgb3B0aW9ucy50aW1lb3V0ID09PSB1bmRlZmluZWQpID8gZm4oKSA6IHBfdGltZW91dF8xLmRlZmF1bHQoUHJvbWlzZS5yZXNvbHZlKGZuKCkpLCAob3B0aW9ucy50aW1lb3V0ID09PSB1bmRlZmluZWQgPyB0aGlzLl90aW1lb3V0IDogb3B0aW9ucy50aW1lb3V0KSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudGhyb3dPblRpbWVvdXQgPT09IHVuZGVmaW5lZCA/IHRoaXMuX3Rocm93T25UaW1lb3V0IDogb3B0aW9ucy50aHJvd09uVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh0aW1lb3V0RXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYXdhaXQgb3BlcmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX25leHQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9xdWV1ZS5lbnF1ZXVlKHJ1biwgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLl90cnlUb1N0YXJ0QW5vdGhlcigpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdhZGQnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFNhbWUgYXMgYC5hZGQoKWAsIGJ1dCBhY2NlcHRzIGFuIGFycmF5IG9mIHN5bmMgb3IgYXN5bmMgZnVuY3Rpb25zLlxuXG4gICAgQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBhbGwgZnVuY3Rpb25zIGFyZSByZXNvbHZlZC5cbiAgICAqL1xuICAgIGFzeW5jIGFkZEFsbChmdW5jdGlvbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGZ1bmN0aW9ucy5tYXAoYXN5bmMgKGZ1bmN0aW9uXykgPT4gdGhpcy5hZGQoZnVuY3Rpb25fLCBvcHRpb25zKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBTdGFydCAob3IgcmVzdW1lKSBleGVjdXRpbmcgZW5xdWV1ZWQgdGFza3Mgd2l0aGluIGNvbmN1cnJlbmN5IGxpbWl0LiBObyBuZWVkIHRvIGNhbGwgdGhpcyBpZiBxdWV1ZSBpcyBub3QgcGF1c2VkICh2aWEgYG9wdGlvbnMuYXV0b1N0YXJ0ID0gZmFsc2VgIG9yIGJ5IGAucGF1c2UoKWAgbWV0aG9kLilcbiAgICAqL1xuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzUGF1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcm9jZXNzUXVldWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFB1dCBxdWV1ZSBleGVjdXRpb24gb24gaG9sZC5cbiAgICAqL1xuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIENsZWFyIHRoZSBxdWV1ZS5cbiAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IG5ldyB0aGlzLl9xdWV1ZUNsYXNzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMuIFVzZWZ1bCBpZiB5b3UgZm9yIGV4YW1wbGUgYWRkIGFkZGl0aW9uYWwgaXRlbXMgYXQgYSBsYXRlciB0aW1lLlxuXG4gICAgQHJldHVybnMgQSBwcm9taXNlIHRoYXQgc2V0dGxlcyB3aGVuIHRoZSBxdWV1ZSBiZWNvbWVzIGVtcHR5LlxuICAgICovXG4gICAgYXN5bmMgb25FbXB0eSgpIHtcbiAgICAgICAgLy8gSW5zdGFudGx5IHJlc29sdmUgaWYgdGhlIHF1ZXVlIGlzIGVtcHR5XG4gICAgICAgIGlmICh0aGlzLl9xdWV1ZS5zaXplID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdSZXNvbHZlID0gdGhpcy5fcmVzb2x2ZUVtcHR5O1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZUVtcHR5ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nUmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZGlmZmVyZW5jZSB3aXRoIGAub25FbXB0eWAgaXMgdGhhdCBgLm9uSWRsZWAgZ3VhcmFudGVlcyB0aGF0IGFsbCB3b3JrIGZyb20gdGhlIHF1ZXVlIGhhcyBmaW5pc2hlZC4gYC5vbkVtcHR5YCBtZXJlbHkgc2lnbmFscyB0aGF0IHRoZSBxdWV1ZSBpcyBlbXB0eSwgYnV0IGl0IGNvdWxkIG1lYW4gdGhhdCBzb21lIHByb21pc2VzIGhhdmVuJ3QgY29tcGxldGVkIHlldC5cblxuICAgIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHNldHRsZXMgd2hlbiB0aGUgcXVldWUgYmVjb21lcyBlbXB0eSwgYW5kIGFsbCBwcm9taXNlcyBoYXZlIGNvbXBsZXRlZDsgYHF1ZXVlLnNpemUgPT09IDAgJiYgcXVldWUucGVuZGluZyA9PT0gMGAuXG4gICAgKi9cbiAgICBhc3luYyBvbklkbGUoKSB7XG4gICAgICAgIC8vIEluc3RhbnRseSByZXNvbHZlIGlmIG5vbmUgcGVuZGluZyBhbmQgaWYgbm90aGluZyBlbHNlIGlzIHF1ZXVlZFxuICAgICAgICBpZiAodGhpcy5fcGVuZGluZ0NvdW50ID09PSAwICYmIHRoaXMuX3F1ZXVlLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1Jlc29sdmUgPSB0aGlzLl9yZXNvbHZlSWRsZTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVJZGxlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nUmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBTaXplIG9mIHRoZSBxdWV1ZS5cbiAgICAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVldWUuc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2l6ZSBvZiB0aGUgcXVldWUsIGZpbHRlcmVkIGJ5IHRoZSBnaXZlbiBvcHRpb25zLlxuXG4gICAgRm9yIGV4YW1wbGUsIHRoaXMgY2FuIGJlIHVzZWQgdG8gZmluZCB0aGUgbnVtYmVyIG9mIGl0ZW1zIHJlbWFpbmluZyBpbiB0aGUgcXVldWUgd2l0aCBhIHNwZWNpZmljIHByaW9yaXR5IGxldmVsLlxuICAgICovXG4gICAgc2l6ZUJ5KG9wdGlvbnMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vbm8tZm4tcmVmZXJlbmNlLWluLWl0ZXJhdG9yXG4gICAgICAgIHJldHVybiB0aGlzLl9xdWV1ZS5maWx0ZXIob3B0aW9ucykubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICBOdW1iZXIgb2YgcGVuZGluZyBwcm9taXNlcy5cbiAgICAqL1xuICAgIGdldCBwZW5kaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0NvdW50O1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBxdWV1ZSBpcyBjdXJyZW50bHkgcGF1c2VkLlxuICAgICovXG4gICAgZ2V0IGlzUGF1c2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNQYXVzZWQ7XG4gICAgfVxuICAgIGdldCB0aW1lb3V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGltZW91dDtcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IHRoZSB0aW1lb3V0IGZvciBmdXR1cmUgb3BlcmF0aW9ucy5cbiAgICAqL1xuICAgIHNldCB0aW1lb3V0KG1pbGxpc2Vjb25kcykge1xuICAgICAgICB0aGlzLl90aW1lb3V0ID0gbWlsbGlzZWNvbmRzO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFBRdWV1ZTtcbiIsICIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsICJpbXBvcnQge1xuICBBcHAsXG4gIC8vIE1hcmtkb3duVmlldyxcbiAgTW9kYWwsXG4gIC8vIE5vdGljZSxcbiAgUGx1Z2luLFxufSBmcm9tIFwib2JzaWRpYW5cIjtcblxuaW1wb3J0IHtcbiAgREVGQVVMVF9TRVRUSU5HUyxcbiAgdHlwZSBPYnNpZGlhbkNoYXRHUFRQbHVnaW5TZXR0aW5ncyxcbn0gZnJvbSBcIi4vc2V0dGluZ3NcIjtcbmltcG9ydCBTZXR0aW5nVGFiIGZyb20gXCIuL1NldHRpbmdUYWJcIjtcbmltcG9ydCB7IGNoYXQsIHVwZGF0ZUxMTSB9IGZyb20gXCIuL2xsbVwiO1xuaW1wb3J0IHN0b3JlIGZyb20gXCIuL3N0b3JlXCI7XG5pbXBvcnQgQ29tcG9uZW50IGZyb20gXCIuL0NvbXBvbmVudC5zdmVsdGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT2JzaWRpYW5DaGF0R1BUUGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcbiAgZGVjbGFyZSBzZXR0aW5nczogT2JzaWRpYW5DaGF0R1BUUGx1Z2luU2V0dGluZ3M7XG4gIGRlY2xhcmUgc3RhdHVzQmFySXRlbUVsOiBIVE1MRWxlbWVudDtcblxuICBhc3luYyBvbmxvYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcbiAgICB0aGlzLmFkZFNldHRpbmdUYWIobmV3IFNldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcblxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogXCJzdW1tYXJ5XCIsXG4gICAgICBuYW1lOiBcIlN1bW1hcnkgQ3VycmVudCBOb3RlXCIsXG4gICAgICBhc3luYyBlZGl0b3JDYWxsYmFjayhlZGl0b3IsIF92aWV3KSB7XG4gICAgICAgIGVkaXRvci5yZXBsYWNlU2VsZWN0aW9uKFwiPiBcIik7XG4gICAgICAgIGNvbnN0IGNodW5rcyA9IGNoYXQoZWRpdG9yLmdldFZhbHVlKCkpO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNvbnRlbnQgb2YgY2h1bmtzKSB7XG4gICAgICAgICAgZWRpdG9yLnJlcGxhY2VTZWxlY3Rpb24oU3RyaW5nKGNvbnRlbnQpKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8qXG4gICAgICBjaGVja0NhbGxiYWNrOiAoY2hlY2tpbmcpID0+IHtcbiAgICAgICAgY29uc3QgbWFya2Rvd25WaWV3ID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoXG4gICAgICAgICAgTWFya2Rvd25WaWV3LFxuICAgICAgICApO1xuICAgICAgICBpZiAobWFya2Rvd25WaWV3KSB7XG4gICAgICAgICAgaWYgKCFjaGVja2luZykge1xuICAgICAgICAgICAgbmV3IENoYXRNb2RhbCh0aGlzLmFwcCwgdGhpcywgbWFya2Rvd25WaWV3LmNvbnRlbnRFbC50ZXh0Q29udGVudClcbiAgICAgICAgICAgICAgLm9wZW4oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAqL1xuICAgIH0pO1xuICB9XG5cbiAgb251bmxvYWQoKSB7XG4gIH1cblxuICB1cGRhdGVTdGF0dXMoKSB7XG4gICAgdXBkYXRlTExNKHRoaXMuc2V0dGluZ3MpO1xuICAgIHRoaXMuc3RhdHVzQmFySXRlbUVsLnNldFRleHQodGhpcy5zZXR0aW5ncy5PUEVOQUlfQVBJX0tFWSA/IFwib25cIiA6IFwib2ZmXCIpO1xuICB9XG5cbiAgYXN5bmMgbG9hZFNldHRpbmdzKCkge1xuICAgIHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuICAgIHRoaXMuc3RhdHVzQmFySXRlbUVsID0gdGhpcy5hZGRTdGF0dXNCYXJJdGVtKCk7XG4gICAgdGhpcy51cGRhdGVTdGF0dXMoKTtcbiAgfVxuXG4gIGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcbiAgICB0aGlzLnVwZGF0ZVN0YXR1cygpO1xuICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG4gIH1cbn1cblxuY2xhc3MgQ2hhdE1vZGFsIGV4dGVuZHMgTW9kYWwge1xuICBkZWNsYXJlIGNvbXBvbmVudDogQ29tcG9uZW50O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGFwcDogQXBwLFxuICAgIHB1YmxpYyBwbHVnaW46IE9ic2lkaWFuQ2hhdEdQVFBsdWdpbixcbiAgICBwdWJsaWMgY29udGVudDogc3RyaW5nIHwgbnVsbCxcbiAgKSB7XG4gICAgc3VwZXIoYXBwKTtcbiAgfVxuXG4gIG9uT3BlbigpIHtcbiAgICBpZiAodGhpcy5jb250ZW50KSByZXR1cm47XG5cbiAgICBzdG9yZS5wbHVnaW4uc2V0KHRoaXMucGx1Z2luKTtcbiAgICB0aGlzLmNvbXBvbmVudCA9IG5ldyBDb21wb25lbnQoe1xuICAgICAgdGFyZ2V0OiB0aGlzLmNvbnRlbnRFbCxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGNvbnRlbnQ6IHRoaXMuY29udGVudCxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBvbkNsb3NlKCkge1xuICAgIHRoaXMuY29tcG9uZW50LiRkZXN0cm95KCk7XG4gIH1cbn1cbiIsICJleHBvcnQgaW50ZXJmYWNlIE9ic2lkaWFuQ2hhdEdQVFBsdWdpblNldHRpbmdzIHtcbiAgT1BFTkFJX0FQSV9LRVk6IHN0cmluZztcbiAgT1BFTkFJX0FQSV9CQVNFOiBzdHJpbmc7XG5cbiAgTEFOR0NIQUlOX1RSQUNJTkdfVjI6IGJvb2xlYW47XG4gIExBTkdDSEFJTl9BUElfS0VZOiBzdHJpbmc7XG4gIExBTkdDSEFJTl9QUk9KRUNUOiBzdHJpbmc7XG4gIExBTkdDSEFJTl9FTkRQT0lOVDogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9TRVRUSU5HUzogT2JzaWRpYW5DaGF0R1BUUGx1Z2luU2V0dGluZ3MgPSB7XG4gIE9QRU5BSV9BUElfS0VZOiBcIlwiLFxuICBPUEVOQUlfQVBJX0JBU0U6IFwiaHR0cHM6Ly9hcGkub3BlbmFpLmNvbS92MVwiLFxuXG4gIExBTkdDSEFJTl9UUkFDSU5HX1YyOiBmYWxzZSxcbiAgTEFOR0NIQUlOX0FQSV9LRVk6IFwiXCIsXG4gIExBTkdDSEFJTl9QUk9KRUNUOiBcImRlZmF1bHRcIixcbiAgTEFOR0NIQUlOX0VORFBPSU5UOiBcImh0dHBzOi8vYXBpLnNtaXRoLmxhbmdjaGFpbi5jb21cIixcbn07XG4iLCAiaW1wb3J0IHsgdHlwZSBBcHAsIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB0eXBlIE9ic2lkaWFuQ2hhdEdQVFBsdWdpbiBmcm9tIFwiLi9tYWluXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNldHRpbmdUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcbiAgcGx1Z2luOiBPYnNpZGlhbkNoYXRHUFRQbHVnaW47XG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogT2JzaWRpYW5DaGF0R1BUUGx1Z2luKSB7XG4gICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICB9XG5cbiAgZGlzcGxheSgpIHtcbiAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIk9QRU5BSV9BUElfS0VZXCIpXG4gICAgICAuc2V0RGVzYyhcImUuZy4gc2stXCIpXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cbiAgICAgICAgdGV4dFxuICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihcIk9QRU5BSV9BUElfS0VZXCIpXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLk9QRU5BSV9BUElfS0VZKVxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLk9QRU5BSV9BUElfS0VZID0gdmFsdWU7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICB9KVxuICAgICAgKTtcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKFwiT1BFTkFJX0FQSV9CQVNFXCIpXG4gICAgICAuc2V0RGVzYyhcImUuZy4gaHR0cHM6Ly9hcGkub3BlbmFpLmNvbS92MVwiKVxuICAgICAgLmFkZFRleHQoKHRleHQpID0+XG4gICAgICAgIHRleHRcbiAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoXCJPUEVOQUlfQVBJX0JBU0VcIilcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuT1BFTkFJX0FQSV9CQVNFKVxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLk9QRU5BSV9BUElfQkFTRSA9IHZhbHVlO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKFwiTEFOR0NIQUlOX1RSQUNJTkdfVjJcIilcbiAgICAgIC5zZXREZXNjKFwiZS5nLiBodHRwczovL2FwaS5vcGVuYWkuY29tL3YxXCIpXG4gICAgICAuYWRkVG9nZ2xlKCh0ZXh0KSA9PlxuICAgICAgICB0ZXh0XG4gICAgICAgICAgLnNldFRvb2x0aXAoXCJMQU5HQ0hBSU5fVFJBQ0lOR19WMlwiKVxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5MQU5HQ0hBSU5fVFJBQ0lOR19WMilcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5MQU5HQ0hBSU5fVFJBQ0lOR19WMiA9IHZhbHVlO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgfSlcbiAgICAgICk7XG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIkxBTkdDSEFJTl9BUElfS0VZXCIpXG4gICAgICAuc2V0RGVzYyhcImUuZy4gbHNfX1wiKVxuICAgICAgLmFkZFRleHQoKHRleHQpID0+XG4gICAgICAgIHRleHRcbiAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoXCJMQU5HQ0hBSU5fQVBJX0tFWVwiKVxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5MQU5HQ0hBSU5fQVBJX0tFWSlcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5MQU5HQ0hBSU5fQVBJX0tFWSA9IHZhbHVlO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgfSlcbiAgICAgICk7XG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIkxBTkdDSEFJTl9QUk9KRUNUXCIpXG4gICAgICAuc2V0RGVzYyhcImUuZy4gZGVmYXVsdFwiKVxuICAgICAgLmFkZFRleHQoKHRleHQpID0+XG4gICAgICAgIHRleHRcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuTEFOR0NIQUlOX1BST0pFQ1QpXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuTEFOR0NIQUlOX1BST0pFQ1QgPSB2YWx1ZTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgIH0pXG4gICAgICApO1xuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgLnNldE5hbWUoXCJMQU5HQ0hBSU5fRU5EUE9JTlRcIilcbiAgICAgIC5zZXREZXNjKFwiZS5nLiBodHRwczovL2FwaS5zbWl0aC5sYW5nY2hhaW4uY29tXCIpXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cbiAgICAgICAgdGV4dC5zZXRQbGFjZWhvbGRlcihcIkxBTkdDSEFJTl9FTkRQT0lOVFwiKVxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5MQU5HQ0hBSU5fRU5EUE9JTlQpXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuTEFOR0NIQUlOX0VORFBPSU5UID0gdmFsdWU7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICB9KVxuICAgICAgKTtcbiAgfVxufVxuIiwgImV4cG9ydCBjb25zdCBpc0Jyb3dzZXIgPSAoKSA9PiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG5leHBvcnQgY29uc3QgaXNXZWJXb3JrZXIgPSAoKSA9PiB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIiAmJlxuICAgIGdsb2JhbFRoaXMuY29uc3RydWN0b3IgJiZcbiAgICBnbG9iYWxUaGlzLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGVcIjtcbmV4cG9ydCBjb25zdCBpc0pzRG9tID0gKCkgPT4gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Lm5hbWUgPT09IFwibm9kZWpzXCIpIHx8XG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoXCJOb2RlLmpzXCIpIHx8XG4gICAgICAgICAgICBuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwianNkb21cIikpKTtcbi8vIFN1cGFiYXNlIEVkZ2UgRnVuY3Rpb24gcHJvdmlkZXMgYSBgRGVub2AgZ2xvYmFsIG9iamVjdFxuLy8gd2l0aG91dCBgdmVyc2lvbmAgcHJvcGVydHlcbmV4cG9ydCBjb25zdCBpc0Rlbm8gPSAoKSA9PiB0eXBlb2YgRGVubyAhPT0gXCJ1bmRlZmluZWRcIjtcbi8vIE1hcmsgbm90LWFzLW5vZGUgaWYgaW4gU3VwYWJhc2UgRWRnZSBGdW5jdGlvblxuZXhwb3J0IGNvbnN0IGlzTm9kZSA9ICgpID0+IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgIWlzRGVubygpO1xuZXhwb3J0IGNvbnN0IGdldEVudiA9ICgpID0+IHtcbiAgICBsZXQgZW52O1xuICAgIGlmIChpc0Jyb3dzZXIoKSkge1xuICAgICAgICBlbnYgPSBcImJyb3dzZXJcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNOb2RlKCkpIHtcbiAgICAgICAgZW52ID0gXCJub2RlXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzV2ViV29ya2VyKCkpIHtcbiAgICAgICAgZW52ID0gXCJ3ZWJ3b3JrZXJcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNKc0RvbSgpKSB7XG4gICAgICAgIGVudiA9IFwianNkb21cIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNEZW5vKCkpIHtcbiAgICAgICAgZW52ID0gXCJkZW5vXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbnYgPSBcIm90aGVyXCI7XG4gICAgfVxuICAgIHJldHVybiBlbnY7XG59O1xubGV0IHJ1bnRpbWVFbnZpcm9ubWVudDtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSdW50aW1lRW52aXJvbm1lbnQoKSB7XG4gICAgaWYgKHJ1bnRpbWVFbnZpcm9ubWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGVudiA9IGdldEVudigpO1xuICAgICAgICBydW50aW1lRW52aXJvbm1lbnQgPSB7XG4gICAgICAgICAgICBsaWJyYXJ5OiBcImxhbmdjaGFpbi1qc1wiLFxuICAgICAgICAgICAgcnVudGltZTogZW52LFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcnVudGltZUVudmlyb25tZW50O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEVudmlyb25tZW50VmFyaWFibGUobmFtZSkge1xuICAgIC8vIENlcnRhaW4gRGVubyBzZXR1cHMgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB5b3UgdHJ5IHRvIGFjY2VzcyBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbGFuZ2NoYWluLWFpL2xhbmdjaGFpbmpzL2lzc3Vlcy8xNDEyXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9jZXNzLWVudlxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Py5bbmFtZV1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbiIsICIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiBJbiB0aGUgYnJvd3NlciB3ZSB0aGVyZWZvcmVcbi8vIHJlcXVpcmUgdGhlIGNyeXB0byBBUEkgYW5kIGRvIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGZhbGxiYWNrIHRvIGxvd2VyIHF1YWxpdHkgcmFuZG9tIG51bWJlclxuLy8gZ2VuZXJhdG9ycyAobGlrZSBNYXRoLnJhbmRvbSgpKS5cbmxldCBnZXRSYW5kb21WYWx1ZXM7XG5jb25zdCBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJuZygpIHtcbiAgLy8gbGF6eSBsb2FkIHNvIHRoYXQgZW52aXJvbm1lbnRzIHRoYXQgbmVlZCB0byBwb2x5ZmlsbCBoYXZlIGEgY2hhbmNlIHRvIGRvIHNvXG4gIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gZ2V0UmFuZG9tVmFsdWVzIG5lZWRzIHRvIGJlIGludm9rZWQgaW4gYSBjb250ZXh0IHdoZXJlIFwidGhpc1wiIGlzIGEgQ3J5cHRvIGltcGxlbWVudGF0aW9uLlxuICAgIGdldFJhbmRvbVZhbHVlcyA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0byk7XG5cbiAgICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKCkgbm90IHN1cHBvcnRlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCNnZXRyYW5kb212YWx1ZXMtbm90LXN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBnZXRSYW5kb21WYWx1ZXMocm5kczgpO1xufSIsICJleHBvcnQgZGVmYXVsdCAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7IiwgImltcG9ydCBSRUdFWCBmcm9tICcuL3JlZ2V4LmpzJztcblxuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIFJFR0VYLnRlc3QodXVpZCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRlOyIsICJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG4vKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cblxuY29uc3QgYnl0ZVRvSGV4ID0gW107XG5cbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnNsaWNlKDEpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuc2FmZVN0cmluZ2lmeShhcnIsIG9mZnNldCA9IDApIHtcbiAgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcbiAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG4gIHJldHVybiBieXRlVG9IZXhbYXJyW29mZnNldCArIDBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDNdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA1XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDZdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgN11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA4XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDldXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTNdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTVdXTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KGFyciwgb2Zmc2V0ID0gMCkge1xuICBjb25zdCB1dWlkID0gdW5zYWZlU3RyaW5naWZ5KGFyciwgb2Zmc2V0KTsgLy8gQ29uc2lzdGVuY3kgY2hlY2sgZm9yIHZhbGlkIFVVSUQuICBJZiB0aGlzIHRocm93cywgaXQncyBsaWtlbHkgZHVlIHRvIG9uZVxuICAvLyBvZiB0aGUgZm9sbG93aW5nOlxuICAvLyAtIE9uZSBvciBtb3JlIGlucHV0IGFycmF5IHZhbHVlcyBkb24ndCBtYXAgdG8gYSBoZXggb2N0ZXQgKGxlYWRpbmcgdG9cbiAgLy8gXCJ1bmRlZmluZWRcIiBpbiB0aGUgdXVpZClcbiAgLy8gLSBJbnZhbGlkIGlucHV0IHZhbHVlcyBmb3IgdGhlIFJGQyBgdmVyc2lvbmAgb3IgYHZhcmlhbnRgIGZpZWxkc1xuXG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIHV1aWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ2lmeTsiLCAiY29uc3QgcmFuZG9tVVVJRCA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5yYW5kb21VVUlEICYmIGNyeXB0by5yYW5kb21VVUlELmJpbmQoY3J5cHRvKTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgcmFuZG9tVVVJRFxufTsiLCAiaW1wb3J0IG5hdGl2ZSBmcm9tICcuL25hdGl2ZS5qcyc7XG5pbXBvcnQgcm5nIGZyb20gJy4vcm5nLmpzJztcbmltcG9ydCB7IHVuc2FmZVN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgaWYgKG5hdGl2ZS5yYW5kb21VVUlEICYmICFidWYgJiYgIW9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmF0aXZlLnJhbmRvbVVVSUQoKTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTsgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7IC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuXG4gIGlmIChidWYpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgcmV0dXJuIHVuc2FmZVN0cmluZ2lmeShybmRzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdjQ7IiwgImltcG9ydCBzbmFrZUNhc2UgZnJvbSBcImRlY2FtZWxpemVcIjtcbmltcG9ydCBjYW1lbENhc2UgZnJvbSBcImNhbWVsY2FzZVwiO1xuZXhwb3J0IGZ1bmN0aW9uIGtleVRvSnNvbihrZXksIG1hcCkge1xuICAgIHJldHVybiBtYXA/LltrZXldIHx8IHNuYWtlQ2FzZShrZXkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGtleUZyb21Kc29uKGtleSwgbWFwKSB7XG4gICAgcmV0dXJuIG1hcD8uW2tleV0gfHwgY2FtZWxDYXNlKGtleSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFwS2V5cyhmaWVsZHMsIG1hcHBlciwgbWFwKSB7XG4gICAgY29uc3QgbWFwcGVkID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZmllbGRzKSB7XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duKGZpZWxkcywga2V5KSkge1xuICAgICAgICAgICAgbWFwcGVkW21hcHBlcihrZXksIG1hcCldID0gZmllbGRzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcHBlZDtcbn1cbiIsICJpbXBvcnQgeyBrZXlUb0pzb24sIG1hcEtleXMgfSBmcm9tIFwiLi9tYXBfa2V5cy5qc1wiO1xuZnVuY3Rpb24gc2hhbGxvd0NvcHkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKSA/IFsuLi5vYmpdIDogeyAuLi5vYmogfTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VTZWNyZXRzKHJvb3QsIHNlY3JldHNNYXApIHtcbiAgICBjb25zdCByZXN1bHQgPSBzaGFsbG93Q29weShyb290KTtcbiAgICBmb3IgKGNvbnN0IFtwYXRoLCBzZWNyZXRJZF0gb2YgT2JqZWN0LmVudHJpZXMoc2VjcmV0c01hcCkpIHtcbiAgICAgICAgY29uc3QgW2xhc3QsIC4uLnBhcnRzUmV2ZXJzZV0gPSBwYXRoLnNwbGl0KFwiLlwiKS5yZXZlcnNlKCk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGxldCBjdXJyZW50ID0gcmVzdWx0O1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHNSZXZlcnNlLnJldmVyc2UoKSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRbcGFydF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFtwYXJ0XSA9IHNoYWxsb3dDb3B5KGN1cnJlbnRbcGFydF0pO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbcGFydF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRbbGFzdF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY3VycmVudFtsYXN0XSA9IHtcbiAgICAgICAgICAgICAgICBsYzogMSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcInNlY3JldFwiLFxuICAgICAgICAgICAgICAgIGlkOiBbc2VjcmV0SWRdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBHZXQgYSB1bmlxdWUgbmFtZSBmb3IgdGhlIG1vZHVsZSwgcmF0aGVyIHRoYW4gcGFyZW50IGNsYXNzIGltcGxlbWVudGF0aW9ucy5cbiAqIFNob3VsZCBub3QgYmUgc3ViY2xhc3NlZCwgc3ViY2xhc3MgbGNfbmFtZSBhYm92ZSBpbnN0ZWFkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2xjX3VuaXF1ZV9uYW1lKFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuc2VyaWFsaXphYmxlQ2xhc3MpIHtcbiAgICAvLyBcInN1cGVyXCIgaGVyZSB3b3VsZCByZWZlciB0byB0aGUgcGFyZW50IGNsYXNzIG9mIFNlcmlhbGl6YWJsZSxcbiAgICAvLyB3aGVuIHdlIHdhbnQgdGhlIHBhcmVudCBjbGFzcyBvZiB0aGUgbW9kdWxlIGFjdHVhbGx5IGNhbGxpbmcgdGhpcyBtZXRob2QuXG4gICAgY29uc3QgcGFyZW50Q2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc2VyaWFsaXphYmxlQ2xhc3MpO1xuICAgIGNvbnN0IGxjTmFtZUlzU3ViY2xhc3NlZCA9IHR5cGVvZiBzZXJpYWxpemFibGVDbGFzcy5sY19uYW1lID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgKHR5cGVvZiBwYXJlbnRDbGFzcy5sY19uYW1lICE9PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAgICAgICAgIHNlcmlhbGl6YWJsZUNsYXNzLmxjX25hbWUoKSAhPT0gcGFyZW50Q2xhc3MubGNfbmFtZSgpKTtcbiAgICBpZiAobGNOYW1lSXNTdWJjbGFzc2VkKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemFibGVDbGFzcy5sY19uYW1lKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXphYmxlQ2xhc3MubmFtZTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU2VyaWFsaXphYmxlIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgc2VyaWFsaXphYmxlLiBPdmVycmlkZSB0byBwcm92aWRlIGFuIGFsaWFzIG9yXG4gICAgICogdG8gcHJlc2VydmUgdGhlIHNlcmlhbGl6ZWQgbW9kdWxlIG5hbWUgaW4gbWluaWZpZWQgZW52aXJvbm1lbnRzLlxuICAgICAqXG4gICAgICogSW1wbGVtZW50ZWQgYXMgYSBzdGF0aWMgbWV0aG9kIHRvIHN1cHBvcnQgbG9hZGluZyBsb2dpYy5cbiAgICAgKi9cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGZpbmFsIHNlcmlhbGl6ZWQgaWRlbnRpZmllciBmb3IgdGhlIG1vZHVsZS5cbiAgICAgKi9cbiAgICBnZXQgbGNfaWQoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi50aGlzLmxjX25hbWVzcGFjZSxcbiAgICAgICAgICAgIGdldF9sY191bmlxdWVfbmFtZSh0aGlzLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBtYXAgb2Ygc2VjcmV0cywgd2hpY2ggd2lsbCBiZSBvbWl0dGVkIGZyb20gc2VyaWFsaXphdGlvbi5cbiAgICAgKiBLZXlzIGFyZSBwYXRocyB0byB0aGUgc2VjcmV0IGluIGNvbnN0cnVjdG9yIGFyZ3MsIGUuZy4gXCJmb28uYmFyLmJhelwiLlxuICAgICAqIFZhbHVlcyBhcmUgdGhlIHNlY3JldCBpZHMsIHdoaWNoIHdpbGwgYmUgdXNlZCB3aGVuIGRlc2VyaWFsaXppbmcuXG4gICAgICovXG4gICAgZ2V0IGxjX3NlY3JldHMoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbWFwIG9mIGFkZGl0aW9uYWwgYXR0cmlidXRlcyB0byBtZXJnZSB3aXRoIGNvbnN0cnVjdG9yIGFyZ3MuXG4gICAgICogS2V5cyBhcmUgdGhlIGF0dHJpYnV0ZSBuYW1lcywgZS5nLiBcImZvb1wiLlxuICAgICAqIFZhbHVlcyBhcmUgdGhlIGF0dHJpYnV0ZSB2YWx1ZXMsIHdoaWNoIHdpbGwgYmUgc2VyaWFsaXplZC5cbiAgICAgKiBUaGVzZSBhdHRyaWJ1dGVzIG5lZWQgdG8gYmUgYWNjZXB0ZWQgYnkgdGhlIGNvbnN0cnVjdG9yIGFzIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBnZXQgbGNfYXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBtYXAgb2YgYWxpYXNlcyBmb3IgY29uc3RydWN0b3IgYXJncy5cbiAgICAgKiBLZXlzIGFyZSB0aGUgYXR0cmlidXRlIG5hbWVzLCBlLmcuIFwiZm9vXCIuXG4gICAgICogVmFsdWVzIGFyZSB0aGUgYWxpYXMgdGhhdCB3aWxsIHJlcGxhY2UgdGhlIGtleSBpbiBzZXJpYWxpemF0aW9uLlxuICAgICAqIFRoaXMgaXMgdXNlZCB0byBlZy4gbWFrZSBhcmd1bWVudCBuYW1lcyBtYXRjaCBQeXRob24uXG4gICAgICovXG4gICAgZ2V0IGxjX2FsaWFzZXMoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGt3YXJncywgLi4uX2FyZ3MpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfa3dhcmdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGNfa3dhcmdzID0ga3dhcmdzIHx8IHt9O1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGlmICghdGhpcy5sY19zZXJpYWxpemFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvSlNPTk5vdEltcGxlbWVudGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgIHRoaXMubGNfa3dhcmdzIGluc3RhbmNlb2YgU2VyaWFsaXphYmxlIHx8XG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5sY19rd2FyZ3MgIT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodGhpcy5sY19rd2FyZ3MpKSB7XG4gICAgICAgICAgICAvLyBXZSBkbyBub3Qgc3VwcG9ydCBzZXJpYWxpemF0aW9uIG9mIGNsYXNzZXMgd2l0aCBhcmcgbm90IGEgUE9KT1xuICAgICAgICAgICAgLy8gSSdtIGF3YXJlIHRoZSBjaGVjayBhYm92ZSBpc24ndCBhcyBzdHJpY3QgYXMgaXQgY291bGQgYmVcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvSlNPTk5vdEltcGxlbWVudGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxpYXNlcyA9IHt9O1xuICAgICAgICBjb25zdCBzZWNyZXRzID0ge307XG4gICAgICAgIGNvbnN0IGt3YXJncyA9IE9iamVjdC5rZXlzKHRoaXMubGNfa3dhcmdzKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IGtleSBpbiB0aGlzID8gdGhpc1trZXldIDogdGhpcy5sY19rd2FyZ3Nba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgLy8gZ2V0IHNlY3JldHMsIGF0dHJpYnV0ZXMgYW5kIGFsaWFzZXMgZnJvbSBhbGwgc3VwZXJjbGFzc2VzXG4gICAgICAgIGZvciAoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICBsZXQgY3VycmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKTsgY3VycmVudDsgY3VycmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjdXJyZW50KSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihhbGlhc2VzLCBSZWZsZWN0LmdldChjdXJyZW50LCBcImxjX2FsaWFzZXNcIiwgdGhpcykpO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzZWNyZXRzLCBSZWZsZWN0LmdldChjdXJyZW50LCBcImxjX3NlY3JldHNcIiwgdGhpcykpO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihrd2FyZ3MsIFJlZmxlY3QuZ2V0KGN1cnJlbnQsIFwibGNfYXR0cmlidXRlc1wiLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW5jbHVkZSBhbGwgc2VjcmV0cyB1c2VkLCBldmVuIGlmIG5vdCBpbiBrd2FyZ3MsXG4gICAgICAgIC8vIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBzZW50aW5lbCB2YWx1ZSBpbiByZXBsYWNlU2VjcmV0c1xuICAgICAgICBPYmplY3Qua2V5cyhzZWNyZXRzKS5mb3JFYWNoKChrZXlQYXRoKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXMsIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGxldCByZWFkID0gdGhpcztcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBsZXQgd3JpdGUgPSBrd2FyZ3M7XG4gICAgICAgICAgICBjb25zdCBbbGFzdCwgLi4ucGFydHNSZXZlcnNlXSA9IGtleVBhdGguc3BsaXQoXCIuXCIpLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHBhcnRzUmV2ZXJzZS5yZXZlcnNlKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gcmVhZCkgfHwgcmVhZFtrZXldID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gd3JpdGUpIHx8IHdyaXRlW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlYWRba2V5XSA9PT0gXCJvYmplY3RcIiAmJiByZWFkW2tleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVhZFtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVba2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlYWQgPSByZWFkW2tleV07XG4gICAgICAgICAgICAgICAgd3JpdGUgPSB3cml0ZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3QgaW4gcmVhZCAmJiByZWFkW2xhc3RdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB3cml0ZVtsYXN0XSA9IHdyaXRlW2xhc3RdIHx8IHJlYWRbbGFzdF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGM6IDEsXG4gICAgICAgICAgICB0eXBlOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICBpZDogdGhpcy5sY19pZCxcbiAgICAgICAgICAgIGt3YXJnczogbWFwS2V5cyhPYmplY3Qua2V5cyhzZWNyZXRzKS5sZW5ndGggPyByZXBsYWNlU2VjcmV0cyhrd2FyZ3MsIHNlY3JldHMpIDoga3dhcmdzLCBrZXlUb0pzb24sIGFsaWFzZXMpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0b0pTT05Ob3RJbXBsZW1lbnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxjOiAxLFxuICAgICAgICAgICAgdHlwZTogXCJub3RfaW1wbGVtZW50ZWRcIixcbiAgICAgICAgICAgIGlkOiB0aGlzLmxjX2lkLFxuICAgICAgICB9O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgKiBhcyB1dWlkIGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyBTZXJpYWxpemFibGUsIGdldF9sY191bmlxdWVfbmFtZSwgfSBmcm9tIFwiLi4vbG9hZC9zZXJpYWxpemFibGUuanNcIjtcbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgdGhhdCBwcm92aWRlcyBhIHNldCBvZiBvcHRpb25hbCBtZXRob2RzIHRoYXQgY2FuIGJlXG4gKiBvdmVycmlkZGVuIGluIGRlcml2ZWQgY2xhc3NlcyB0byBoYW5kbGUgdmFyaW91cyBldmVudHMgZHVyaW5nIHRoZVxuICogZXhlY3V0aW9uIG9mIGEgTGFuZ0NoYWluIGFwcGxpY2F0aW9uLlxuICovXG5jbGFzcyBCYXNlQ2FsbGJhY2tIYW5kbGVyTWV0aG9kc0NsYXNzIHtcbn1cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgY3JlYXRpbmcgY2FsbGJhY2sgaGFuZGxlcnMgaW4gdGhlIExhbmdDaGFpblxuICogZnJhbWV3b3JrLiBJdCBwcm92aWRlcyBhIHNldCBvZiBvcHRpb25hbCBtZXRob2RzIHRoYXQgY2FuIGJlIG92ZXJyaWRkZW5cbiAqIGluIGRlcml2ZWQgY2xhc3NlcyB0byBoYW5kbGUgdmFyaW91cyBldmVudHMgZHVyaW5nIHRoZSBleGVjdXRpb24gb2YgYVxuICogTGFuZ0NoYWluIGFwcGxpY2F0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgQmFzZUNhbGxiYWNrSGFuZGxlciBleHRlbmRzIEJhc2VDYWxsYmFja0hhbmRsZXJNZXRob2RzQ2xhc3Mge1xuICAgIGdldCBsY19uYW1lc3BhY2UoKSB7XG4gICAgICAgIHJldHVybiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcImNhbGxiYWNrc1wiLCB0aGlzLm5hbWVdO1xuICAgIH1cbiAgICBnZXQgbGNfc2VjcmV0cygpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IGxjX2F0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBsY19hbGlhc2VzKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgc2VyaWFsaXphYmxlLiBPdmVycmlkZSB0byBwcm92aWRlIGFuIGFsaWFzIG9yXG4gICAgICogdG8gcHJlc2VydmUgdGhlIHNlcmlhbGl6ZWQgbW9kdWxlIG5hbWUgaW4gbWluaWZpZWQgZW52aXJvbm1lbnRzLlxuICAgICAqXG4gICAgICogSW1wbGVtZW50ZWQgYXMgYSBzdGF0aWMgbWV0aG9kIHRvIHN1cHBvcnQgbG9hZGluZyBsb2dpYy5cbiAgICAgKi9cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGZpbmFsIHNlcmlhbGl6ZWQgaWRlbnRpZmllciBmb3IgdGhlIG1vZHVsZS5cbiAgICAgKi9cbiAgICBnZXQgbGNfaWQoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi50aGlzLmxjX25hbWVzcGFjZSxcbiAgICAgICAgICAgIGdldF9sY191bmlxdWVfbmFtZSh0aGlzLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfa3dhcmdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlnbm9yZUxMTVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlnbm9yZUNoYWluXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWdub3JlQWdlbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZ25vcmVSZXRyaWV2ZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhd2FpdEhhbmRsZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZW52XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Py5MQU5HQ0hBSU5fQ0FMTEJBQ0tTX0JBQ0tHUk9VTkQgIT09IFwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxjX2t3YXJncyA9IGlucHV0IHx8IHt9O1xuICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuaWdub3JlTExNID0gaW5wdXQuaWdub3JlTExNID8/IHRoaXMuaWdub3JlTExNO1xuICAgICAgICAgICAgdGhpcy5pZ25vcmVDaGFpbiA9IGlucHV0Lmlnbm9yZUNoYWluID8/IHRoaXMuaWdub3JlQ2hhaW47XG4gICAgICAgICAgICB0aGlzLmlnbm9yZUFnZW50ID0gaW5wdXQuaWdub3JlQWdlbnQgPz8gdGhpcy5pZ25vcmVBZ2VudDtcbiAgICAgICAgICAgIHRoaXMuaWdub3JlUmV0cmlldmVyID0gaW5wdXQuaWdub3JlUmV0cmlldmVyID8/IHRoaXMuaWdub3JlUmV0cmlldmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gU2VyaWFsaXphYmxlLnByb3RvdHlwZS50b0pTT04uY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgdG9KU09OTm90SW1wbGVtZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiBTZXJpYWxpemFibGUucHJvdG90eXBlLnRvSlNPTk5vdEltcGxlbWVudGVkLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tTWV0aG9kcyhtZXRob2RzKSB7XG4gICAgICAgIGNsYXNzIEhhbmRsZXIgZXh0ZW5kcyBCYXNlQ2FsbGJhY2tIYW5kbGVyIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1dWlkLnY0KClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIG1ldGhvZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSGFuZGxlcigpO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBCYXNlQ2FsbGJhY2tIYW5kbGVyLCB9IGZyb20gXCIuLi9jYWxsYmFja3MvYmFzZS5qc1wiO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIF9jb2VyY2VUb0RpY3QodmFsdWUsIGRlZmF1bHRLZXkpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIlxuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogeyBbZGVmYXVsdEtleV06IHZhbHVlIH07XG59XG5mdW5jdGlvbiBzdHJpcE5vbkFscGhhbnVtZXJpYyhpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9bLTouXS9nLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb0RvdHRlZE9yZGVyRm9ybWF0KGVwb2NoLCBydW5JZCkge1xuICAgIHJldHVybiAoc3RyaXBOb25BbHBoYW51bWVyaWMoYCR7bmV3IERhdGUoZXBvY2gpLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwgLTEpfTAwMFpgKSArXG4gICAgICAgIHJ1bklkKTtcbn1cbmV4cG9ydCBjbGFzcyBCYXNlVHJhY2VyIGV4dGVuZHMgQmFzZUNhbGxiYWNrSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoX2ZpZWxkcykge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5NYXBcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29weSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHN0cmluZ2lmeUVycm9yKGVycm9yKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvci5tZXNzYWdlICsgKGVycm9yPy5zdGFjayA/IGBcXG5cXG4ke2Vycm9yLnN0YWNrfWAgOiBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke2Vycm9yfWA7XG4gICAgfVxuICAgIF9hZGRDaGlsZFJ1bihwYXJlbnRSdW4sIGNoaWxkUnVuKSB7XG4gICAgICAgIHBhcmVudFJ1bi5jaGlsZF9ydW5zLnB1c2goY2hpbGRSdW4pO1xuICAgIH1cbiAgICBhc3luYyBfc3RhcnRUcmFjZShydW4pIHtcbiAgICAgICAgY29uc3QgY3VycmVudERvdHRlZE9yZGVyID0gY29udmVydFRvRG90dGVkT3JkZXJGb3JtYXQocnVuLnN0YXJ0X3RpbWUsIHJ1bi5pZCk7XG4gICAgICAgIGNvbnN0IHN0b3JlZFJ1biA9IHsgLi4ucnVuIH07XG4gICAgICAgIGlmIChzdG9yZWRSdW4ucGFyZW50X3J1bl9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRSdW4gPSB0aGlzLnJ1bk1hcC5nZXQoc3RvcmVkUnVuLnBhcmVudF9ydW5faWQpO1xuICAgICAgICAgICAgaWYgKHBhcmVudFJ1bikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZENoaWxkUnVuKHBhcmVudFJ1biwgc3RvcmVkUnVuKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRSdW4uY2hpbGRfZXhlY3V0aW9uX29yZGVyID0gTWF0aC5tYXgocGFyZW50UnVuLmNoaWxkX2V4ZWN1dGlvbl9vcmRlciwgc3RvcmVkUnVuLmNoaWxkX2V4ZWN1dGlvbl9vcmRlcik7XG4gICAgICAgICAgICAgICAgc3RvcmVkUnVuLnRyYWNlX2lkID0gcGFyZW50UnVuLnRyYWNlX2lkO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRSdW4uZG90dGVkX29yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVkUnVuLmRvdHRlZF9vcmRlciA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFJ1bi5kb3R0ZWRfb3JkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RG90dGVkT3JkZXIsXG4gICAgICAgICAgICAgICAgICAgIF0uam9pbihcIi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gbmF0dXJhbGx5IGZvciBjYWxsYmFja3MgYWRkZWQgd2l0aGluIGEgcnVuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZGVidWcoYFBhcmVudCBydW4gd2l0aCBVVUlEICR7c3RvcmVkUnVuLnBhcmVudF9ydW5faWR9IGhhcyBubyBkb3R0ZWQgb3JkZXIuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIG5hdHVyYWxseSBmb3IgY2FsbGJhY2tzIGFkZGVkIHdpdGhpbiBhIHJ1blxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZGVidWcoXG4gICAgICAgICAgICAgICAgLy8gICBgUGFyZW50IHJ1biB3aXRoIFVVSUQgJHtzdG9yZWRSdW4ucGFyZW50X3J1bl9pZH0gbm90IGZvdW5kLmBcbiAgICAgICAgICAgICAgICAvLyApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RvcmVkUnVuLnRyYWNlX2lkID0gc3RvcmVkUnVuLmlkO1xuICAgICAgICAgICAgc3RvcmVkUnVuLmRvdHRlZF9vcmRlciA9IGN1cnJlbnREb3R0ZWRPcmRlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJ1bk1hcC5zZXQoc3RvcmVkUnVuLmlkLCBzdG9yZWRSdW4pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uUnVuQ3JlYXRlPy4oc3RvcmVkUnVuKTtcbiAgICB9XG4gICAgYXN5bmMgX2VuZFRyYWNlKHJ1bikge1xuICAgICAgICBjb25zdCBwYXJlbnRSdW4gPSBydW4ucGFyZW50X3J1bl9pZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMucnVuTWFwLmdldChydW4ucGFyZW50X3J1bl9pZCk7XG4gICAgICAgIGlmIChwYXJlbnRSdW4pIHtcbiAgICAgICAgICAgIHBhcmVudFJ1bi5jaGlsZF9leGVjdXRpb25fb3JkZXIgPSBNYXRoLm1heChwYXJlbnRSdW4uY2hpbGRfZXhlY3V0aW9uX29yZGVyLCBydW4uY2hpbGRfZXhlY3V0aW9uX29yZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGVyc2lzdFJ1bihydW4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucnVuTWFwLmRlbGV0ZShydW4uaWQpO1xuICAgICAgICBhd2FpdCB0aGlzLm9uUnVuVXBkYXRlPy4ocnVuKTtcbiAgICB9XG4gICAgX2dldEV4ZWN1dGlvbk9yZGVyKHBhcmVudFJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFJ1biA9IHBhcmVudFJ1bklkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ydW5NYXAuZ2V0KHBhcmVudFJ1bklkKTtcbiAgICAgICAgLy8gSWYgYSBydW4gaGFzIG5vIHBhcmVudCB0aGVuIGV4ZWN1dGlvbiBvcmRlciBpcyAxXG4gICAgICAgIGlmICghcGFyZW50UnVuKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50UnVuLmNoaWxkX2V4ZWN1dGlvbl9vcmRlciArIDE7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUxMTVN0YXJ0KGxsbSwgcHJvbXB0cywgcnVuSWQsIHBhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGFncywgbWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uX29yZGVyID0gdGhpcy5fZ2V0RXhlY3V0aW9uT3JkZXIocGFyZW50UnVuSWQpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgZmluYWxFeHRyYVBhcmFtcyA9IG1ldGFkYXRhXG4gICAgICAgICAgICA/IHsgLi4uZXh0cmFQYXJhbXMsIG1ldGFkYXRhIH1cbiAgICAgICAgICAgIDogZXh0cmFQYXJhbXM7XG4gICAgICAgIGNvbnN0IHJ1biA9IHtcbiAgICAgICAgICAgIGlkOiBydW5JZCxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUgPz8gbGxtLmlkW2xsbS5pZC5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IHBhcmVudFJ1bklkLFxuICAgICAgICAgICAgc3RhcnRfdGltZSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQ6IGxsbSxcbiAgICAgICAgICAgIGV2ZW50czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJzdGFydFwiLFxuICAgICAgICAgICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShzdGFydF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaW5wdXRzOiB7IHByb21wdHMgfSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIGNoaWxkX3J1bnM6IFtdLFxuICAgICAgICAgICAgY2hpbGRfZXhlY3V0aW9uX29yZGVyOiBleGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBydW5fdHlwZTogXCJsbG1cIixcbiAgICAgICAgICAgIGV4dHJhOiBmaW5hbEV4dHJhUGFyYW1zID8/IHt9LFxuICAgICAgICAgICAgdGFnczogdGFncyB8fCBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgYXdhaXQgdGhpcy5fc3RhcnRUcmFjZShydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uTExNU3RhcnQ/LihydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGF0TW9kZWxTdGFydChsbG0sIG1lc3NhZ2VzLCBydW5JZCwgcGFyZW50UnVuSWQsIGV4dHJhUGFyYW1zLCB0YWdzLCBtZXRhZGF0YSwgbmFtZSkge1xuICAgICAgICBjb25zdCBleGVjdXRpb25fb3JkZXIgPSB0aGlzLl9nZXRFeGVjdXRpb25PcmRlcihwYXJlbnRSdW5JZCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0X3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBmaW5hbEV4dHJhUGFyYW1zID0gbWV0YWRhdGFcbiAgICAgICAgICAgID8geyAuLi5leHRyYVBhcmFtcywgbWV0YWRhdGEgfVxuICAgICAgICAgICAgOiBleHRyYVBhcmFtcztcbiAgICAgICAgY29uc3QgcnVuID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bklkLFxuICAgICAgICAgICAgbmFtZTogbmFtZSA/PyBsbG0uaWRbbGxtLmlkLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgcGFyZW50X3J1bl9pZDogcGFyZW50UnVuSWQsXG4gICAgICAgICAgICBzdGFydF90aW1lLFxuICAgICAgICAgICAgc2VyaWFsaXplZDogbGxtLFxuICAgICAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHN0YXJ0X3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbnB1dHM6IHsgbWVzc2FnZXMgfSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIGNoaWxkX3J1bnM6IFtdLFxuICAgICAgICAgICAgY2hpbGRfZXhlY3V0aW9uX29yZGVyOiBleGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBydW5fdHlwZTogXCJsbG1cIixcbiAgICAgICAgICAgIGV4dHJhOiBmaW5hbEV4dHJhUGFyYW1zID8/IHt9LFxuICAgICAgICAgICAgdGFnczogdGFncyB8fCBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgYXdhaXQgdGhpcy5fc3RhcnRUcmFjZShydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uTExNU3RhcnQ/LihydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVMTE1FbmQob3V0cHV0LCBydW5JZCkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcImxsbVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBMTE0gcnVuIHRvIGVuZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmVuZF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcnVuLm91dHB1dHMgPSBvdXRwdXQ7XG4gICAgICAgIHJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcImVuZFwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUocnVuLmVuZF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vbkxMTUVuZD8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZFRyYWNlKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUxMTUVycm9yKGVycm9yLCBydW5JZCkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcImxsbVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBMTE0gcnVuIHRvIGVuZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmVuZF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcnVuLmVycm9yID0gdGhpcy5zdHJpbmdpZnlFcnJvcihlcnJvcik7XG4gICAgICAgIHJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcImVycm9yXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShydW4uZW5kX3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uTExNRXJyb3I/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVDaGFpblN0YXJ0KGNoYWluLCBpbnB1dHMsIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIHJ1blR5cGUsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uX29yZGVyID0gdGhpcy5fZ2V0RXhlY3V0aW9uT3JkZXIocGFyZW50UnVuSWQpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgcnVuID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bklkLFxuICAgICAgICAgICAgbmFtZTogbmFtZSA/PyBjaGFpbi5pZFtjaGFpbi5pZC5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IHBhcmVudFJ1bklkLFxuICAgICAgICAgICAgc3RhcnRfdGltZSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQ6IGNoYWluLFxuICAgICAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHN0YXJ0X3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbnB1dHMsXG4gICAgICAgICAgICBleGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBjaGlsZF9leGVjdXRpb25fb3JkZXI6IGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIHJ1bl90eXBlOiBydW5UeXBlID8/IFwiY2hhaW5cIixcbiAgICAgICAgICAgIGNoaWxkX3J1bnM6IFtdLFxuICAgICAgICAgICAgZXh0cmE6IG1ldGFkYXRhID8geyBtZXRhZGF0YSB9IDoge30sXG4gICAgICAgICAgICB0YWdzOiB0YWdzIHx8IFtdLFxuICAgICAgICB9O1xuICAgICAgICBhd2FpdCB0aGlzLl9zdGFydFRyYWNlKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMub25DaGFpblN0YXJ0Py4ocnVuKTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlQ2hhaW5FbmQob3V0cHV0cywgcnVuSWQsIF9wYXJlbnRSdW5JZCwgX3RhZ3MsIGt3YXJncykge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1bikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2hhaW4gcnVuIHRvIGVuZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmVuZF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcnVuLm91dHB1dHMgPSBfY29lcmNlVG9EaWN0KG91dHB1dHMsIFwib3V0cHV0XCIpO1xuICAgICAgICBydW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJlbmRcIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHJ1bi5lbmRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChrd2FyZ3M/LmlucHV0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBydW4uaW5wdXRzID0gX2NvZXJjZVRvRGljdChrd2FyZ3MuaW5wdXRzLCBcImlucHV0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMub25DaGFpbkVuZD8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZFRyYWNlKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUNoYWluRXJyb3IoZXJyb3IsIHJ1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBrd2FyZ3MpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNoYWluIHJ1biB0byBlbmQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5lbmRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHJ1bi5lcnJvciA9IHRoaXMuc3RyaW5naWZ5RXJyb3IoZXJyb3IpO1xuICAgICAgICBydW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUocnVuLmVuZF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGt3YXJncz8uaW5wdXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJ1bi5pbnB1dHMgPSBfY29lcmNlVG9EaWN0KGt3YXJncy5pbnB1dHMsIFwiaW5wdXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5vbkNoYWluRXJyb3I/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVUb29sU3RhcnQodG9vbCwgaW5wdXQsIHJ1bklkLCBwYXJlbnRSdW5JZCwgdGFncywgbWV0YWRhdGEsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uX29yZGVyID0gdGhpcy5fZ2V0RXhlY3V0aW9uT3JkZXIocGFyZW50UnVuSWQpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgcnVuID0ge1xuICAgICAgICAgICAgaWQ6IHJ1bklkLFxuICAgICAgICAgICAgbmFtZTogbmFtZSA/PyB0b29sLmlkW3Rvb2wuaWQubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiBwYXJlbnRSdW5JZCxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWUsXG4gICAgICAgICAgICBzZXJpYWxpemVkOiB0b29sLFxuICAgICAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHN0YXJ0X3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpbnB1dHM6IHsgaW5wdXQgfSxcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIGNoaWxkX2V4ZWN1dGlvbl9vcmRlcjogZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgcnVuX3R5cGU6IFwidG9vbFwiLFxuICAgICAgICAgICAgY2hpbGRfcnVuczogW10sXG4gICAgICAgICAgICBleHRyYTogbWV0YWRhdGEgPyB7IG1ldGFkYXRhIH0gOiB7fSxcbiAgICAgICAgICAgIHRhZ3M6IHRhZ3MgfHwgW10sXG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IHRoaXMuX3N0YXJ0VHJhY2UocnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblRvb2xTdGFydD8uKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVRvb2xFbmQob3V0cHV0LCBydW5JZCkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcInRvb2xcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdG9vbCBydW4gdG8gZW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5lbmRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHJ1bi5vdXRwdXRzID0geyBvdXRwdXQgfTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZW5kXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShydW4uZW5kX3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uVG9vbEVuZD8uKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMuX2VuZFRyYWNlKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVRvb2xFcnJvcihlcnJvciwgcnVuSWQpIHtcbiAgICAgICAgY29uc3QgcnVuID0gdGhpcy5ydW5NYXAuZ2V0KHJ1bklkKTtcbiAgICAgICAgaWYgKCFydW4gfHwgcnVuPy5ydW5fdHlwZSAhPT0gXCJ0b29sXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHRvb2wgcnVuIHRvIGVuZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBydW4uZW5kX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBydW4uZXJyb3IgPSB0aGlzLnN0cmluZ2lmeUVycm9yKGVycm9yKTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIHRpbWU6IG5ldyBEYXRlKHJ1bi5lbmRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMub25Ub29sRXJyb3I/LihydW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9lbmRUcmFjZShydW4pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVBZ2VudEFjdGlvbihhY3Rpb24sIHJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwiY2hhaW5cIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFnZW50UnVuID0gcnVuO1xuICAgICAgICBhZ2VudFJ1bi5hY3Rpb25zID0gYWdlbnRSdW4uYWN0aW9ucyB8fCBbXTtcbiAgICAgICAgYWdlbnRSdW4uYWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gICAgICAgIGFnZW50UnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWdlbnRfYWN0aW9uXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBrd2FyZ3M6IHsgYWN0aW9uIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uQWdlbnRBY3Rpb24/LihydW4pO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVBZ2VudEVuZChhY3Rpb24sIHJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwiY2hhaW5cIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcImFnZW50X2VuZFwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAga3dhcmdzOiB7IGFjdGlvbiB9LFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vbkFnZW50RW5kPy4ocnVuKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlUmV0cmlldmVyU3RhcnQocmV0cmlldmVyLCBxdWVyeSwgcnVuSWQsIHBhcmVudFJ1bklkLCB0YWdzLCBtZXRhZGF0YSwgbmFtZSkge1xuICAgICAgICBjb25zdCBleGVjdXRpb25fb3JkZXIgPSB0aGlzLl9nZXRFeGVjdXRpb25PcmRlcihwYXJlbnRSdW5JZCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0X3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBydW4gPSB7XG4gICAgICAgICAgICBpZDogcnVuSWQsXG4gICAgICAgICAgICBuYW1lOiBuYW1lID8/IHJldHJpZXZlci5pZFtyZXRyaWV2ZXIuaWQubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiBwYXJlbnRSdW5JZCxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWUsXG4gICAgICAgICAgICBzZXJpYWxpemVkOiByZXRyaWV2ZXIsXG4gICAgICAgICAgICBldmVudHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwic3RhcnRcIixcbiAgICAgICAgICAgICAgICAgICAgdGltZTogbmV3IERhdGUoc3RhcnRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGlucHV0czogeyBxdWVyeSB9LFxuICAgICAgICAgICAgZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgY2hpbGRfZXhlY3V0aW9uX29yZGVyOiBleGVjdXRpb25fb3JkZXIsXG4gICAgICAgICAgICBydW5fdHlwZTogXCJyZXRyaWV2ZXJcIixcbiAgICAgICAgICAgIGNoaWxkX3J1bnM6IFtdLFxuICAgICAgICAgICAgZXh0cmE6IG1ldGFkYXRhID8geyBtZXRhZGF0YSB9IDoge30sXG4gICAgICAgICAgICB0YWdzOiB0YWdzIHx8IFtdLFxuICAgICAgICB9O1xuICAgICAgICBhd2FpdCB0aGlzLl9zdGFydFRyYWNlKHJ1bik7XG4gICAgICAgIGF3YWl0IHRoaXMub25SZXRyaWV2ZXJTdGFydD8uKHJ1bik7XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVJldHJpZXZlckVuZChkb2N1bWVudHMsIHJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwicmV0cmlldmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJldHJpZXZlciBydW4gdG8gZW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5lbmRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHJ1bi5vdXRwdXRzID0geyBkb2N1bWVudHMgfTtcbiAgICAgICAgcnVuLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwiZW5kXCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZShydW4uZW5kX3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uUmV0cmlldmVyRW5kPy4ocnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZW5kVHJhY2UocnVuKTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlUmV0cmlldmVyRXJyb3IoZXJyb3IsIHJ1bklkKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwicmV0cmlldmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJldHJpZXZlciBydW4gdG8gZW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5lbmRfdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHJ1bi5lcnJvciA9IHRoaXMuc3RyaW5naWZ5RXJyb3IoZXJyb3IpO1xuICAgICAgICBydW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUocnVuLmVuZF90aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblJldHJpZXZlckVycm9yPy4ocnVuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fZW5kVHJhY2UocnVuKTtcbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlVGV4dCh0ZXh0LCBydW5JZCkge1xuICAgICAgICBjb25zdCBydW4gPSB0aGlzLnJ1bk1hcC5nZXQocnVuSWQpO1xuICAgICAgICBpZiAoIXJ1biB8fCBydW4/LnJ1bl90eXBlICE9PSBcImNoYWluXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBydW4uZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBrd2FyZ3M6IHsgdGV4dCB9LFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5vblRleHQ/LihydW4pO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVMTE1OZXdUb2tlbih0b2tlbiwgaWR4LCBydW5JZCwgX3BhcmVudFJ1bklkLCBfdGFncywgZmllbGRzKSB7XG4gICAgICAgIGNvbnN0IHJ1biA9IHRoaXMucnVuTWFwLmdldChydW5JZCk7XG4gICAgICAgIGlmICghcnVuIHx8IHJ1bj8ucnVuX3R5cGUgIT09IFwibGxtXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBcInJ1bklkXCIgcHJvdmlkZWQgdG8gXCJoYW5kbGVMTE1OZXdUb2tlblwiIGNhbGxiYWNrLmApO1xuICAgICAgICB9XG4gICAgICAgIHJ1bi5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcIm5ld190b2tlblwiLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAga3dhcmdzOiB7IHRva2VuLCBpZHgsIGNodW5rOiBmaWVsZHM/LmNodW5rIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLm9uTExNTmV3VG9rZW4/LihydW4sIHRva2VuLCB7IGNodW5rOiBmaWVsZHM/LmNodW5rIH0pO1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgc3R5bGVzIGZyb20gXCJhbnNpLXN0eWxlc1wiO1xuaW1wb3J0IHsgQmFzZVRyYWNlciB9IGZyb20gXCIuL2Jhc2UuanNcIjtcbmZ1bmN0aW9uIHdyYXAoc3R5bGUsIHRleHQpIHtcbiAgICByZXR1cm4gYCR7c3R5bGUub3Blbn0ke3RleHR9JHtzdHlsZS5jbG9zZX1gO1xufVxuZnVuY3Rpb24gdHJ5SnNvblN0cmluZ2lmeShvYmosIGZhbGxiYWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgMik7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVsYXBzZWQocnVuKSB7XG4gICAgaWYgKCFydW4uZW5kX3RpbWUpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIGNvbnN0IGVsYXBzZWQgPSBydW4uZW5kX3RpbWUgLSBydW4uc3RhcnRfdGltZTtcbiAgICBpZiAoZWxhcHNlZCA8IDEwMDApIHtcbiAgICAgICAgcmV0dXJuIGAke2VsYXBzZWR9bXNgO1xuICAgIH1cbiAgICByZXR1cm4gYCR7KGVsYXBzZWQgLyAxMDAwKS50b0ZpeGVkKDIpfXNgO1xufVxuY29uc3QgeyBjb2xvciB9ID0gc3R5bGVzO1xuLyoqXG4gKiBBIHRyYWNlciB0aGF0IGxvZ3MgYWxsIGV2ZW50cyB0byB0aGUgY29uc29sZS4gSXQgZXh0ZW5kcyBmcm9tIHRoZVxuICogYEJhc2VUcmFjZXJgIGNsYXNzIGFuZCBvdmVycmlkZXMgaXRzIG1ldGhvZHMgdG8gcHJvdmlkZSBjdXN0b20gbG9nZ2luZ1xuICogZnVuY3Rpb25hbGl0eS5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKlxuICogY29uc3QgbGxtID0gbmV3IENoYXRBbnRocm9waWMoe1xuICogICB0ZW1wZXJhdHVyZTogMCxcbiAqICAgdGFnczogW1wiZXhhbXBsZVwiLCBcImNhbGxiYWNrc1wiLCBcImNvbnN0cnVjdG9yXCJdLFxuICogICBjYWxsYmFja3M6IFtuZXcgQ29uc29sZUNhbGxiYWNrSGFuZGxlcigpXSxcbiAqIH0pO1xuICpcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQ29uc29sZUNhbGxiYWNrSGFuZGxlciBleHRlbmRzIEJhc2VUcmFjZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImNvbnNvbGVfY2FsbGJhY2tfaGFuZGxlclwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBwZXJzaXN0IHRoZSBydW4uIEluIHRoaXMgY2FzZSwgaXQgc2ltcGx5IHJldHVybnMgYVxuICAgICAqIHJlc29sdmVkIHByb21pc2UgYXMgdGhlcmUncyBubyBwZXJzaXN0ZW5jZSBsb2dpYy5cbiAgICAgKiBAcGFyYW0gX3J1biBUaGUgcnVuIHRvIHBlcnNpc3QuXG4gICAgICogQHJldHVybnMgQSByZXNvbHZlZCBwcm9taXNlLlxuICAgICAqL1xuICAgIHBlcnNpc3RSdW4oX3J1bikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIC8vIHV0aWxpdHkgbWV0aG9kc1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGdldCBhbGwgdGhlIHBhcmVudCBydW5zIG9mIGEgZ2l2ZW4gcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIHJ1biB3aG9zZSBwYXJlbnRzIGFyZSB0byBiZSByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgcGFyZW50IHJ1bnMuXG4gICAgICovXG4gICAgZ2V0UGFyZW50cyhydW4pIHtcbiAgICAgICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgICAgICBsZXQgY3VycmVudFJ1biA9IHJ1bjtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRSdW4ucGFyZW50X3J1bl9pZCkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5ydW5NYXAuZ2V0KGN1cnJlbnRSdW4ucGFyZW50X3J1bl9pZCk7XG4gICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgY3VycmVudFJ1biA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBnZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHJ1bidzIGxpbmVhZ2UsIHdoaWNoXG4gICAgICogaXMgdXNlZCBpbiBsb2dnaW5nLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIHJ1biB3aG9zZSBsaW5lYWdlIGlzIHRvIGJlIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcnVuJ3MgbGluZWFnZS5cbiAgICAgKi9cbiAgICBnZXRCcmVhZGNydW1icyhydW4pIHtcbiAgICAgICAgY29uc3QgcGFyZW50cyA9IHRoaXMuZ2V0UGFyZW50cyhydW4pLnJldmVyc2UoKTtcbiAgICAgICAgY29uc3Qgc3RyaW5nID0gWy4uLnBhcmVudHMsIHJ1bl1cbiAgICAgICAgICAgIC5tYXAoKHBhcmVudCwgaSwgYXJyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gYCR7cGFyZW50LmV4ZWN1dGlvbl9vcmRlcn06JHtwYXJlbnQucnVuX3R5cGV9OiR7cGFyZW50Lm5hbWV9YDtcbiAgICAgICAgICAgIHJldHVybiBpID09PSBhcnIubGVuZ3RoIC0gMSA/IHdyYXAoc3R5bGVzLmJvbGQsIG5hbWUpIDogbmFtZTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKFwiID4gXCIpO1xuICAgICAgICByZXR1cm4gd3JhcChjb2xvci5ncmV5LCBzdHJpbmcpO1xuICAgIH1cbiAgICAvLyBsb2dnaW5nIG1ldGhvZHNcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgdGhlIHN0YXJ0IG9mIGEgY2hhaW4gcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIGNoYWluIHJ1biB0aGF0IGhhcyBzdGFydGVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvbkNoYWluU3RhcnQocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5ncmVlbiwgXCJbY2hhaW4vc3RhcnRdXCIpfSBbJHtjcnVtYnN9XSBFbnRlcmluZyBDaGFpbiBydW4gd2l0aCBpbnB1dDogJHt0cnlKc29uU3RyaW5naWZ5KHJ1bi5pbnB1dHMsIFwiW2lucHV0c11cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyB0aGUgZW5kIG9mIGEgY2hhaW4gcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIGNoYWluIHJ1biB0aGF0IGhhcyBlbmRlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25DaGFpbkVuZChydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLmN5YW4sIFwiW2NoYWluL2VuZF1cIil9IFske2NydW1ic31dIFske2VsYXBzZWQocnVuKX1dIEV4aXRpbmcgQ2hhaW4gcnVuIHdpdGggb3V0cHV0OiAke3RyeUpzb25TdHJpbmdpZnkocnVuLm91dHB1dHMsIFwiW291dHB1dHNdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgYW55IGVycm9ycyBvZiBhIGNoYWluIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSBjaGFpbiBydW4gdGhhdCBoYXMgZXJyb3JlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25DaGFpbkVycm9yKHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IucmVkLCBcIltjaGFpbi9lcnJvcl1cIil9IFske2NydW1ic31dIFske2VsYXBzZWQocnVuKX1dIENoYWluIHJ1biBlcnJvcmVkIHdpdGggZXJyb3I6ICR7dHJ5SnNvblN0cmluZ2lmeShydW4uZXJyb3IsIFwiW2Vycm9yXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIHRoZSBzdGFydCBvZiBhbiBMTE0gcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIExMTSBydW4gdGhhdCBoYXMgc3RhcnRlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25MTE1TdGFydChydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zdCBpbnB1dHMgPSBcInByb21wdHNcIiBpbiBydW4uaW5wdXRzXG4gICAgICAgICAgICA/IHsgcHJvbXB0czogcnVuLmlucHV0cy5wcm9tcHRzLm1hcCgocCkgPT4gcC50cmltKCkpIH1cbiAgICAgICAgICAgIDogcnVuLmlucHV0cztcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5ncmVlbiwgXCJbbGxtL3N0YXJ0XVwiKX0gWyR7Y3J1bWJzfV0gRW50ZXJpbmcgTExNIHJ1biB3aXRoIGlucHV0OiAke3RyeUpzb25TdHJpbmdpZnkoaW5wdXRzLCBcIltpbnB1dHNdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgdGhlIGVuZCBvZiBhbiBMTE0gcnVuLlxuICAgICAqIEBwYXJhbSBydW4gVGhlIExMTSBydW4gdGhhdCBoYXMgZW5kZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uTExNRW5kKHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IuY3lhbiwgXCJbbGxtL2VuZF1cIil9IFske2NydW1ic31dIFske2VsYXBzZWQocnVuKX1dIEV4aXRpbmcgTExNIHJ1biB3aXRoIG91dHB1dDogJHt0cnlKc29uU3RyaW5naWZ5KHJ1bi5vdXRwdXRzLCBcIltyZXNwb25zZV1cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyBhbnkgZXJyb3JzIG9mIGFuIExMTSBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgTExNIHJ1biB0aGF0IGhhcyBlcnJvcmVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvbkxMTUVycm9yKHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IucmVkLCBcIltsbG0vZXJyb3JdXCIpfSBbJHtjcnVtYnN9XSBbJHtlbGFwc2VkKHJ1bil9XSBMTE0gcnVuIGVycm9yZWQgd2l0aCBlcnJvcjogJHt0cnlKc29uU3RyaW5naWZ5KHJ1bi5lcnJvciwgXCJbZXJyb3JdXCIpfWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBsb2cgdGhlIHN0YXJ0IG9mIGEgdG9vbCBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgdG9vbCBydW4gdGhhdCBoYXMgc3RhcnRlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25Ub29sU3RhcnQocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5ncmVlbiwgXCJbdG9vbC9zdGFydF1cIil9IFske2NydW1ic31dIEVudGVyaW5nIFRvb2wgcnVuIHdpdGggaW5wdXQ6IFwiJHtydW4uaW5wdXRzLmlucHV0Py50cmltKCl9XCJgKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIHRoZSBlbmQgb2YgYSB0b29sIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSB0b29sIHJ1biB0aGF0IGhhcyBlbmRlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25Ub29sRW5kKHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IuY3lhbiwgXCJbdG9vbC9lbmRdXCIpfSBbJHtjcnVtYnN9XSBbJHtlbGFwc2VkKHJ1bil9XSBFeGl0aW5nIFRvb2wgcnVuIHdpdGggb3V0cHV0OiBcIiR7cnVuLm91dHB1dHM/Lm91dHB1dD8udHJpbSgpfVwiYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyBhbnkgZXJyb3JzIG9mIGEgdG9vbCBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgdG9vbCBydW4gdGhhdCBoYXMgZXJyb3JlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25Ub29sRXJyb3IocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5yZWQsIFwiW3Rvb2wvZXJyb3JdXCIpfSBbJHtjcnVtYnN9XSBbJHtlbGFwc2VkKHJ1bil9XSBUb29sIHJ1biBlcnJvcmVkIHdpdGggZXJyb3I6ICR7dHJ5SnNvblN0cmluZ2lmeShydW4uZXJyb3IsIFwiW2Vycm9yXVwiKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gbG9nIHRoZSBzdGFydCBvZiBhIHJldHJpZXZlciBydW4uXG4gICAgICogQHBhcmFtIHJ1biBUaGUgcmV0cmlldmVyIHJ1biB0aGF0IGhhcyBzdGFydGVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvblJldHJpZXZlclN0YXJ0KHJ1bikge1xuICAgICAgICBjb25zdCBjcnVtYnMgPSB0aGlzLmdldEJyZWFkY3J1bWJzKHJ1bik7XG4gICAgICAgIGNvbnNvbGUubG9nKGAke3dyYXAoY29sb3IuZ3JlZW4sIFwiW3JldHJpZXZlci9zdGFydF1cIil9IFske2NydW1ic31dIEVudGVyaW5nIFJldHJpZXZlciBydW4gd2l0aCBpbnB1dDogJHt0cnlKc29uU3RyaW5naWZ5KHJ1bi5pbnB1dHMsIFwiW2lucHV0c11cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyB0aGUgZW5kIG9mIGEgcmV0cmlldmVyIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSByZXRyaWV2ZXIgcnVuIHRoYXQgaGFzIGVuZGVkLlxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBvblJldHJpZXZlckVuZChydW4pIHtcbiAgICAgICAgY29uc3QgY3J1bWJzID0gdGhpcy5nZXRCcmVhZGNydW1icyhydW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHt3cmFwKGNvbG9yLmN5YW4sIFwiW3JldHJpZXZlci9lbmRdXCIpfSBbJHtjcnVtYnN9XSBbJHtlbGFwc2VkKHJ1bil9XSBFeGl0aW5nIFJldHJpZXZlciBydW4gd2l0aCBvdXRwdXQ6ICR7dHJ5SnNvblN0cmluZ2lmeShydW4ub3V0cHV0cywgXCJbb3V0cHV0c11cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyBhbnkgZXJyb3JzIG9mIGEgcmV0cmlldmVyIHJ1bi5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSByZXRyaWV2ZXIgcnVuIHRoYXQgaGFzIGVycm9yZWQuXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIG9uUmV0cmlldmVyRXJyb3IocnVuKSB7XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5yZWQsIFwiW3JldHJpZXZlci9lcnJvcl1cIil9IFske2NydW1ic31dIFske2VsYXBzZWQocnVuKX1dIFJldHJpZXZlciBydW4gZXJyb3JlZCB3aXRoIGVycm9yOiAke3RyeUpzb25TdHJpbmdpZnkocnVuLmVycm9yLCBcIltlcnJvcl1cIil9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGxvZyB0aGUgYWN0aW9uIHNlbGVjdGVkIGJ5IHRoZSBhZ2VudC5cbiAgICAgKiBAcGFyYW0gcnVuIFRoZSBydW4gaW4gd2hpY2ggdGhlIGFnZW50IGFjdGlvbiBvY2N1cnJlZC5cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgb25BZ2VudEFjdGlvbihydW4pIHtcbiAgICAgICAgY29uc3QgYWdlbnRSdW4gPSBydW47XG4gICAgICAgIGNvbnN0IGNydW1icyA9IHRoaXMuZ2V0QnJlYWRjcnVtYnMocnVuKTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7d3JhcChjb2xvci5ibHVlLCBcIlthZ2VudC9hY3Rpb25dXCIpfSBbJHtjcnVtYnN9XSBBZ2VudCBzZWxlY3RlZCBhY3Rpb246ICR7dHJ5SnNvblN0cmluZ2lmeShhZ2VudFJ1bi5hY3Rpb25zW2FnZW50UnVuLmFjdGlvbnMubGVuZ3RoIC0gMV0sIFwiW2FjdGlvbl1cIil9YCk7XG4gICAgfVxufVxuIiwgImltcG9ydCBwUmV0cnkgZnJvbSBcInAtcmV0cnlcIjtcbmltcG9ydCBQUXVldWVNb2QgZnJvbSBcInAtcXVldWVcIjtcbmNvbnN0IFNUQVRVU19OT19SRVRSWSA9IFtcbiAgICA0MDAsXG4gICAgNDAxLFxuICAgIDQwMyxcbiAgICA0MDQsXG4gICAgNDA1LFxuICAgIDQwNixcbiAgICA0MDcsXG4gICAgNDA4LCAvLyBSZXF1ZXN0IFRpbWVvdXRcbl07XG5jb25zdCBTVEFUVVNfSUdOT1JFID0gW1xuICAgIDQwOSwgLy8gQ29uZmxpY3Rcbl07XG4vKipcbiAqIEEgY2xhc3MgdGhhdCBjYW4gYmUgdXNlZCB0byBtYWtlIGFzeW5jIGNhbGxzIHdpdGggY29uY3VycmVuY3kgYW5kIHJldHJ5IGxvZ2ljLlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBtYWtpbmcgY2FsbHMgdG8gYW55IGtpbmQgb2YgXCJleHBlbnNpdmVcIiBleHRlcm5hbCByZXNvdXJjZSxcbiAqIGJlIGl0IGJlY2F1c2UgaXQncyByYXRlLWxpbWl0ZWQsIHN1YmplY3QgdG8gbmV0d29yayBpc3N1ZXMsIGV0Yy5cbiAqXG4gKiBDb25jdXJyZW50IGNhbGxzIGFyZSBsaW1pdGVkIGJ5IHRoZSBgbWF4Q29uY3VycmVuY3lgIHBhcmFtZXRlciwgd2hpY2ggZGVmYXVsdHNcbiAqIHRvIGBJbmZpbml0eWAuIFRoaXMgbWVhbnMgdGhhdCBieSBkZWZhdWx0LCBhbGwgY2FsbHMgd2lsbCBiZSBtYWRlIGluIHBhcmFsbGVsLlxuICpcbiAqIFJldHJpZXMgYXJlIGxpbWl0ZWQgYnkgdGhlIGBtYXhSZXRyaWVzYCBwYXJhbWV0ZXIsIHdoaWNoIGRlZmF1bHRzIHRvIDYuIFRoaXNcbiAqIG1lYW5zIHRoYXQgYnkgZGVmYXVsdCwgZWFjaCBjYWxsIHdpbGwgYmUgcmV0cmllZCB1cCB0byA2IHRpbWVzLCB3aXRoIGFuXG4gKiBleHBvbmVudGlhbCBiYWNrb2ZmIGJldHdlZW4gZWFjaCBhdHRlbXB0LlxuICovXG5leHBvcnQgY2xhc3MgQXN5bmNDYWxsZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhDb25jdXJyZW5jeVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhSZXRyaWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInF1ZXVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRmFpbGVkUmVzcG9uc2VIb29rXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWF4Q29uY3VycmVuY3kgPSBwYXJhbXMubWF4Q29uY3VycmVuY3kgPz8gSW5maW5pdHk7XG4gICAgICAgIHRoaXMubWF4UmV0cmllcyA9IHBhcmFtcy5tYXhSZXRyaWVzID8/IDY7XG4gICAgICAgIGNvbnN0IFBRdWV1ZSA9IFwiZGVmYXVsdFwiIGluIFBRdWV1ZU1vZCA/IFBRdWV1ZU1vZC5kZWZhdWx0IDogUFF1ZXVlTW9kO1xuICAgICAgICB0aGlzLnF1ZXVlID0gbmV3IFBRdWV1ZSh7IGNvbmN1cnJlbmN5OiB0aGlzLm1heENvbmN1cnJlbmN5IH0pO1xuICAgICAgICB0aGlzLm9uRmFpbGVkUmVzcG9uc2VIb29rID0gcGFyYW1zPy5vbkZhaWxlZFJlc3BvbnNlSG9vaztcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjYWxsKGNhbGxhYmxlLCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IG9uRmFpbGVkUmVzcG9uc2VIb29rID0gdGhpcy5vbkZhaWxlZFJlc3BvbnNlSG9vaztcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWUuYWRkKCgpID0+IHBSZXRyeSgoKSA9PiBjYWxsYWJsZSguLi5hcmdzKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwge1xuICAgICAgICAgICAgYXN5bmMgb25GYWlsZWRBdHRlbXB0KGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIkNhbmNlbFwiKSB8fFxuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJUaW1lb3V0RXJyb3JcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKFwiQWJvcnRFcnJvclwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3I/LmNvZGUgPT09IFwiRUNPTk5BQk9SVEVEXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBlcnJvcj8ucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gcmVzcG9uc2U/LnN0YXR1cztcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChTVEFUVVNfTk9fUkVUUlkuaW5jbHVkZXMoK3N0YXR1cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFNUQVRVU19JR05PUkUuaW5jbHVkZXMoK3N0YXR1cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob25GYWlsZWRSZXNwb25zZUhvb2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IG9uRmFpbGVkUmVzcG9uc2VIb29rKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBJZiBuZWVkZWQgd2UgY2FuIGNoYW5nZSBzb21lIG9mIHRoZSBkZWZhdWx0cyBoZXJlLFxuICAgICAgICAgICAgLy8gYnV0IHRoZXkncmUgcXVpdGUgc2Vuc2libGUuXG4gICAgICAgICAgICByZXRyaWVzOiB0aGlzLm1heFJldHJpZXMsXG4gICAgICAgICAgICByYW5kb21pemU6IHRydWUsXG4gICAgICAgIH0pLCB7IHRocm93T25UaW1lb3V0OiB0cnVlIH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNhbGxXaXRoT3B0aW9ucyhvcHRpb25zLCBjYWxsYWJsZSwgLi4uYXJncykge1xuICAgICAgICAvLyBOb3RlIHRoaXMgZG9lc24ndCBjYW5jZWwgdGhlIHVuZGVybHlpbmcgcmVxdWVzdCxcbiAgICAgICAgLy8gd2hlbiBhdmFpbGFibGUgcHJlZmVyIHRvIHVzZSB0aGUgc2lnbmFsIG9wdGlvbiBvZiB0aGUgdW5kZXJseWluZyBjYWxsXG4gICAgICAgIGlmIChvcHRpb25zLnNpZ25hbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsKGNhbGxhYmxlLCAuLi5hcmdzKSxcbiAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsPy5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkFib3J0RXJyb3JcIikpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwoY2FsbGFibGUsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBmZXRjaCguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwoKCkgPT4gZmV0Y2goLi4uYXJncykudGhlbigocmVzKSA9PiAocmVzLm9rID8gcmVzIDogUHJvbWlzZS5yZWplY3QocmVzKSkpKTtcbiAgICB9XG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGlzTGFuZ0NoYWluTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBtZXNzYWdlPy5fZ2V0VHlwZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRMYW5nQ2hhaW5NZXNzYWdlVG9FeGFtcGxlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBjb252ZXJ0ZWQgPSB7XG4gICAgICAgIHR5cGU6IG1lc3NhZ2UuX2dldFR5cGUoKSxcbiAgICAgICAgZGF0YTogeyBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQgfSxcbiAgICB9O1xuICAgIC8vIENoZWNrIGZvciBwcmVzZW5jZSBvZiBrZXlzIGluIGFkZGl0aW9uYWxfa3dhcmdzXG4gICAgaWYgKG1lc3NhZ2U/LmFkZGl0aW9uYWxfa3dhcmdzICYmXG4gICAgICAgIE9iamVjdC5rZXlzKG1lc3NhZ2UuYWRkaXRpb25hbF9rd2FyZ3MpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29udmVydGVkLmRhdGEuYWRkaXRpb25hbF9rd2FyZ3MgPSB7IC4uLm1lc3NhZ2UuYWRkaXRpb25hbF9rd2FyZ3MgfTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRlZDtcbn1cbiIsICIvLyBJbmxpbmVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2ZsZXhkaW5lc2gvYnJvd3Nlci1vci1ub2RlXG5pbXBvcnQgeyBfX3ZlcnNpb25fXyB9IGZyb20gXCIuLi9pbmRleC5qc1wiO1xubGV0IGdsb2JhbEVudjtcbmV4cG9ydCBjb25zdCBpc0Jyb3dzZXIgPSAoKSA9PiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCI7XG5leHBvcnQgY29uc3QgaXNXZWJXb3JrZXIgPSAoKSA9PiB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIiAmJlxuICAgIGdsb2JhbFRoaXMuY29uc3RydWN0b3IgJiZcbiAgICBnbG9iYWxUaGlzLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiRGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGVcIjtcbmV4cG9ydCBjb25zdCBpc0pzRG9tID0gKCkgPT4gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Lm5hbWUgPT09IFwibm9kZWpzXCIpIHx8XG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoXCJOb2RlLmpzXCIpIHx8XG4gICAgICAgICAgICBuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwianNkb21cIikpKTtcbi8vIFN1cGFiYXNlIEVkZ2UgRnVuY3Rpb24gcHJvdmlkZXMgYSBgRGVub2AgZ2xvYmFsIG9iamVjdFxuLy8gd2l0aG91dCBgdmVyc2lvbmAgcHJvcGVydHlcbmV4cG9ydCBjb25zdCBpc0Rlbm8gPSAoKSA9PiB0eXBlb2YgRGVubyAhPT0gXCJ1bmRlZmluZWRcIjtcbi8vIE1hcmsgbm90LWFzLW5vZGUgaWYgaW4gU3VwYWJhc2UgRWRnZSBGdW5jdGlvblxuZXhwb3J0IGNvbnN0IGlzTm9kZSA9ICgpID0+IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgIWlzRGVubygpO1xuZXhwb3J0IGNvbnN0IGdldEVudiA9ICgpID0+IHtcbiAgICBpZiAoZ2xvYmFsRW52KSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxFbnY7XG4gICAgfVxuICAgIGlmIChpc0Jyb3dzZXIoKSkge1xuICAgICAgICBnbG9iYWxFbnYgPSBcImJyb3dzZXJcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNOb2RlKCkpIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJub2RlXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzV2ViV29ya2VyKCkpIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJ3ZWJ3b3JrZXJcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNKc0RvbSgpKSB7XG4gICAgICAgIGdsb2JhbEVudiA9IFwianNkb21cIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNEZW5vKCkpIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJkZW5vXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbG9iYWxFbnYgPSBcIm90aGVyXCI7XG4gICAgfVxuICAgIHJldHVybiBnbG9iYWxFbnY7XG59O1xubGV0IHJ1bnRpbWVFbnZpcm9ubWVudDtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSdW50aW1lRW52aXJvbm1lbnQoKSB7XG4gICAgaWYgKHJ1bnRpbWVFbnZpcm9ubWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGVudiA9IGdldEVudigpO1xuICAgICAgICBjb25zdCByZWxlYXNlRW52ID0gZ2V0U2hhcygpO1xuICAgICAgICBydW50aW1lRW52aXJvbm1lbnQgPSB7XG4gICAgICAgICAgICBsaWJyYXJ5OiBcImxhbmdzbWl0aFwiLFxuICAgICAgICAgICAgcnVudGltZTogZW52LFxuICAgICAgICAgICAgc2RrOiBcImxhbmdzbWl0aC1qc1wiLFxuICAgICAgICAgICAgc2RrX3ZlcnNpb246IF9fdmVyc2lvbl9fLFxuICAgICAgICAgICAgLi4ucmVsZWFzZUVudixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1bnRpbWVFbnZpcm9ubWVudDtcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBMYW5nQ2hhaW4tc3BlY2lmaWMgZW52aXJvbm1lbnQgdmFyaWFibGVzIGZyb20gdGhlIGN1cnJlbnQgcnVudGltZSBlbnZpcm9ubWVudC5cbiAqIFNlbnNpdGl2ZSBrZXlzIChjb250YWluaW5nIHRoZSB3b3JkIFwia2V5XCIsIFwidG9rZW5cIiwgb3IgXCJzZWNyZXRcIikgaGF2ZSB0aGVpciB2YWx1ZXMgcmVkYWN0ZWQgZm9yIHNlY3VyaXR5LlxuICpcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fVxuICogIC0gQSByZWNvcmQgb2YgTGFuZ0NoYWluLXNwZWNpZmljIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExhbmdDaGFpbkVudlZhcnMoKSB7XG4gICAgY29uc3QgYWxsRW52VmFycyA9IGdldEVudmlyb25tZW50VmFyaWFibGVzKCkgfHwge307XG4gICAgY29uc3QgZW52VmFycyA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGFsbEVudlZhcnMpKSB7XG4gICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChcIkxBTkdDSEFJTl9cIikgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBlbnZWYXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBlbnZWYXJzKSB7XG4gICAgICAgIGlmICgoa2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJrZXlcIikgfHxcbiAgICAgICAgICAgIGtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwic2VjcmV0XCIpIHx8XG4gICAgICAgICAgICBrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInRva2VuXCIpKSAmJlxuICAgICAgICAgICAgdHlwZW9mIGVudlZhcnNba2V5XSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBlbnZWYXJzW2tleV07XG4gICAgICAgICAgICBlbnZWYXJzW2tleV0gPVxuICAgICAgICAgICAgICAgIHZhbHVlLnNsaWNlKDAsIDIpICsgXCIqXCIucmVwZWF0KHZhbHVlLmxlbmd0aCAtIDQpICsgdmFsdWUuc2xpY2UoLTIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbnZWYXJzO1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIExhbmdDaGFpbi1zcGVjaWZpYyBtZXRhZGF0YSBmcm9tIHRoZSBjdXJyZW50IHJ1bnRpbWUgZW52aXJvbm1lbnQuXG4gKlxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZz59XG4gKiAgLSBBIHJlY29yZCBvZiBMYW5nQ2hhaW4tc3BlY2lmaWMgbWV0YWRhdGEgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGFuZ0NoYWluRW52VmFyc01ldGFkYXRhKCkge1xuICAgIGNvbnN0IGFsbEVudlZhcnMgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlcygpIHx8IHt9O1xuICAgIGNvbnN0IGVudlZhcnMgPSB7fTtcbiAgICBjb25zdCBleGNsdWRlZCA9IFtcbiAgICAgICAgXCJMQU5HQ0hBSU5fQVBJX0tFWVwiLFxuICAgICAgICBcIkxBTkdDSEFJTl9FTkRQT0lOVFwiLFxuICAgICAgICBcIkxBTkdDSEFJTl9UUkFDSU5HX1YyXCIsXG4gICAgICAgIFwiTEFOR0NIQUlOX1BST0pFQ1RcIixcbiAgICAgICAgXCJMQU5HQ0hBSU5fU0VTU0lPTlwiLFxuICAgIF07XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYWxsRW52VmFycykpIHtcbiAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKFwiTEFOR0NIQUlOX1wiKSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAhZXhjbHVkZWQuaW5jbHVkZXMoa2V5KSAmJlxuICAgICAgICAgICAgIWtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwia2V5XCIpICYmXG4gICAgICAgICAgICAha2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJzZWNyZXRcIikgJiZcbiAgICAgICAgICAgICFrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInRva2VuXCIpKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcIkxBTkdDSEFJTl9SRVZJU0lPTl9JRFwiKSB7XG4gICAgICAgICAgICAgICAgZW52VmFyc1tcInJldmlzaW9uX2lkXCJdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbnZWYXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW52VmFycztcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZnJvbSB0aGUgY3VycmVudCBydW50aW1lIGVudmlyb25tZW50LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gb3BlcmF0ZSBpbiBhIHZhcmlldHkgb2YgSlMgZW52aXJvbm1lbnRzLFxuICogaW5jbHVkaW5nIE5vZGUuanMsIERlbm8sIGJyb3dzZXJzLCBldGMuXG4gKlxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZz4gfCB1bmRlZmluZWR9XG4gKiAgLSBBIHJlY29yZCBvZiBlbnZpcm9ubWVudCB2YXJpYWJsZXMgaWYgYXZhaWxhYmxlLlxuICogIC0gYHVuZGVmaW5lZGAgaWYgdGhlIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgb3IgYWxsb3dzIGFjY2VzcyB0byBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlcygpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBDaGVjayBmb3IgTm9kZS5qcyBlbnZpcm9ubWVudFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvY2Vzcy1lbnZcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52KSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvY2Vzcy1lbnZcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhwcm9jZXNzLmVudikucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY1trZXldID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvciBicm93c2VycyBhbmQgb3RoZXIgZW52aXJvbm1lbnRzLCB3ZSBtYXkgbm90IGhhdmUgZGlyZWN0IGFjY2VzcyB0byBlbnYgdmFyaWFibGVzXG4gICAgICAgIC8vIFJldHVybiB1bmRlZmluZWQgb3IgYW55IG90aGVyIGZhbGxiYWNrIGFzIHJlcXVpcmVkLlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBDYXRjaCBhbnkgZXJyb3JzIHRoYXQgbWlnaHQgb2NjdXIgd2hpbGUgdHJ5aW5nIHRvIGFjY2VzcyBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShuYW1lKSB7XG4gICAgLy8gQ2VydGFpbiBEZW5vIHNldHVwcyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHlvdSB0cnkgdG8gYWNjZXNzIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9od2NoYXNlMTcvbGFuZ2NoYWluanMvaXNzdWVzLzE0MTJcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZW52XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnY/LltuYW1lXVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHNldEVudmlyb25tZW50VmFyaWFibGUobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZW52XG4gICAgICAgIHByb2Nlc3MuZW52W25hbWVdID0gdmFsdWU7XG4gICAgfVxufVxubGV0IGNhY2hlZENvbW1pdFNIQXM7XG4vKipcbiAqIEdldCB0aGUgR2l0IGNvbW1pdCBTSEEgZnJvbSBjb21tb24gZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gKiB1c2VkIGJ5IGRpZmZlcmVudCBDSS9DRCBwbGF0Zm9ybXMuXG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSBUaGUgR2l0IGNvbW1pdCBTSEEgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNoYXMoKSB7XG4gICAgaWYgKGNhY2hlZENvbW1pdFNIQXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY2FjaGVkQ29tbWl0U0hBcztcbiAgICB9XG4gICAgY29uc3QgY29tbW9uX3JlbGVhc2VfZW52cyA9IFtcbiAgICAgICAgXCJWRVJDRUxfR0lUX0NPTU1JVF9TSEFcIixcbiAgICAgICAgXCJORVhUX1BVQkxJQ19WRVJDRUxfR0lUX0NPTU1JVF9TSEFcIixcbiAgICAgICAgXCJDT01NSVRfUkVGXCIsXG4gICAgICAgIFwiUkVOREVSX0dJVF9DT01NSVRcIixcbiAgICAgICAgXCJDSV9DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiQ0lSQ0xFX1NIQTFcIixcbiAgICAgICAgXCJDRl9QQUdFU19DT01NSVRfU0hBXCIsXG4gICAgICAgIFwiUkVBQ1RfQVBQX0dJVF9TSEFcIixcbiAgICAgICAgXCJTT1VSQ0VfVkVSU0lPTlwiLFxuICAgICAgICBcIkdJVEhVQl9TSEFcIixcbiAgICAgICAgXCJUUkFWSVNfQ09NTUlUXCIsXG4gICAgICAgIFwiR0lUX0NPTU1JVFwiLFxuICAgICAgICBcIkJVSUxEX1ZDU19OVU1CRVJcIixcbiAgICAgICAgXCJiYW1ib29fcGxhblJlcG9zaXRvcnlfcmV2aXNpb25cIixcbiAgICAgICAgXCJCdWlsZC5Tb3VyY2VWZXJzaW9uXCIsXG4gICAgICAgIFwiQklUQlVDS0VUX0NPTU1JVFwiLFxuICAgICAgICBcIkRST05FX0NPTU1JVF9TSEFcIixcbiAgICAgICAgXCJTRU1BUEhPUkVfR0lUX1NIQVwiLFxuICAgICAgICBcIkJVSUxES0lURV9DT01NSVRcIixcbiAgICBdO1xuICAgIGNvbnN0IHNoYXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGVudiBvZiBjb21tb25fcmVsZWFzZV9lbnZzKSB7XG4gICAgICAgIGNvbnN0IGVudlZhciA9IGdldEVudmlyb25tZW50VmFyaWFibGUoZW52KTtcbiAgICAgICAgaWYgKGVudlZhciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzaGFzW2Vudl0gPSBlbnZWYXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FjaGVkQ29tbWl0U0hBcyA9IHNoYXM7XG4gICAgcmV0dXJuIHNoYXM7XG59XG4iLCAiaW1wb3J0ICogYXMgdXVpZCBmcm9tIFwidXVpZFwiO1xuaW1wb3J0IHsgQXN5bmNDYWxsZXIgfSBmcm9tIFwiLi91dGlscy9hc3luY19jYWxsZXIuanNcIjtcbmltcG9ydCB7IGNvbnZlcnRMYW5nQ2hhaW5NZXNzYWdlVG9FeGFtcGxlLCBpc0xhbmdDaGFpbk1lc3NhZ2UsIH0gZnJvbSBcIi4vdXRpbHMvbWVzc2FnZXMuanNcIjtcbmltcG9ydCB7IGdldEVudmlyb25tZW50VmFyaWFibGUsIGdldExhbmdDaGFpbkVudlZhcnNNZXRhZGF0YSwgZ2V0UnVudGltZUVudmlyb25tZW50LCB9IGZyb20gXCIuL3V0aWxzL2Vudi5qc1wiO1xuaW1wb3J0IHsgX192ZXJzaW9uX18gfSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuYXN5bmMgZnVuY3Rpb24gbWVyZ2VSdW50aW1lRW52SW50b1J1bkNyZWF0ZXMocnVucykge1xuICAgIGNvbnN0IHJ1bnRpbWVFbnYgPSBhd2FpdCBnZXRSdW50aW1lRW52aXJvbm1lbnQoKTtcbiAgICBjb25zdCBlbnZWYXJzID0gZ2V0TGFuZ0NoYWluRW52VmFyc01ldGFkYXRhKCk7XG4gICAgcmV0dXJuIHJ1bnMubWFwKChydW4pID0+IHtcbiAgICAgICAgY29uc3QgZXh0cmEgPSBydW4uZXh0cmEgPz8ge307XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gZXh0cmEubWV0YWRhdGE7XG4gICAgICAgIHJ1bi5leHRyYSA9IHtcbiAgICAgICAgICAgIC4uLmV4dHJhLFxuICAgICAgICAgICAgcnVudGltZToge1xuICAgICAgICAgICAgICAgIC4uLnJ1bnRpbWVFbnYsXG4gICAgICAgICAgICAgICAgLi4uZXh0cmE/LnJ1bnRpbWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICAuLi5lbnZWYXJzLFxuICAgICAgICAgICAgICAgIC4uLihlbnZWYXJzLnJldmlzaW9uX2lkIHx8IHJ1bi5yZXZpc2lvbl9pZFxuICAgICAgICAgICAgICAgICAgICA/IHsgcmV2aXNpb25faWQ6IHJ1bi5yZXZpc2lvbl9pZCA/PyBlbnZWYXJzLnJldmlzaW9uX2lkIH1cbiAgICAgICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH0pO1xufVxuY29uc3QgZ2V0VHJhY2luZ1NhbXBsaW5nUmF0ZSA9ICgpID0+IHtcbiAgICBjb25zdCBzYW1wbGluZ1JhdGVTdHIgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX1RSQUNJTkdfU0FNUExJTkdfUkFURVwiKTtcbiAgICBpZiAoc2FtcGxpbmdSYXRlU3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3Qgc2FtcGxpbmdSYXRlID0gcGFyc2VGbG9hdChzYW1wbGluZ1JhdGVTdHIpO1xuICAgIGlmIChzYW1wbGluZ1JhdGUgPCAwIHx8IHNhbXBsaW5nUmF0ZSA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMQU5HQ0hBSU5fVFJBQ0lOR19TQU1QTElOR19SQVRFIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxIGlmIHNldC4gR290OiAke3NhbXBsaW5nUmF0ZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHNhbXBsaW5nUmF0ZTtcbn07XG4vLyB1dGlsaXR5IGZ1bmN0aW9uc1xuY29uc3QgaXNMb2NhbGhvc3QgPSAodXJsKSA9PiB7XG4gICAgY29uc3Qgc3RyaXBwZWRVcmwgPSB1cmwucmVwbGFjZShcImh0dHA6Ly9cIiwgXCJcIikucmVwbGFjZShcImh0dHBzOi8vXCIsIFwiXCIpO1xuICAgIGNvbnN0IGhvc3RuYW1lID0gc3RyaXBwZWRVcmwuc3BsaXQoXCIvXCIpWzBdLnNwbGl0KFwiOlwiKVswXTtcbiAgICByZXR1cm4gKGhvc3RuYW1lID09PSBcImxvY2FsaG9zdFwiIHx8IGhvc3RuYW1lID09PSBcIjEyNy4wLjAuMVwiIHx8IGhvc3RuYW1lID09PSBcIjo6MVwiKTtcbn07XG5jb25zdCByYWlzZUZvclN0YXR1cyA9IGFzeW5jIChyZXNwb25zZSwgb3BlcmF0aW9uKSA9PiB7XG4gICAgLy8gY29uc3VtZSB0aGUgcmVzcG9uc2UgYm9keSB0byByZWxlYXNlIHRoZSBjb25uZWN0aW9uXG4gICAgLy8gaHR0cHM6Ly91bmRpY2kubm9kZWpzLm9yZy8jLz9pZD1nYXJiYWdlLWNvbGxlY3Rpb25cbiAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gJHtvcGVyYXRpb259OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fSAke2JvZHl9YCk7XG4gICAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIHRvQXJyYXkoaXRlcmFibGUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgaXRlcmFibGUpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0cmltUXVvdGVzKHN0cikge1xuICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gc3RyXG4gICAgICAgIC50cmltKClcbiAgICAgICAgLnJlcGxhY2UoL15cIiguKilcIiQvLCBcIiQxXCIpXG4gICAgICAgIC5yZXBsYWNlKC9eJyguKiknJC8sIFwiJDFcIik7XG59XG5mdW5jdGlvbiBhc3NlcnRVdWlkKHN0cikge1xuICAgIGlmICghdXVpZC52YWxpZGF0ZShzdHIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBVVUlEOiAke3N0cn1gKTtcbiAgICB9XG59XG5jb25zdCBoYW5kbGU0MjkgPSBhc3luYyAocmVzcG9uc2UpID0+IHtcbiAgICBpZiAocmVzcG9uc2U/LnN0YXR1cyA9PT0gNDI5KSB7XG4gICAgICAgIGNvbnN0IHJldHJ5QWZ0ZXIgPSBwYXJzZUludChyZXNwb25zZS5oZWFkZXJzLmdldChcInJldHJ5LWFmdGVyXCIpID8/IFwiMzBcIiwgMTApICogMTAwMDtcbiAgICAgICAgaWYgKHJldHJ5QWZ0ZXIgPiAwKSB7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCByZXRyeUFmdGVyKSk7XG4gICAgICAgICAgICAvLyBSZXR1cm4gZGlyZWN0bHkgYWZ0ZXIgY2FsbGluZyB0aGlzIGNoZWNrXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBGYWxsIGJhY2sgdG8gZXhpc3Rpbmcgc3RhdHVzIGNoZWNrc1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5leHBvcnQgY2xhc3MgUXVldWUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpdGVtc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5sZW5ndGg7XG4gICAgfVxuICAgIHB1c2goaXRlbSkge1xuICAgICAgICAvLyB0aGlzLml0ZW1zLnB1c2ggaXMgc3luY2hyb25vdXMgd2l0aCBwcm9taXNlIGNyZWF0aW9uOlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm9taXNlL1Byb21pc2VcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2goW2l0ZW0sIHJlc29sdmVdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBvcCh1cFRvTikge1xuICAgICAgICBpZiAodXBUb04gPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgb2YgaXRlbXMgdG8gcG9wIG9mZiBtYXkgbm90IGJlIGxlc3MgdGhhbiAxLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3BwZWQgPSBbXTtcbiAgICAgICAgd2hpbGUgKHBvcHBlZC5sZW5ndGggPCB1cFRvTiAmJiB0aGlzLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuaXRlbXMuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcG9wcGVkLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3BvcHBlZC5tYXAoKGl0KSA9PiBpdFswXSksICgpID0+IHBvcHBlZC5mb3JFYWNoKChpdCkgPT4gaXRbMV0oKSldO1xuICAgIH1cbn1cbi8vIDIwIE1CXG5leHBvcnQgY29uc3QgREVGQVVMVF9CQVRDSF9TSVpFX0xJTUlUX0JZVEVTID0gMjA5NzE1MjA7XG5leHBvcnQgY2xhc3MgQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcGlLZXlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXBpVXJsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndlYlVybFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYWxsZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYmF0Y2hJbmdlc3RDYWxsZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGltZW91dF9tc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGVuYW50SWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhpZGVJbnB1dHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaGlkZU91dHB1dHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhY2luZ1NhbXBsZVJhdGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2FtcGxlZFBvc3RVdWlkc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IFNldCgpXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdXRvQmF0Y2hUcmFjaW5nXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJiYXRjaEVuZHBvaW50U3VwcG9ydGVkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9CYXRjaFF1ZXVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgUXVldWUoKVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGVuZGluZ0F1dG9CYXRjaGVkUnVuTGltaXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDEwMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXV0b0JhdGNoVGltZW91dFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdXRvQmF0Y2hJbml0aWFsRGVsYXlNc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMjUwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdXRvQmF0Y2hBZ2dyZWdhdGlvbkRlbGF5TXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDUwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXJ2ZXJJbmZvXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRDb25maWcgPSBDbGllbnQuZ2V0RGVmYXVsdENsaWVudENvbmZpZygpO1xuICAgICAgICB0aGlzLnRyYWNpbmdTYW1wbGVSYXRlID0gZ2V0VHJhY2luZ1NhbXBsaW5nUmF0ZSgpO1xuICAgICAgICB0aGlzLmFwaVVybCA9IHRyaW1RdW90ZXMoY29uZmlnLmFwaVVybCA/PyBkZWZhdWx0Q29uZmlnLmFwaVVybCkgPz8gXCJcIjtcbiAgICAgICAgdGhpcy5hcGlLZXkgPSB0cmltUXVvdGVzKGNvbmZpZy5hcGlLZXkgPz8gZGVmYXVsdENvbmZpZy5hcGlLZXkpO1xuICAgICAgICB0aGlzLndlYlVybCA9IHRyaW1RdW90ZXMoY29uZmlnLndlYlVybCA/PyBkZWZhdWx0Q29uZmlnLndlYlVybCk7XG4gICAgICAgIHRoaXMudGltZW91dF9tcyA9IGNvbmZpZy50aW1lb3V0X21zID8/IDEyMDAwO1xuICAgICAgICB0aGlzLmNhbGxlciA9IG5ldyBBc3luY0NhbGxlcihjb25maWcuY2FsbGVyT3B0aW9ucyA/PyB7fSk7XG4gICAgICAgIHRoaXMuYmF0Y2hJbmdlc3RDYWxsZXIgPSBuZXcgQXN5bmNDYWxsZXIoe1xuICAgICAgICAgICAgLi4uKGNvbmZpZy5jYWxsZXJPcHRpb25zID8/IHt9KSxcbiAgICAgICAgICAgIG9uRmFpbGVkUmVzcG9uc2VIb29rOiBoYW5kbGU0MjksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhpZGVJbnB1dHMgPSBjb25maWcuaGlkZUlucHV0cyA/PyBkZWZhdWx0Q29uZmlnLmhpZGVJbnB1dHM7XG4gICAgICAgIHRoaXMuaGlkZU91dHB1dHMgPSBjb25maWcuaGlkZU91dHB1dHMgPz8gZGVmYXVsdENvbmZpZy5oaWRlT3V0cHV0cztcbiAgICAgICAgdGhpcy5hdXRvQmF0Y2hUcmFjaW5nID0gY29uZmlnLmF1dG9CYXRjaFRyYWNpbmcgPz8gdGhpcy5hdXRvQmF0Y2hUcmFjaW5nO1xuICAgICAgICB0aGlzLnBlbmRpbmdBdXRvQmF0Y2hlZFJ1bkxpbWl0ID1cbiAgICAgICAgICAgIGNvbmZpZy5wZW5kaW5nQXV0b0JhdGNoZWRSdW5MaW1pdCA/PyB0aGlzLnBlbmRpbmdBdXRvQmF0Y2hlZFJ1bkxpbWl0O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0RGVmYXVsdENsaWVudENvbmZpZygpIHtcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9BUElfS0VZXCIpO1xuICAgICAgICBjb25zdCBhcGlVcmwgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX0VORFBPSU5UXCIpID8/XG4gICAgICAgICAgICBcImh0dHBzOi8vYXBpLnNtaXRoLmxhbmdjaGFpbi5jb21cIjtcbiAgICAgICAgY29uc3QgaGlkZUlucHV0cyA9IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fSElERV9JTlBVVFNcIikgPT09IFwidHJ1ZVwiO1xuICAgICAgICBjb25zdCBoaWRlT3V0cHV0cyA9IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fSElERV9PVVRQVVRTXCIpID09PSBcInRydWVcIjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFwaVVybDogYXBpVXJsLFxuICAgICAgICAgICAgYXBpS2V5OiBhcGlLZXksXG4gICAgICAgICAgICB3ZWJVcmw6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGhpZGVJbnB1dHM6IGhpZGVJbnB1dHMsXG4gICAgICAgICAgICBoaWRlT3V0cHV0czogaGlkZU91dHB1dHMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldEhvc3RVcmwoKSB7XG4gICAgICAgIGlmICh0aGlzLndlYlVybCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2ViVXJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTG9jYWxob3N0KHRoaXMuYXBpVXJsKSkge1xuICAgICAgICAgICAgdGhpcy53ZWJVcmwgPSBcImh0dHA6Ly9sb2NhbGhvc3RcIjtcbiAgICAgICAgICAgIHJldHVybiBcImh0dHA6Ly9sb2NhbGhvc3RcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFwaVVybC5pbmNsdWRlcyhcIi9hcGlcIikgJiZcbiAgICAgICAgICAgICF0aGlzLmFwaVVybC5zcGxpdChcIi5cIiwgMSlbMF0uZW5kc1dpdGgoXCJhcGlcIikpIHtcbiAgICAgICAgICAgIHRoaXMud2ViVXJsID0gdGhpcy5hcGlVcmwucmVwbGFjZShcIi9hcGlcIiwgXCJcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWJVcmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hcGlVcmwuc3BsaXQoXCIuXCIsIDEpWzBdLmluY2x1ZGVzKFwiZGV2XCIpKSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IFwiaHR0cHM6Ly9kZXYuc21pdGgubGFuZ2NoYWluLmNvbVwiO1xuICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6Ly9kZXYuc21pdGgubGFuZ2NoYWluLmNvbVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53ZWJVcmwgPSBcImh0dHBzOi8vc21pdGgubGFuZ2NoYWluLmNvbVwiO1xuICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6Ly9zbWl0aC5sYW5nY2hhaW4uY29tXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGhlYWRlcnMoKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICBcIlVzZXItQWdlbnRcIjogYGxhbmdzbWl0aC1qcy8ke19fdmVyc2lvbl9ffWAsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmFwaUtleSkge1xuICAgICAgICAgICAgaGVhZGVyc1tcIngtYXBpLWtleVwiXSA9IGAke3RoaXMuYXBpS2V5fWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIHByb2Nlc3NJbnB1dHMoaW5wdXRzKSB7XG4gICAgICAgIGlmICh0aGlzLmhpZGVJbnB1dHMpIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXRzO1xuICAgIH1cbiAgICBwcm9jZXNzT3V0cHV0cyhvdXRwdXRzKSB7XG4gICAgICAgIGlmICh0aGlzLmhpZGVPdXRwdXRzKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgfVxuICAgIHByZXBhcmVSdW5DcmVhdGVPclVwZGF0ZUlucHV0cyhydW4pIHtcbiAgICAgICAgY29uc3QgcnVuUGFyYW1zID0geyAuLi5ydW4gfTtcbiAgICAgICAgaWYgKHJ1blBhcmFtcy5pbnB1dHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcnVuUGFyYW1zLmlucHV0cyA9IHRoaXMucHJvY2Vzc0lucHV0cyhydW5QYXJhbXMuaW5wdXRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVuUGFyYW1zLm91dHB1dHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcnVuUGFyYW1zLm91dHB1dHMgPSB0aGlzLnByb2Nlc3NPdXRwdXRzKHJ1blBhcmFtcy5vdXRwdXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVuUGFyYW1zO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0UmVzcG9uc2UocGF0aCwgcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zU3RyaW5nID0gcXVlcnlQYXJhbXM/LnRvU3RyaW5nKCkgPz8gXCJcIjtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5hcGlVcmx9JHtwYXRofT8ke3BhcmFtc1N0cmluZ31gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIHVybCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCAke3BhdGh9OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgX2dldChwYXRoLCBxdWVyeVBhcmFtcykge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldFJlc3BvbnNlKHBhdGgsIHF1ZXJ5UGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgYXN5bmMgKl9nZXRQYWdpbmF0ZWQocGF0aCwgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCkpIHtcbiAgICAgICAgbGV0IG9mZnNldCA9IE51bWJlcihxdWVyeVBhcmFtcy5nZXQoXCJvZmZzZXRcIikpIHx8IDA7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gTnVtYmVyKHF1ZXJ5UGFyYW1zLmdldChcImxpbWl0XCIpKSB8fCAxMDA7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcy5zZXQoXCJvZmZzZXRcIiwgU3RyaW5nKG9mZnNldCkpO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMuc2V0KFwibGltaXRcIiwgU3RyaW5nKGxpbWl0KSk7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmFwaVVybH0ke3BhdGh9PyR7cXVlcnlQYXJhbXN9YDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgdXJsLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoICR7cGF0aH06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIGl0ZW1zO1xuICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA8IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgKz0gaXRlbXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICpfZ2V0Q3Vyc29yUGFnaW5hdGVkTGlzdChwYXRoLCBib2R5ID0gbnVsbCwgcmVxdWVzdE1ldGhvZCA9IFwiUE9TVFwiLCBkYXRhS2V5ID0gXCJydW5zXCIpIHtcbiAgICAgICAgY29uc3QgYm9keVBhcmFtcyA9IGJvZHkgPyB7IC4uLmJvZHkgfSA6IHt9O1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0ke3BhdGh9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogcmVxdWVzdE1ldGhvZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5UGFyYW1zKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZUJvZHkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VCb2R5W2RhdGFLZXldKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCByZXNwb25zZUJvZHlbZGF0YUtleV07XG4gICAgICAgICAgICBjb25zdCBjdXJzb3JzID0gcmVzcG9uc2VCb2R5LmN1cnNvcnM7XG4gICAgICAgICAgICBpZiAoIWN1cnNvcnMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY3Vyc29ycy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib2R5UGFyYW1zLmN1cnNvciA9IGN1cnNvcnMubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZmlsdGVyRm9yU2FtcGxpbmcocnVucywgcGF0Y2ggPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy50cmFjaW5nU2FtcGxlUmF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcnVucztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZWQgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcnVuIG9mIHJ1bnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zYW1wbGVkUG9zdFV1aWRzLmhhcyhydW4uaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZWQucHVzaChydW4pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNhbXBsZWRQb3N0VXVpZHMuZGVsZXRlKHJ1bi5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVkID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJ1biBvZiBydW5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCB0aGlzLnRyYWNpbmdTYW1wbGVSYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZWQucHVzaChydW4pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNhbXBsZWRQb3N0VXVpZHMuYWRkKHJ1bi5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZHJhaW5BdXRvQmF0Y2hRdWV1ZSgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuYXV0b0JhdGNoUXVldWUuc2l6ZSA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBbYmF0Y2gsIGRvbmVdID0gdGhpcy5hdXRvQmF0Y2hRdWV1ZS5wb3AodGhpcy5wZW5kaW5nQXV0b0JhdGNoZWRSdW5MaW1pdCk7XG4gICAgICAgICAgICBpZiAoIWJhdGNoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYmF0Y2hJbmdlc3RSdW5zKHtcbiAgICAgICAgICAgICAgICAgICAgcnVuQ3JlYXRlczogYmF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0uYWN0aW9uID09PSBcImNyZWF0ZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoaXRlbSkgPT4gaXRlbS5pdGVtKSxcbiAgICAgICAgICAgICAgICAgICAgcnVuVXBkYXRlczogYmF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0uYWN0aW9uID09PSBcInVwZGF0ZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoaXRlbSkgPT4gaXRlbS5pdGVtKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwcm9jZXNzUnVuT3BlcmF0aW9uKGl0ZW0sIGltbWVkaWF0ZWx5VHJpZ2dlckJhdGNoKSB7XG4gICAgICAgIGNvbnN0IG9sZFRpbWVvdXQgPSB0aGlzLmF1dG9CYXRjaFRpbWVvdXQ7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmF1dG9CYXRjaFRpbWVvdXQpO1xuICAgICAgICB0aGlzLmF1dG9CYXRjaFRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGl0ZW1Qcm9taXNlID0gdGhpcy5hdXRvQmF0Y2hRdWV1ZS5wdXNoKGl0ZW0pO1xuICAgICAgICBpZiAoaW1tZWRpYXRlbHlUcmlnZ2VyQmF0Y2ggfHxcbiAgICAgICAgICAgIHRoaXMuYXV0b0JhdGNoUXVldWUuc2l6ZSA+IHRoaXMucGVuZGluZ0F1dG9CYXRjaGVkUnVuTGltaXQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZHJhaW5BdXRvQmF0Y2hRdWV1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF1dG9CYXRjaFF1ZXVlLnNpemUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmF1dG9CYXRjaFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9CYXRjaFRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBlcnJvciB3b3VsZCBoYXBwZW4gaW4gdGhlIGJhY2tncm91bmQgYW5kIGlzIHVuY2F0Y2hhYmxlXG4gICAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgb3V0c2lkZS4gU28ganVzdCBsb2cgaW5zdGVhZC5cbiAgICAgICAgICAgICAgICB2b2lkIHRoaXMuZHJhaW5BdXRvQmF0Y2hRdWV1ZSgpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgICAgICAgICAgfSwgb2xkVGltZW91dFxuICAgICAgICAgICAgICAgID8gdGhpcy5hdXRvQmF0Y2hBZ2dyZWdhdGlvbkRlbGF5TXNcbiAgICAgICAgICAgICAgICA6IHRoaXMuYXV0b0JhdGNoSW5pdGlhbERlbGF5TXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtUHJvbWlzZTtcbiAgICB9XG4gICAgYXN5bmMgX2dldFNlcnZlckluZm8oKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2luZm9gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgLy8gY29uc3VtZSB0aGUgcmVzcG9uc2UgYm9keSB0byByZWxlYXNlIHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAgICAvLyBodHRwczovL3VuZGljaS5ub2RlanMub3JnLyMvP2lkPWdhcmJhZ2UtY29sbGVjdGlvblxuICAgICAgICAgICAgYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHJldHJpZXZlIHNlcnZlciBpbmZvLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyBiYXRjaEVuZHBvaW50SXNTdXBwb3J0ZWQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnNlcnZlckluZm8gPSBhd2FpdCB0aGlzLl9nZXRTZXJ2ZXJJbmZvKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlUnVuKHJ1bikge1xuICAgICAgICBpZiAoIXRoaXMuX2ZpbHRlckZvclNhbXBsaW5nKFtydW5dKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0geyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH07XG4gICAgICAgIGNvbnN0IHNlc3Npb25fbmFtZSA9IHJ1bi5wcm9qZWN0X25hbWU7XG4gICAgICAgIGRlbGV0ZSBydW4ucHJvamVjdF9uYW1lO1xuICAgICAgICBjb25zdCBydW5DcmVhdGUgPSB0aGlzLnByZXBhcmVSdW5DcmVhdGVPclVwZGF0ZUlucHV0cyh7XG4gICAgICAgICAgICBzZXNzaW9uX25hbWUsXG4gICAgICAgICAgICAuLi5ydW4sXG4gICAgICAgICAgICBzdGFydF90aW1lOiBydW4uc3RhcnRfdGltZSA/PyBEYXRlLm5vdygpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0JhdGNoVHJhY2luZyAmJlxuICAgICAgICAgICAgcnVuQ3JlYXRlLnRyYWNlX2lkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHJ1bkNyZWF0ZS5kb3R0ZWRfb3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdm9pZCB0aGlzLnByb2Nlc3NSdW5PcGVyYXRpb24oe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJjcmVhdGVcIixcbiAgICAgICAgICAgICAgICBpdGVtOiBydW5DcmVhdGUsXG4gICAgICAgICAgICB9KS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXJnZWRSdW5DcmVhdGVQYXJhbXMgPSBhd2FpdCBtZXJnZVJ1bnRpbWVFbnZJbnRvUnVuQ3JlYXRlcyhbXG4gICAgICAgICAgICBydW5DcmVhdGUsXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9ydW5zYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShtZXJnZWRSdW5DcmVhdGVQYXJhbXNbMF0pLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJjcmVhdGUgcnVuXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCYXRjaCBpbmdlc3QvdXBzZXJ0IG11bHRpcGxlIHJ1bnMgaW4gdGhlIExhbmdzbWl0aCBzeXN0ZW0uXG4gICAgICogQHBhcmFtIHJ1bnNcbiAgICAgKi9cbiAgICBhc3luYyBiYXRjaEluZ2VzdFJ1bnMoeyBydW5DcmVhdGVzLCBydW5VcGRhdGVzLCB9KSB7XG4gICAgICAgIGlmIChydW5DcmVhdGVzID09PSB1bmRlZmluZWQgJiYgcnVuVXBkYXRlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByZXBhcmVkQ3JlYXRlUGFyYW1zID0gcnVuQ3JlYXRlcz8ubWFwKChjcmVhdGUpID0+IHRoaXMucHJlcGFyZVJ1bkNyZWF0ZU9yVXBkYXRlSW5wdXRzKGNyZWF0ZSkpID8/IFtdO1xuICAgICAgICBsZXQgcHJlcGFyZWRVcGRhdGVQYXJhbXMgPSBydW5VcGRhdGVzPy5tYXAoKHVwZGF0ZSkgPT4gdGhpcy5wcmVwYXJlUnVuQ3JlYXRlT3JVcGRhdGVJbnB1dHModXBkYXRlKSkgPz8gW107XG4gICAgICAgIGlmIChwcmVwYXJlZENyZWF0ZVBhcmFtcy5sZW5ndGggPiAwICYmIHByZXBhcmVkVXBkYXRlUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZUJ5SWQgPSBwcmVwYXJlZENyZWF0ZVBhcmFtcy5yZWR1Y2UoKHBhcmFtcywgcnVuKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFydW4uaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyYW1zW3J1bi5pZF0gPSBydW47XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW5kYWxvbmVVcGRhdGVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHVwZGF0ZVBhcmFtIG9mIHByZXBhcmVkVXBkYXRlUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZVBhcmFtLmlkICE9PSB1bmRlZmluZWQgJiYgY3JlYXRlQnlJZFt1cGRhdGVQYXJhbS5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQnlJZFt1cGRhdGVQYXJhbS5pZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jcmVhdGVCeUlkW3VwZGF0ZVBhcmFtLmlkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnVwZGF0ZVBhcmFtLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhbmRhbG9uZVVwZGF0ZXMucHVzaCh1cGRhdGVQYXJhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlcGFyZWRDcmVhdGVQYXJhbXMgPSBPYmplY3QudmFsdWVzKGNyZWF0ZUJ5SWQpO1xuICAgICAgICAgICAgcHJlcGFyZWRVcGRhdGVQYXJhbXMgPSBzdGFuZGFsb25lVXBkYXRlcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYXdCYXRjaCA9IHtcbiAgICAgICAgICAgIHBvc3Q6IHRoaXMuX2ZpbHRlckZvclNhbXBsaW5nKHByZXBhcmVkQ3JlYXRlUGFyYW1zKSxcbiAgICAgICAgICAgIHBhdGNoOiB0aGlzLl9maWx0ZXJGb3JTYW1wbGluZyhwcmVwYXJlZFVwZGF0ZVBhcmFtcywgdHJ1ZSksXG4gICAgICAgIH07XG4gICAgICAgIGlmICghcmF3QmF0Y2gucG9zdC5sZW5ndGggJiYgIXJhd0JhdGNoLnBhdGNoLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByZXBhcmVkQ3JlYXRlUGFyYW1zID0gYXdhaXQgbWVyZ2VSdW50aW1lRW52SW50b1J1bkNyZWF0ZXMocHJlcGFyZWRDcmVhdGVQYXJhbXMpO1xuICAgICAgICBpZiAodGhpcy5iYXRjaEVuZHBvaW50U3VwcG9ydGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hFbmRwb2ludFN1cHBvcnRlZCA9IGF3YWl0IHRoaXMuYmF0Y2hFbmRwb2ludElzU3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmJhdGNoRW5kcG9pbnRTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b0JhdGNoVHJhY2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcmVwYXJlZENyZWF0ZVBhcmFtIG9mIHJhd0JhdGNoLnBvc3QpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZVJ1bihwcmVwYXJlZENyZWF0ZVBhcmFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJlcGFyZWRVcGRhdGVQYXJhbSBvZiByYXdCYXRjaC5wYXRjaCkge1xuICAgICAgICAgICAgICAgIGlmIChwcmVwYXJlZFVwZGF0ZVBhcmFtLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVSdW4ocHJlcGFyZWRVcGRhdGVQYXJhbS5pZCwgcHJlcGFyZWRVcGRhdGVQYXJhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpemVMaW1pdEJ5dGVzID0gdGhpcy5zZXJ2ZXJJbmZvPy5iYXRjaF9pbmdlc3RfY29uZmlnPy5zaXplX2xpbWl0X2J5dGVzID8/XG4gICAgICAgICAgICBERUZBVUxUX0JBVENIX1NJWkVfTElNSVRfQllURVM7XG4gICAgICAgIGNvbnN0IGJhdGNoQ2h1bmtzID0ge1xuICAgICAgICAgICAgcG9zdDogW10sXG4gICAgICAgICAgICBwYXRjaDogW10sXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjdXJyZW50QmF0Y2hTaXplQnl0ZXMgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGsgb2YgW1wicG9zdFwiLCBcInBhdGNoXCJdKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBrO1xuICAgICAgICAgICAgY29uc3QgYmF0Y2hJdGVtcyA9IHJhd0JhdGNoW2tleV0ucmV2ZXJzZSgpO1xuICAgICAgICAgICAgbGV0IGJhdGNoSXRlbSA9IGJhdGNoSXRlbXMucG9wKCk7XG4gICAgICAgICAgICB3aGlsZSAoYmF0Y2hJdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZEJhdGNoSXRlbSA9IEpTT04uc3RyaW5naWZ5KGJhdGNoSXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRCYXRjaFNpemVCeXRlcyA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEJhdGNoU2l6ZUJ5dGVzICsgc3RyaW5naWZpZWRCYXRjaEl0ZW0ubGVuZ3RoID4gc2l6ZUxpbWl0Qnl0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcG9zdEJhdGNoSW5nZXN0UnVucyhKU09OLnN0cmluZ2lmeShiYXRjaENodW5rcykpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QmF0Y2hTaXplQnl0ZXMgPSAwO1xuICAgICAgICAgICAgICAgICAgICBiYXRjaENodW5rcy5wb3N0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGJhdGNoQ2h1bmtzLnBhdGNoID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRCYXRjaFNpemVCeXRlcyArPSBzdHJpbmdpZmllZEJhdGNoSXRlbS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYmF0Y2hDaHVua3Nba2V5XS5wdXNoKGJhdGNoSXRlbSk7XG4gICAgICAgICAgICAgICAgYmF0Y2hJdGVtID0gYmF0Y2hJdGVtcy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmF0Y2hDaHVua3MucG9zdC5sZW5ndGggPiAwIHx8IGJhdGNoQ2h1bmtzLnBhdGNoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Bvc3RCYXRjaEluZ2VzdFJ1bnMoSlNPTi5zdHJpbmdpZnkoYmF0Y2hDaHVua3MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfcG9zdEJhdGNoSW5nZXN0UnVucyhib2R5KSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAuLi50aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5iYXRjaEluZ2VzdENhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vcnVucy9iYXRjaGAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiYmF0Y2ggY3JlYXRlIHJ1blwiKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlUnVuKHJ1bklkLCBydW4pIHtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGlmIChydW4uaW5wdXRzKSB7XG4gICAgICAgICAgICBydW4uaW5wdXRzID0gdGhpcy5wcm9jZXNzSW5wdXRzKHJ1bi5pbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW4ub3V0cHV0cykge1xuICAgICAgICAgICAgcnVuLm91dHB1dHMgPSB0aGlzLnByb2Nlc3NPdXRwdXRzKHJ1bi5vdXRwdXRzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBVbnRhbmdsZSB0eXBlc1xuICAgICAgICBjb25zdCBkYXRhID0geyAuLi5ydW4sIGlkOiBydW5JZCB9O1xuICAgICAgICBpZiAoIXRoaXMuX2ZpbHRlckZvclNhbXBsaW5nKFtkYXRhXSwgdHJ1ZSkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXV0b0JhdGNoVHJhY2luZyAmJlxuICAgICAgICAgICAgZGF0YS50cmFjZV9pZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBkYXRhLmRvdHRlZF9vcmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAocnVuLmVuZF90aW1lICE9PSB1bmRlZmluZWQgJiYgZGF0YS5wYXJlbnRfcnVuX2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIGEgYmF0Y2ggYXMgc29vbiBhcyBhIHJvb3QgdHJhY2UgZW5kcyBhbmQgYmxvY2sgdG8gZW5zdXJlIHRyYWNlIGZpbmlzaGVzXG4gICAgICAgICAgICAgICAgLy8gaW4gc2VydmVybGVzcyBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzUnVuT3BlcmF0aW9uKHsgYWN0aW9uOiBcInVwZGF0ZVwiLCBpdGVtOiBkYXRhIH0sIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5wcm9jZXNzUnVuT3BlcmF0aW9uKHsgYWN0aW9uOiBcInVwZGF0ZVwiLCBpdGVtOiBkYXRhIH0pLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vcnVucy8ke3J1bklkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJ1biksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVwZGF0ZSBydW5cIik7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRSdW4ocnVuSWQsIHsgbG9hZENoaWxkUnVucyB9ID0geyBsb2FkQ2hpbGRSdW5zOiBmYWxzZSB9KSB7XG4gICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICBsZXQgcnVuID0gYXdhaXQgdGhpcy5fZ2V0KGAvcnVucy8ke3J1bklkfWApO1xuICAgICAgICBpZiAobG9hZENoaWxkUnVucyAmJiBydW4uY2hpbGRfcnVuX2lkcykge1xuICAgICAgICAgICAgcnVuID0gYXdhaXQgdGhpcy5fbG9hZENoaWxkUnVucyhydW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxuICAgIGFzeW5jIGdldFJ1blVybCh7IHJ1bklkLCBydW4sIHByb2plY3RPcHRzLCB9KSB7XG4gICAgICAgIGlmIChydW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IHNlc3Npb25JZDtcbiAgICAgICAgICAgIGlmIChydW4uc2Vzc2lvbl9pZCkge1xuICAgICAgICAgICAgICAgIHNlc3Npb25JZCA9IHJ1bi5zZXNzaW9uX2lkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvamVjdE9wdHM/LnByb2plY3ROYW1lKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkID0gKGF3YWl0IHRoaXMucmVhZFByb2plY3QoeyBwcm9qZWN0TmFtZTogcHJvamVjdE9wdHM/LnByb2plY3ROYW1lIH0pKS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb2plY3RPcHRzPy5wcm9qZWN0SWQpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQgPSBwcm9qZWN0T3B0cz8ucHJvamVjdElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvamVjdCA9IGF3YWl0IHRoaXMucmVhZFByb2plY3Qoe1xuICAgICAgICAgICAgICAgICAgICBwcm9qZWN0TmFtZTogZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9QUk9KRUNUXCIpIHx8IFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlc3Npb25JZCA9IHByb2plY3QuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ZW5hbnRJZCA9IGF3YWl0IHRoaXMuX2dldFRlbmFudElkKCk7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L28vJHt0ZW5hbnRJZH0vcHJvamVjdHMvcC8ke3Nlc3Npb25JZH0vci8ke3J1bi5pZH0/cG9sbD10cnVlYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChydW5JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBydW5fID0gYXdhaXQgdGhpcy5yZWFkUnVuKHJ1bklkKTtcbiAgICAgICAgICAgIGlmICghcnVuXy5hcHBfcGF0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUnVuICR7cnVuSWR9IGhhcyBubyBhcHBfcGF0aGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmFzZVVybCA9IHRoaXMuZ2V0SG9zdFVybCgpO1xuICAgICAgICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9JHtydW5fLmFwcF9wYXRofWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHJ1bklkIG9yIHJ1blwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfbG9hZENoaWxkUnVucyhydW4pIHtcbiAgICAgICAgY29uc3QgY2hpbGRSdW5zID0gYXdhaXQgdG9BcnJheSh0aGlzLmxpc3RSdW5zKHsgaWQ6IHJ1bi5jaGlsZF9ydW5faWRzIH0pKTtcbiAgICAgICAgY29uc3QgdHJlZW1hcCA9IHt9O1xuICAgICAgICBjb25zdCBydW5zID0ge307XG4gICAgICAgIC8vIFRPRE86IG1ha2UgZG90dGVkIG9yZGVyIHJlcXVpcmVkIHdoZW4gdGhlIG1pZ3JhdGlvbiBmaW5pc2hlc1xuICAgICAgICBjaGlsZFJ1bnMuc29ydCgoYSwgYikgPT4gKGE/LmRvdHRlZF9vcmRlciA/PyBcIlwiKS5sb2NhbGVDb21wYXJlKGI/LmRvdHRlZF9vcmRlciA/PyBcIlwiKSk7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGRSdW4gb2YgY2hpbGRSdW5zKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRSdW4ucGFyZW50X3J1bl9pZCA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIGNoaWxkUnVuLnBhcmVudF9ydW5faWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2hpbGQgcnVuICR7Y2hpbGRSdW4uaWR9IGhhcyBubyBwYXJlbnRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKGNoaWxkUnVuLnBhcmVudF9ydW5faWQgaW4gdHJlZW1hcCkpIHtcbiAgICAgICAgICAgICAgICB0cmVlbWFwW2NoaWxkUnVuLnBhcmVudF9ydW5faWRdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmVlbWFwW2NoaWxkUnVuLnBhcmVudF9ydW5faWRdLnB1c2goY2hpbGRSdW4pO1xuICAgICAgICAgICAgcnVuc1tjaGlsZFJ1bi5pZF0gPSBjaGlsZFJ1bjtcbiAgICAgICAgfVxuICAgICAgICBydW4uY2hpbGRfcnVucyA9IHRyZWVtYXBbcnVuLmlkXSB8fCBbXTtcbiAgICAgICAgZm9yIChjb25zdCBydW5JZCBpbiB0cmVlbWFwKSB7XG4gICAgICAgICAgICBpZiAocnVuSWQgIT09IHJ1bi5pZCkge1xuICAgICAgICAgICAgICAgIHJ1bnNbcnVuSWRdLmNoaWxkX3J1bnMgPSB0cmVlbWFwW3J1bklkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IHJ1bnMgZnJvbSB0aGUgTGFuZ1NtaXRoIHNlcnZlci5cbiAgICAgKiBAcGFyYW0gcHJvamVjdElkIC0gVGhlIElEIG9mIHRoZSBwcm9qZWN0IHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gcHJvamVjdE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcHJvamVjdCB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIHBhcmVudFJ1bklkIC0gVGhlIElEIG9mIHRoZSBwYXJlbnQgcnVuIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gdHJhY2VJZCAtIFRoZSBJRCBvZiB0aGUgdHJhY2UgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSByZWZlcmVuY2VFeGFtcGxlSWQgLSBUaGUgSUQgb2YgdGhlIHJlZmVyZW5jZSBleGFtcGxlIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gc3RhcnRUaW1lIC0gVGhlIHN0YXJ0IHRpbWUgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSBleGVjdXRpb25PcmRlciAtIFRoZSBleGVjdXRpb24gb3JkZXIgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSBydW5UeXBlIC0gVGhlIHJ1biB0eXBlIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gZXJyb3IgLSBJbmRpY2F0ZXMgd2hldGhlciB0byBmaWx0ZXIgYnkgZXJyb3IgcnVucy5cbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgSUQgb2YgdGhlIHJ1biB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHN0cmluZyB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIGZpbHRlciAtIFRoZSBmaWx0ZXIgc3RyaW5nIHRvIGFwcGx5IHRvIHRoZSBydW4gc3BhbnMuXG4gICAgICogQHBhcmFtIHRyYWNlRmlsdGVyIC0gVGhlIGZpbHRlciBzdHJpbmcgdG8gYXBwbHkgb24gdGhlIHJvb3QgcnVuIG9mIHRoZSB0cmFjZS5cbiAgICAgKiBAcGFyYW0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcnVucyB0byByZXRyaWV2ZS5cbiAgICAgKiBAcmV0dXJucyB7QXN5bmNJdGVyYWJsZTxSdW4+fSAtIFRoZSBydW5zLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IGFsbCBydW5zIGluIGEgcHJvamVjdFxuICAgICAqIGNvbnN0IHByb2plY3RSdW5zID0gY2xpZW50Lmxpc3RSdW5zKHsgcHJvamVjdE5hbWU6IFwiPHlvdXJfcHJvamVjdD5cIiB9KTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTGlzdCBMTE0gYW5kIENoYXQgcnVucyBpbiB0aGUgbGFzdCAyNCBob3Vyc1xuICAgICAqIGNvbnN0IHRvZGF5c0xMTVJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoe1xuICAgICAqICAgcHJvamVjdE5hbWU6IFwiPHlvdXJfcHJvamVjdD5cIixcbiAgICAgKiAgIHN0YXJ0X3RpbWU6IG5ldyBEYXRlKERhdGUubm93KCkgLSAyNCAqIDYwICogNjAgKiAxMDAwKSxcbiAgICAgKiAgIHJ1bl90eXBlOiBcImxsbVwiLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IHRyYWNlcyBpbiBhIHByb2plY3RcbiAgICAgKiBjb25zdCByb290UnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgZXhlY3V0aW9uX29yZGVyOiAxLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IHJ1bnMgd2l0aG91dCBlcnJvcnNcbiAgICAgKiBjb25zdCBjb3JyZWN0UnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgZXJyb3I6IGZhbHNlLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IHJ1bnMgYnkgcnVuIElEXG4gICAgICogY29uc3QgcnVuSWRzID0gW1xuICAgICAqICAgXCJhMzYwOTJkMi00YWQ1LTRmYjQtOWMwZC0wZGJhOWEyZWQ4MzZcIixcbiAgICAgKiAgIFwiOTM5OGU2YmUtOTY0Zi00YWE0LThhZTktYWQ3OGNkNGI3MDc0XCIsXG4gICAgICogXTtcbiAgICAgKiBjb25zdCBzZWxlY3RlZFJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoeyBydW5faWRzOiBydW5JZHMgfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgYWxsIFwiY2hhaW5cIiB0eXBlIHJ1bnMgdGhhdCB0b29rIG1vcmUgdGhhbiAxMCBzZWNvbmRzIGFuZCBoYWQgYHRvdGFsX3Rva2Vuc2AgZ3JlYXRlciB0aGFuIDUwMDBcbiAgICAgKiBjb25zdCBjaGFpblJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoe1xuICAgICAqICAgcHJvamVjdE5hbWU6IFwiPHlvdXJfcHJvamVjdD5cIixcbiAgICAgKiAgIGZpbHRlcjogJ2FuZChlcShydW5fdHlwZSwgXCJjaGFpblwiKSwgZ3QobGF0ZW5jeSwgMTApLCBndCh0b3RhbF90b2tlbnMsIDUwMDApKScsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgYWxsIHJ1bnMgY2FsbGVkIFwiZXh0cmFjdG9yXCIgd2hvc2Ugcm9vdCBvZiB0aGUgdHJhY2Ugd2FzIGFzc2lnbmVkIGZlZWRiYWNrIFwidXNlcl9zY29yZVwiIHNjb3JlIG9mIDFcbiAgICAgKiBjb25zdCBnb29kRXh0cmFjdG9yUnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgZmlsdGVyOiAnZXEobmFtZSwgXCJleHRyYWN0b3JcIiknLFxuICAgICAqICAgdHJhY2VGaWx0ZXI6ICdhbmQoZXEoZmVlZGJhY2tfa2V5LCBcInVzZXJfc2NvcmVcIiksIGVxKGZlZWRiYWNrX3Njb3JlLCAxKSknLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IGFsbCBydW5zIHRoYXQgc3RhcnRlZCBhZnRlciBhIHNwZWNpZmljIHRpbWVzdGFtcCBhbmQgZWl0aGVyIGhhdmUgXCJlcnJvclwiIG5vdCBlcXVhbCB0byBudWxsIG9yIGEgXCJDb3JyZWN0bmVzc1wiIGZlZWRiYWNrIHNjb3JlIGVxdWFsIHRvIDBcbiAgICAgKiBjb25zdCBjb21wbGV4UnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgZmlsdGVyOiAnYW5kKGd0KHN0YXJ0X3RpbWUsIFwiMjAyMy0wNy0xNVQxMjozNDo1NlpcIiksIG9yKG5lcShlcnJvciwgbnVsbCksIGFuZChlcShmZWVkYmFja19rZXksIFwiQ29ycmVjdG5lc3NcIiksIGVxKGZlZWRiYWNrX3Njb3JlLCAwLjApKSkpJyxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTGlzdCBhbGwgcnVucyB3aGVyZSBgdGFnc2AgaW5jbHVkZSBcImV4cGVyaW1lbnRhbFwiIG9yIFwiYmV0YVwiIGFuZCBgbGF0ZW5jeWAgaXMgZ3JlYXRlciB0aGFuIDIgc2Vjb25kc1xuICAgICAqIGNvbnN0IHRhZ2dlZFJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoe1xuICAgICAqICAgcHJvamVjdE5hbWU6IFwiPHlvdXJfcHJvamVjdD5cIixcbiAgICAgKiAgIGZpbHRlcjogJ2FuZChvcihoYXModGFncywgXCJleHBlcmltZW50YWxcIiksIGhhcyh0YWdzLCBcImJldGFcIikpLCBndChsYXRlbmN5LCAyKSknLFxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGFzeW5jICpsaXN0UnVucyhwcm9wcykge1xuICAgICAgICBjb25zdCB7IHByb2plY3RJZCwgcHJvamVjdE5hbWUsIHBhcmVudFJ1bklkLCB0cmFjZUlkLCByZWZlcmVuY2VFeGFtcGxlSWQsIHN0YXJ0VGltZSwgZXhlY3V0aW9uT3JkZXIsIHJ1blR5cGUsIGVycm9yLCBpZCwgcXVlcnksIGZpbHRlciwgdHJhY2VGaWx0ZXIsIGxpbWl0LCB9ID0gcHJvcHM7XG4gICAgICAgIGxldCBwcm9qZWN0SWRzID0gW107XG4gICAgICAgIGlmIChwcm9qZWN0SWQpIHtcbiAgICAgICAgICAgIHByb2plY3RJZHMgPSBBcnJheS5pc0FycmF5KHByb2plY3RJZCkgPyBwcm9qZWN0SWQgOiBbcHJvamVjdElkXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvamVjdE5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb2plY3ROYW1lcyA9IEFycmF5LmlzQXJyYXkocHJvamVjdE5hbWUpXG4gICAgICAgICAgICAgICAgPyBwcm9qZWN0TmFtZVxuICAgICAgICAgICAgICAgIDogW3Byb2plY3ROYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IHByb2plY3RJZHNfID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvamVjdE5hbWVzLm1hcCgobmFtZSkgPT4gdGhpcy5yZWFkUHJvamVjdCh7IHByb2plY3ROYW1lOiBuYW1lIH0pLnRoZW4oKHByb2plY3QpID0+IHByb2plY3QuaWQpKSk7XG4gICAgICAgICAgICBwcm9qZWN0SWRzLnB1c2goLi4ucHJvamVjdElkc18pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBzZXNzaW9uOiBwcm9qZWN0SWRzLmxlbmd0aCA/IHByb2plY3RJZHMgOiBudWxsLFxuICAgICAgICAgICAgcnVuX3R5cGU6IHJ1blR5cGUsXG4gICAgICAgICAgICByZWZlcmVuY2VfZXhhbXBsZTogcmVmZXJlbmNlRXhhbXBsZUlkLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICB0cmFjZV9maWx0ZXI6IHRyYWNlRmlsdGVyLFxuICAgICAgICAgICAgZXhlY3V0aW9uX29yZGVyOiBleGVjdXRpb25PcmRlcixcbiAgICAgICAgICAgIHBhcmVudF9ydW46IHBhcmVudFJ1bklkID8gW3BhcmVudFJ1bklkXSA6IG51bGwsXG4gICAgICAgICAgICBzdGFydF90aW1lOiBzdGFydFRpbWUgPyBzdGFydFRpbWUudG9JU09TdHJpbmcoKSA6IG51bGwsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbGltaXQsXG4gICAgICAgICAgICB0cmFjZTogdHJhY2VJZCxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBydW5zIG9mIHRoaXMuX2dldEN1cnNvclBhZ2luYXRlZExpc3QoXCIvcnVucy9xdWVyeVwiLCBib2R5KSkge1xuICAgICAgICAgICAgeWllbGQqIHJ1bnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2hhcmVSdW4ocnVuSWQsIHsgc2hhcmVJZCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuSWQsXG4gICAgICAgICAgICBzaGFyZV90b2tlbjogc2hhcmVJZCB8fCB1dWlkLnY0KCksXG4gICAgICAgIH07XG4gICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9ydW5zLyR7cnVuSWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCAhKFwic2hhcmVfdG9rZW5cIiBpbiByZXN1bHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIGZyb20gc2VydmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHVibGljLyR7cmVzdWx0W1wic2hhcmVfdG9rZW5cIl19L3JgO1xuICAgIH1cbiAgICBhc3luYyB1bnNoYXJlUnVuKHJ1bklkKSB7XG4gICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9ydW5zLyR7cnVuSWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1bnNoYXJlIHJ1blwiKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZFJ1blNoYXJlZExpbmsocnVuSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgYCR7dGhpcy5hcGlVcmx9L3J1bnMvJHtydW5JZH0vc2hhcmVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCAhKFwic2hhcmVfdG9rZW5cIiBpbiByZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHVibGljLyR7cmVzdWx0W1wic2hhcmVfdG9rZW5cIl19L3JgO1xuICAgIH1cbiAgICBhc3luYyBsaXN0U2hhcmVkUnVucyhzaGFyZVRva2VuLCB7IHJ1bklkcywgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICBzaGFyZV90b2tlbjogc2hhcmVUb2tlbixcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChydW5JZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBydW5JZCBvZiBydW5JZHMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJpZFwiLCBydW5JZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChzaGFyZVRva2VuKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vcHVibGljLyR7c2hhcmVUb2tlbn0vcnVucyR7cXVlcnlQYXJhbXN9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBydW5zID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcnVucztcbiAgICB9XG4gICAgYXN5bmMgcmVhZERhdGFzZXRTaGFyZWRTY2hlbWEoZGF0YXNldElkLCBkYXRhc2V0TmFtZSkge1xuICAgICAgICBpZiAoIWRhdGFzZXRJZCAmJiAhZGF0YXNldE5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVpdGhlciBkYXRhc2V0SWQgb3IgZGF0YXNldE5hbWUgbXVzdCBiZSBnaXZlblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFzZXRJZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZCA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke2RhdGFzZXRJZH0vc2hhcmVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNoYXJlU2NoZW1hID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBzaGFyZVNjaGVtYS51cmwgPSBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHVibGljLyR7c2hhcmVTY2hlbWEuc2hhcmVfdG9rZW59L2RgO1xuICAgICAgICByZXR1cm4gc2hhcmVTY2hlbWE7XG4gICAgfVxuICAgIGFzeW5jIHNoYXJlRGF0YXNldChkYXRhc2V0SWQsIGRhdGFzZXROYW1lKSB7XG4gICAgICAgIGlmICghZGF0YXNldElkICYmICFkYXRhc2V0TmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWl0aGVyIGRhdGFzZXRJZCBvciBkYXRhc2V0TmFtZSBtdXN0IGJlIGdpdmVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YXNldElkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgZGF0YXNldF9pZDogZGF0YXNldElkLFxuICAgICAgICB9O1xuICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7ZGF0YXNldElkfS9zaGFyZWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzaGFyZVNjaGVtYSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgc2hhcmVTY2hlbWEudXJsID0gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L3B1YmxpYy8ke3NoYXJlU2NoZW1hLnNoYXJlX3Rva2VufS9kYDtcbiAgICAgICAgcmV0dXJuIHNoYXJlU2NoZW1hO1xuICAgIH1cbiAgICBhc3luYyB1bnNoYXJlRGF0YXNldChkYXRhc2V0SWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke2RhdGFzZXRJZH0vc2hhcmVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVuc2hhcmUgZGF0YXNldFwiKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZFNoYXJlZERhdGFzZXQoc2hhcmVUb2tlbikge1xuICAgICAgICBhc3NlcnRVdWlkKHNoYXJlVG9rZW4pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9wdWJsaWMvJHtzaGFyZVRva2VufS9kYXRhc2V0c2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZVByb2plY3QoeyBwcm9qZWN0TmFtZSwgZGVzY3JpcHRpb24gPSBudWxsLCBtZXRhZGF0YSA9IG51bGwsIHVwc2VydCA9IGZhbHNlLCBwcm9qZWN0RXh0cmEgPSBudWxsLCByZWZlcmVuY2VEYXRhc2V0SWQgPSBudWxsLCB9KSB7XG4gICAgICAgIGNvbnN0IHVwc2VydF8gPSB1cHNlcnQgPyBgP3Vwc2VydD10cnVlYCA6IFwiXCI7XG4gICAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7dGhpcy5hcGlVcmx9L3Nlc3Npb25zJHt1cHNlcnRffWA7XG4gICAgICAgIGNvbnN0IGV4dHJhID0gcHJvamVjdEV4dHJhIHx8IHt9O1xuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGV4dHJhW1wibWV0YWRhdGFcIl0gPSBtZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgbmFtZTogcHJvamVjdE5hbWUsXG4gICAgICAgICAgICBleHRyYSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVmZXJlbmNlRGF0YXNldElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBib2R5W1wicmVmZXJlbmNlX2RhdGFzZXRfaWRcIl0gPSByZWZlcmVuY2VEYXRhc2V0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBlbmRwb2ludCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIHNlc3Npb24gJHtwcm9qZWN0TmFtZX06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlUHJvamVjdChwcm9qZWN0SWQsIHsgbmFtZSA9IG51bGwsIGRlc2NyaXB0aW9uID0gbnVsbCwgbWV0YWRhdGEgPSBudWxsLCBwcm9qZWN0RXh0cmEgPSBudWxsLCBlbmRUaW1lID0gbnVsbCwgfSkge1xuICAgICAgICBjb25zdCBlbmRwb2ludCA9IGAke3RoaXMuYXBpVXJsfS9zZXNzaW9ucy8ke3Byb2plY3RJZH1gO1xuICAgICAgICBsZXQgZXh0cmEgPSBwcm9qZWN0RXh0cmE7XG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgZXh0cmEgPSB7IC4uLihleHRyYSB8fCB7fSksIG1ldGFkYXRhIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBleHRyYSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgZW5kX3RpbWU6IGVuZFRpbWUgPyBuZXcgRGF0ZShlbmRUaW1lKS50b0lTT1N0cmluZygpIDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBlbmRwb2ludCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHVwZGF0ZSBwcm9qZWN0ICR7cHJvamVjdElkfTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBoYXNQcm9qZWN0KHsgcHJvamVjdElkLCBwcm9qZWN0TmFtZSwgfSkge1xuICAgICAgICAvLyBUT0RPOiBBZGQgYSBoZWFkIHJlcXVlc3RcbiAgICAgICAgbGV0IHBhdGggPSBcIi9zZXNzaW9uc1wiO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHByb2plY3ROYW1lIG9yIHByb2plY3RJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQocHJvamVjdElkKTtcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke3Byb2plY3RJZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2plY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIHByb2plY3ROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBwcm9qZWN0TmFtZSBvciBwcm9qZWN0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0ke3BhdGh9PyR7cGFyYW1zfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gY29uc3VtZSB0aGUgcmVzcG9uc2UgYm9keSB0byByZWxlYXNlIHRoZSBjb25uZWN0aW9uXG4gICAgICAgIC8vIGh0dHBzOi8vdW5kaWNpLm5vZGVqcy5vcmcvIy8/aWQ9Z2FyYmFnZS1jb2xsZWN0aW9uXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgaXQncyBPSyBhbmQgd2UncmUgcXVlcnlpbmcgYnkgbmFtZSwgbmVlZCB0byBjaGVjayB0aGUgbGlzdCBpcyBub3QgZW1wdHlcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA+IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwcm9qZWN0SWQgcXVlcnlpbmdcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVhZFByb2plY3QoeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCBpbmNsdWRlU3RhdHMsIH0pIHtcbiAgICAgICAgbGV0IHBhdGggPSBcIi9zZXNzaW9uc1wiO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHByb2plY3ROYW1lIG9yIHByb2plY3RJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQocHJvamVjdElkKTtcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke3Byb2plY3RJZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2plY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIHByb2plY3ROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBwcm9qZWN0TmFtZSBvciBwcm9qZWN0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY2x1ZGVTdGF0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaW5jbHVkZV9zdGF0c1wiLCBpbmNsdWRlU3RhdHMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9qZWN0W2lkPSR7cHJvamVjdElkfSwgbmFtZT0ke3Byb2plY3ROYW1lfV0gbm90IGZvdW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSByZXNwb25zZVswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRUZW5hbnRJZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RlbmFudElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGVuYW50SWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgbGltaXQ6IFwiMVwiIH0pO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHByb2plY3RzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9zZXNzaW9uc1wiLCBxdWVyeVBhcmFtcykpIHtcbiAgICAgICAgICAgIHRoaXMuX3RlbmFudElkID0gcHJvamVjdHNbMF0udGVuYW50X2lkO1xuICAgICAgICAgICAgcmV0dXJuIHByb2plY3RzWzBdLnRlbmFudF9pZDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwcm9qZWN0cyBmb3VuZCB0byByZXNvbHZlIHRlbmFudC5cIik7XG4gICAgfVxuICAgIGFzeW5jICpsaXN0UHJvamVjdHMoeyBwcm9qZWN0SWRzLCBuYW1lLCBuYW1lQ29udGFpbnMsIHJlZmVyZW5jZURhdGFzZXRJZCwgcmVmZXJlbmNlRGF0YXNldE5hbWUsIHJlZmVyZW5jZUZyZWUsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmIChwcm9qZWN0SWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvamVjdElkIG9mIHByb2plY3RJZHMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaWRcIiwgcHJvamVjdElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZUNvbnRhaW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lX2NvbnRhaW5zXCIsIG5hbWVDb250YWlucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZmVyZW5jZURhdGFzZXRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwicmVmZXJlbmNlX2RhdGFzZXRcIiwgcmVmZXJlbmNlRGF0YXNldElkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWZlcmVuY2VEYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7XG4gICAgICAgICAgICAgICAgZGF0YXNldE5hbWU6IHJlZmVyZW5jZURhdGFzZXROYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwicmVmZXJlbmNlX2RhdGFzZXRcIiwgZGF0YXNldC5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZmVyZW5jZUZyZWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcInJlZmVyZW5jZV9mcmVlXCIsIHJlZmVyZW5jZUZyZWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBwcm9qZWN0cyBvZiB0aGlzLl9nZXRQYWdpbmF0ZWQoXCIvc2Vzc2lvbnNcIiwgcGFyYW1zKSkge1xuICAgICAgICAgICAgeWllbGQqIHByb2plY3RzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZVByb2plY3QoeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCB9KSB7XG4gICAgICAgIGxldCBwcm9qZWN0SWRfO1xuICAgICAgICBpZiAocHJvamVjdElkID09PSB1bmRlZmluZWQgJiYgcHJvamVjdE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIHByb2plY3ROYW1lIG9yIHByb2plY3RJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHByb2plY3ROYW1lIG9yIHByb2plY3RJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByb2plY3RJZF8gPSAoYXdhaXQgdGhpcy5yZWFkUHJvamVjdCh7IHByb2plY3ROYW1lIH0pKS5pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByb2plY3RJZF8gPSBwcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChwcm9qZWN0SWRfKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vc2Vzc2lvbnMvJHtwcm9qZWN0SWRffWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIGBkZWxldGUgc2Vzc2lvbiAke3Byb2plY3RJZF99ICgke3Byb2plY3ROYW1lfSlgKTtcbiAgICB9XG4gICAgYXN5bmMgdXBsb2FkQ3N2KHsgY3N2RmlsZSwgZmlsZU5hbWUsIGlucHV0S2V5cywgb3V0cHV0S2V5cywgZGVzY3JpcHRpb24sIGRhdGFUeXBlLCBuYW1lLCB9KSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy91cGxvYWRgO1xuICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlXCIsIGNzdkZpbGUsIGZpbGVOYW1lKTtcbiAgICAgICAgaW5wdXRLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiaW5wdXRfa2V5c1wiLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0S2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcIm91dHB1dF9rZXlzXCIsIGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImRlc2NyaXB0aW9uXCIsIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YVR5cGUpIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImRhdGFfdHlwZVwiLCBkYXRhVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCB1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5kZXRhaWwgJiYgcmVzdWx0LmRldGFpbC5pbmNsdWRlcyhcImFscmVhZHkgZXhpc3RzXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhc2V0ICR7ZmlsZU5hbWV9IGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB1cGxvYWQgQ1NWOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlRGF0YXNldChuYW1lLCB7IGRlc2NyaXB0aW9uLCBkYXRhVHlwZSwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChkYXRhVHlwZSkge1xuICAgICAgICAgICAgYm9keS5kYXRhX3R5cGUgPSBkYXRhVHlwZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0c2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmRldGFpbCAmJiByZXN1bHQuZGV0YWlsLmluY2x1ZGVzKFwiYWxyZWFkeSBleGlzdHNcIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERhdGFzZXQgJHtuYW1lfSBhbHJlYWR5IGV4aXN0c2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIGRhdGFzZXQgJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHJlYWREYXRhc2V0KHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgfSkge1xuICAgICAgICBsZXQgcGF0aCA9IFwiL2RhdGFzZXRzXCI7XG4gICAgICAgIC8vIGxpbWl0IHRvIDEgcmVzdWx0XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBsaW1pdDogXCIxXCIgfSk7XG4gICAgICAgIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQoZGF0YXNldElkKTtcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke2RhdGFzZXRJZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIGRhdGFzZXROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhc2V0W2lkPSR7ZGF0YXNldElkfSwgbmFtZT0ke2RhdGFzZXROYW1lfV0gbm90IGZvdW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSByZXNwb25zZVswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHJlYWREYXRhc2V0T3BlbmFpRmluZXR1bmluZyh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIH0pIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IFwiL2RhdGFzZXRzXCI7XG4gICAgICAgIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXRJZCA9IChhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSkpLmlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldFJlc3BvbnNlKGAke3BhdGh9LyR7ZGF0YXNldElkfS9vcGVuYWlfZnRgKTtcbiAgICAgICAgY29uc3QgZGF0YXNldFRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIGNvbnN0IGRhdGFzZXQgPSBkYXRhc2V0VGV4dFxuICAgICAgICAgICAgLnRyaW0oKVxuICAgICAgICAgICAgLnNwbGl0KFwiXFxuXCIpXG4gICAgICAgICAgICAubWFwKChsaW5lKSA9PiBKU09OLnBhcnNlKGxpbmUpKTtcbiAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICAgIGFzeW5jICpsaXN0RGF0YXNldHMoeyBsaW1pdCA9IDEwMCwgb2Zmc2V0ID0gMCwgZGF0YXNldElkcywgZGF0YXNldE5hbWUsIGRhdGFzZXROYW1lQ29udGFpbnMsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBwYXRoID0gXCIvZGF0YXNldHNcIjtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICBsaW1pdDogbGltaXQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LnRvU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGF0YXNldElkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlkXyBvZiBkYXRhc2V0SWRzKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImlkXCIsIGlkXyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIGRhdGFzZXROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YXNldE5hbWVDb250YWlucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZV9jb250YWluc1wiLCBkYXRhc2V0TmFtZUNvbnRhaW5zKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGRhdGFzZXRzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChwYXRoLCBwYXJhbXMpKSB7XG4gICAgICAgICAgICB5aWVsZCogZGF0YXNldHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlRGF0YXNldCh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIH0pIHtcbiAgICAgICAgbGV0IHBhdGggPSBcIi9kYXRhc2V0c1wiO1xuICAgICAgICBsZXQgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgaWYgKGRhdGFzZXRJZCAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXRJZF8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWRfKTtcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke2RhdGFzZXRJZF99YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCB0aGlzLmFwaVVybCArIHBhdGgsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZGVsZXRlICR7cGF0aH06ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVFeGFtcGxlKGlucHV0cywgb3V0cHV0cywgeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCBjcmVhdGVkQXQsIGV4YW1wbGVJZCB9KSB7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3JlYXRlZEF0XyA9IGNyZWF0ZWRBdCB8fCBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgZGF0YXNldF9pZDogZGF0YXNldElkXyxcbiAgICAgICAgICAgIGlucHV0cyxcbiAgICAgICAgICAgIG91dHB1dHMsXG4gICAgICAgICAgICBjcmVhdGVkX2F0OiBjcmVhdGVkQXRfPy50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgaWQ6IGV4YW1wbGVJZCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCBgJHt0aGlzLmFwaVVybH0vZXhhbXBsZXNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIGV4YW1wbGU6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVFeGFtcGxlcyhwcm9wcykge1xuICAgICAgICBjb25zdCB7IGlucHV0cywgb3V0cHV0cywgc291cmNlUnVuSWRzLCBleGFtcGxlSWRzLCBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCB9ID0gcHJvcHM7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9ybWF0dGVkRXhhbXBsZXMgPSBpbnB1dHMubWFwKChpbnB1dCwgaWR4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGFzZXRfaWQ6IGRhdGFzZXRJZF8sXG4gICAgICAgICAgICAgICAgaW5wdXRzOiBpbnB1dCxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiBvdXRwdXRzID8gb3V0cHV0c1tpZHhdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGlkOiBleGFtcGxlSWRzID8gZXhhbXBsZUlkc1tpZHhdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHNvdXJjZV9ydW5faWQ6IHNvdXJjZVJ1bklkcyA/IHNvdXJjZVJ1bklkc1tpZHhdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgYCR7dGhpcy5hcGlVcmx9L2V4YW1wbGVzL2J1bGtgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShmb3JtYXR0ZWRFeGFtcGxlcyksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBleGFtcGxlczogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUxMTUV4YW1wbGUoaW5wdXQsIGdlbmVyYXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXhhbXBsZSh7IGlucHV0IH0sIHsgb3V0cHV0OiBnZW5lcmF0aW9uIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVDaGF0RXhhbXBsZShpbnB1dCwgZ2VuZXJhdGlvbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZmluYWxJbnB1dCA9IGlucHV0Lm1hcCgobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzTGFuZ0NoYWluTWVzc2FnZShtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0TGFuZ0NoYWluTWVzc2FnZVRvRXhhbXBsZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZmluYWxPdXRwdXQgPSBpc0xhbmdDaGFpbk1lc3NhZ2UoZ2VuZXJhdGlvbnMpXG4gICAgICAgICAgICA/IGNvbnZlcnRMYW5nQ2hhaW5NZXNzYWdlVG9FeGFtcGxlKGdlbmVyYXRpb25zKVxuICAgICAgICAgICAgOiBnZW5lcmF0aW9ucztcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXhhbXBsZSh7IGlucHV0OiBmaW5hbElucHV0IH0sIHsgb3V0cHV0OiBmaW5hbE91dHB1dCB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZEV4YW1wbGUoZXhhbXBsZUlkKSB7XG4gICAgICAgIGFzc2VydFV1aWQoZXhhbXBsZUlkKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvZXhhbXBsZXMvJHtleGFtcGxlSWR9YDtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2dldChwYXRoKTtcbiAgICB9XG4gICAgYXN5bmMgKmxpc3RFeGFtcGxlcyh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIGV4YW1wbGVJZHMsIH0gPSB7fSkge1xuICAgICAgICBsZXQgZGF0YXNldElkXztcbiAgICAgICAgaWYgKGRhdGFzZXRJZCAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgYSBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IGRhdGFzZXQ6IGRhdGFzZXRJZF8gfSk7XG4gICAgICAgIGlmIChleGFtcGxlSWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaWRfIG9mIGV4YW1wbGVJZHMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaWRcIiwgaWRfKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGV4YW1wbGVzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9leGFtcGxlc1wiLCBwYXJhbXMpKSB7XG4gICAgICAgICAgICB5aWVsZCogZXhhbXBsZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlRXhhbXBsZShleGFtcGxlSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChleGFtcGxlSWQpO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9leGFtcGxlcy8ke2V4YW1wbGVJZH1gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIHRoaXMuYXBpVXJsICsgcGF0aCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBkZWxldGUgJHtwYXRofTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUV4YW1wbGUoZXhhbXBsZUlkLCB1cGRhdGUpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChleGFtcGxlSWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIGAke3RoaXMuYXBpVXJsfS9leGFtcGxlcy8ke2V4YW1wbGVJZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodXBkYXRlKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gdXBkYXRlIGV4YW1wbGUgJHtleGFtcGxlSWR9OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgZXZhbHVhdGVSdW4ocnVuLCBldmFsdWF0b3IsIHsgc291cmNlSW5mbywgbG9hZENoaWxkUnVucywgcmVmZXJlbmNlRXhhbXBsZSwgfSA9IHsgbG9hZENoaWxkUnVuczogZmFsc2UgfSkge1xuICAgICAgICBsZXQgcnVuXztcbiAgICAgICAgaWYgKHR5cGVvZiBydW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJ1bl8gPSBhd2FpdCB0aGlzLnJlYWRSdW4ocnVuLCB7IGxvYWRDaGlsZFJ1bnMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJ1biA9PT0gXCJvYmplY3RcIiAmJiBcImlkXCIgaW4gcnVuKSB7XG4gICAgICAgICAgICBydW5fID0gcnVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJ1biB0eXBlOiAke3R5cGVvZiBydW59YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bl8ucmVmZXJlbmNlX2V4YW1wbGVfaWQgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHJ1bl8ucmVmZXJlbmNlX2V4YW1wbGVfaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVmZXJlbmNlRXhhbXBsZSA9IGF3YWl0IHRoaXMucmVhZEV4YW1wbGUocnVuXy5yZWZlcmVuY2VfZXhhbXBsZV9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmVlZGJhY2tSZXN1bHQgPSBhd2FpdCBldmFsdWF0b3IuZXZhbHVhdGVSdW4ocnVuXywgcmVmZXJlbmNlRXhhbXBsZSk7XG4gICAgICAgIGxldCBzb3VyY2VJbmZvXyA9IHNvdXJjZUluZm8gPz8ge307XG4gICAgICAgIGlmIChmZWVkYmFja1Jlc3VsdC5ldmFsdWF0b3JJbmZvKSB7XG4gICAgICAgICAgICBzb3VyY2VJbmZvXyA9IHsgLi4uc291cmNlSW5mb18sIC4uLmZlZWRiYWNrUmVzdWx0LmV2YWx1YXRvckluZm8gfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW5JZCA9IGZlZWRiYWNrUmVzdWx0LnRhcmdldFJ1bklkID8/IHJ1bl8uaWQ7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNyZWF0ZUZlZWRiYWNrKHJ1bklkLCBmZWVkYmFja1Jlc3VsdC5rZXksIHtcbiAgICAgICAgICAgIHNjb3JlOiBmZWVkYmFja1Jlc3VsdD8uc2NvcmUsXG4gICAgICAgICAgICB2YWx1ZTogZmVlZGJhY2tSZXN1bHQ/LnZhbHVlLFxuICAgICAgICAgICAgY29tbWVudDogZmVlZGJhY2tSZXN1bHQ/LmNvbW1lbnQsXG4gICAgICAgICAgICBjb3JyZWN0aW9uOiBmZWVkYmFja1Jlc3VsdD8uY29ycmVjdGlvbixcbiAgICAgICAgICAgIHNvdXJjZUluZm86IHNvdXJjZUluZm9fLFxuICAgICAgICAgICAgZmVlZGJhY2tTb3VyY2VUeXBlOiBcIm1vZGVsXCIsXG4gICAgICAgICAgICBzb3VyY2VSdW5JZDogZmVlZGJhY2tSZXN1bHQ/LnNvdXJjZVJ1bklkLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlRmVlZGJhY2socnVuSWQsIGtleSwgeyBzY29yZSwgdmFsdWUsIGNvcnJlY3Rpb24sIGNvbW1lbnQsIHNvdXJjZUluZm8sIGZlZWRiYWNrU291cmNlVHlwZSA9IFwiYXBpXCIsIHNvdXJjZVJ1bklkLCBmZWVkYmFja0lkLCBlYWdlciA9IGZhbHNlLCB9KSB7XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrX3NvdXJjZSA9IHtcbiAgICAgICAgICAgIHR5cGU6IGZlZWRiYWNrU291cmNlVHlwZSA/PyBcImFwaVwiLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHNvdXJjZUluZm8gPz8ge30sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChzb3VyY2VSdW5JZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBmZWVkYmFja19zb3VyY2U/Lm1ldGFkYXRhICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICFmZWVkYmFja19zb3VyY2UubWV0YWRhdGFbXCJfX3J1blwiXSkge1xuICAgICAgICAgICAgZmVlZGJhY2tfc291cmNlLm1ldGFkYXRhW1wiX19ydW5cIl0gPSB7IHJ1bl9pZDogc291cmNlUnVuSWQgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmVlZGJhY2tfc291cmNlPy5tZXRhZGF0YSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBmZWVkYmFja19zb3VyY2UubWV0YWRhdGFbXCJfX3J1blwiXT8ucnVuX2lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQoZmVlZGJhY2tfc291cmNlLm1ldGFkYXRhW1wiX19ydW5cIl0ucnVuX2lkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmZWVkYmFjayA9IHtcbiAgICAgICAgICAgIGlkOiBmZWVkYmFja0lkID8/IHV1aWQudjQoKSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuSWQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBzY29yZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgY29ycmVjdGlvbixcbiAgICAgICAgICAgIGNvbW1lbnQsXG4gICAgICAgICAgICBmZWVkYmFja19zb3VyY2U6IGZlZWRiYWNrX3NvdXJjZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5hcGlVcmx9L2ZlZWRiYWNrYCArIChlYWdlciA/IFwiL2VhZ2VyXCIgOiBcIlwiKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGZldGNoLCB1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGZlZWRiYWNrKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiY3JlYXRlIGZlZWRiYWNrXCIpO1xuICAgICAgICByZXR1cm4gZmVlZGJhY2s7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUZlZWRiYWNrKGZlZWRiYWNrSWQsIHsgc2NvcmUsIHZhbHVlLCBjb3JyZWN0aW9uLCBjb21tZW50LCB9KSB7XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrVXBkYXRlID0ge307XG4gICAgICAgIGlmIChzY29yZSAhPT0gdW5kZWZpbmVkICYmIHNjb3JlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmZWVkYmFja1VwZGF0ZVtcInNjb3JlXCJdID0gc2NvcmU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZlZWRiYWNrVXBkYXRlW1widmFsdWVcIl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ycmVjdGlvbiAhPT0gdW5kZWZpbmVkICYmIGNvcnJlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZlZWRiYWNrVXBkYXRlW1wiY29ycmVjdGlvblwiXSA9IGNvcnJlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1lbnQgIT09IHVuZGVmaW5lZCAmJiBjb21tZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmZWVkYmFja1VwZGF0ZVtcImNvbW1lbnRcIl0gPSBjb21tZW50O1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFV1aWQoZmVlZGJhY2tJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChmZXRjaCwgYCR7dGhpcy5hcGlVcmx9L2ZlZWRiYWNrLyR7ZmVlZGJhY2tJZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZmVlZGJhY2tVcGRhdGUpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1cGRhdGUgZmVlZGJhY2tcIik7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRGZWVkYmFjayhmZWVkYmFja0lkKSB7XG4gICAgICAgIGFzc2VydFV1aWQoZmVlZGJhY2tJZCk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL2ZlZWRiYWNrLyR7ZmVlZGJhY2tJZH1gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldChwYXRoKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVGZWVkYmFjayhmZWVkYmFja0lkKSB7XG4gICAgICAgIGFzc2VydFV1aWQoZmVlZGJhY2tJZCk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL2ZlZWRiYWNrLyR7ZmVlZGJhY2tJZH1gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoZmV0Y2gsIHRoaXMuYXBpVXJsICsgcGF0aCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBkZWxldGUgJHtwYXRofTogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jICpsaXN0RmVlZGJhY2soeyBydW5JZHMsIGZlZWRiYWNrS2V5cywgZmVlZGJhY2tTb3VyY2VUeXBlcywgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBpZiAocnVuSWRzKSB7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJydW5cIiwgcnVuSWRzLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmVlZGJhY2tLZXlzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBmZWVkYmFja0tleXMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJrZXlcIiwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmVlZGJhY2tTb3VyY2VUeXBlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIGZlZWRiYWNrU291cmNlVHlwZXMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJzb3VyY2VcIiwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBmZWVkYmFja3Mgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKFwiL2ZlZWRiYWNrXCIsIHF1ZXJ5UGFyYW1zKSkge1xuICAgICAgICAgICAgeWllbGQqIGZlZWRiYWNrcztcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsICJleHBvcnQgeyBDbGllbnQgfSBmcm9tIFwiLi9jbGllbnQuanNcIjtcbmV4cG9ydCB7IFJ1blRyZWUgfSBmcm9tIFwiLi9ydW5fdHJlZXMuanNcIjtcbi8vIFVwZGF0ZSB1c2luZyB5YXJuIGJ1bXAtdmVyc2lvblxuZXhwb3J0IGNvbnN0IF9fdmVyc2lvbl9fID0gXCIwLjEuOFwiO1xuIiwgImltcG9ydCB7IENsaWVudCB9IGZyb20gXCJsYW5nc21pdGhcIjtcbmltcG9ydCB7IGdldEVudmlyb25tZW50VmFyaWFibGUsIGdldFJ1bnRpbWVFbnZpcm9ubWVudCB9IGZyb20gXCIuLi91dGlscy9lbnYuanNcIjtcbmltcG9ydCB7IEJhc2VUcmFjZXIgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5leHBvcnQgY2xhc3MgTGFuZ0NoYWluVHJhY2VyIGV4dGVuZHMgQmFzZVRyYWNlciB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzID0ge30pIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJsYW5nY2hhaW5fdHJhY2VyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByb2plY3ROYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4YW1wbGVJZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjbGllbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBleGFtcGxlSWQsIHByb2plY3ROYW1lLCBjbGllbnQgfSA9IGZpZWxkcztcbiAgICAgICAgdGhpcy5wcm9qZWN0TmFtZSA9XG4gICAgICAgICAgICBwcm9qZWN0TmFtZSA/P1xuICAgICAgICAgICAgICAgIGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fUFJPSkVDVFwiKSA/P1xuICAgICAgICAgICAgICAgIGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fU0VTU0lPTlwiKTtcbiAgICAgICAgdGhpcy5leGFtcGxlSWQgPSBleGFtcGxlSWQ7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50ID8/IG5ldyBDbGllbnQoe30pO1xuICAgIH1cbiAgICBhc3luYyBfY29udmVydFRvQ3JlYXRlKHJ1biwgZXhhbXBsZV9pZCA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucnVuLFxuICAgICAgICAgICAgZXh0cmE6IHtcbiAgICAgICAgICAgICAgICAuLi5ydW4uZXh0cmEsXG4gICAgICAgICAgICAgICAgcnVudGltZTogYXdhaXQgZ2V0UnVudGltZUVudmlyb25tZW50KCksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hpbGRfcnVuczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2Vzc2lvbl9uYW1lOiB0aGlzLnByb2plY3ROYW1lLFxuICAgICAgICAgICAgcmVmZXJlbmNlX2V4YW1wbGVfaWQ6IHJ1bi5wYXJlbnRfcnVuX2lkID8gdW5kZWZpbmVkIDogZXhhbXBsZV9pZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgcGVyc2lzdFJ1bihfcnVuKSB7IH1cbiAgICBhc3luYyBvblJ1bkNyZWF0ZShydW4pIHtcbiAgICAgICAgY29uc3QgcGVyc2lzdGVkUnVuID0gYXdhaXQgdGhpcy5fY29udmVydFRvQ3JlYXRlKHJ1biwgdGhpcy5leGFtcGxlSWQpO1xuICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC5jcmVhdGVSdW4ocGVyc2lzdGVkUnVuKTtcbiAgICB9XG4gICAgYXN5bmMgb25SdW5VcGRhdGUocnVuKSB7XG4gICAgICAgIGNvbnN0IHJ1blVwZGF0ZSA9IHtcbiAgICAgICAgICAgIGVuZF90aW1lOiBydW4uZW5kX3RpbWUsXG4gICAgICAgICAgICBlcnJvcjogcnVuLmVycm9yLFxuICAgICAgICAgICAgb3V0cHV0czogcnVuLm91dHB1dHMsXG4gICAgICAgICAgICBldmVudHM6IHJ1bi5ldmVudHMsXG4gICAgICAgICAgICBpbnB1dHM6IHJ1bi5pbnB1dHMsXG4gICAgICAgICAgICB0cmFjZV9pZDogcnVuLnRyYWNlX2lkLFxuICAgICAgICAgICAgZG90dGVkX29yZGVyOiBydW4uZG90dGVkX29yZGVyLFxuICAgICAgICAgICAgcGFyZW50X3J1bl9pZDogcnVuLnBhcmVudF9ydW5faWQsXG4gICAgICAgIH07XG4gICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LnVwZGF0ZVJ1bihydW4uaWQsIHJ1blVwZGF0ZSk7XG4gICAgfVxuICAgIGdldFJ1bihpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ydW5NYXAuZ2V0KGlkKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgU2VyaWFsaXphYmxlIH0gZnJvbSBcIi4uL2xvYWQvc2VyaWFsaXphYmxlLmpzXCI7XG5mdW5jdGlvbiBtZXJnZUNvbnRlbnQoZmlyc3RDb250ZW50LCBzZWNvbmRDb250ZW50KSB7XG4gICAgLy8gSWYgZmlyc3QgY29udGVudCBpcyBhIHN0cmluZ1xuICAgIGlmICh0eXBlb2YgZmlyc3RDb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2Vjb25kQ29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0Q29udGVudCArIHNlY29uZENvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IGZpcnN0Q29udGVudCB9LCAuLi5zZWNvbmRDb250ZW50XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBib3RoIGFyZSBhcnJheXNcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzZWNvbmRDb250ZW50KSkge1xuICAgICAgICByZXR1cm4gWy4uLmZpcnN0Q29udGVudCwgLi4uc2Vjb25kQ29udGVudF07XG4gICAgICAgIC8vIElmIHRoZSBmaXJzdCBjb250ZW50IGlzIGEgbGlzdCBhbmQgc2Vjb25kIGlzIGEgc3RyaW5nXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UsIGFkZCB0aGUgc2Vjb25kIGNvbnRlbnQgYXMgYSBuZXcgZWxlbWVudCBvZiB0aGUgbGlzdFxuICAgICAgICByZXR1cm4gWy4uLmZpcnN0Q29udGVudCwgeyB0eXBlOiBcInRleHRcIiwgdGV4dDogc2Vjb25kQ29udGVudCB9XTtcbiAgICB9XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGFsbCB0eXBlcyBvZiBtZXNzYWdlcyBpbiBhIGNvbnZlcnNhdGlvbi4gSXQgaW5jbHVkZXNcbiAqIHByb3BlcnRpZXMgbGlrZSBgY29udGVudGAsIGBuYW1lYCwgYW5kIGBhZGRpdGlvbmFsX2t3YXJnc2AuIEl0IGFsc29cbiAqIGluY2x1ZGVzIG1ldGhvZHMgbGlrZSBgdG9EaWN0KClgIGFuZCBgX2dldFR5cGUoKWAuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlTWVzc2FnZSBleHRlbmRzIFNlcmlhbGl6YWJsZSB7XG4gICAgZ2V0IGxjX2FsaWFzZXMoKSB7XG4gICAgICAgIC8vIGV4Y2x1ZGUgc25ha2UgY2FzZSBjb252ZXJzaW9uIHRvIHBhc2NhbCBjYXNlXG4gICAgICAgIHJldHVybiB7IGFkZGl0aW9uYWxfa3dhcmdzOiBcImFkZGl0aW9uYWxfa3dhcmdzXCIgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBVc2Uge0BsaW5rIEJhc2VNZXNzYWdlLmNvbnRlbnR9IGluc3RlYWQuXG4gICAgICovXG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5jb250ZW50ID09PSBcInN0cmluZ1wiID8gdGhpcy5jb250ZW50IDogXCJcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCBcbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBrd2FyZ3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgZmllbGRzID0geyBjb250ZW50OiBmaWVsZHMsIGFkZGl0aW9uYWxfa3dhcmdzOiBrd2FyZ3MgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIGFkZGl0aW9uYWxfa3dhcmdzIGlzIHBhc3NlZCBpbnRvIHN1cGVyKCkgZm9yIHNlcmlhbGl6YXRpb25cbiAgICAgICAgaWYgKCFmaWVsZHMuYWRkaXRpb25hbF9rd2FyZ3MpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgZmllbGRzLmFkZGl0aW9uYWxfa3dhcmdzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcIm1lc3NhZ2VzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBUaGUgY29udGVudCBvZiB0aGUgbWVzc2FnZS4gKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udGVudFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogVGhlIG5hbWUgb2YgdGhlIG1lc3NhZ2Ugc2VuZGVyIGluIGEgbXVsdGktdXNlciBjaGF0LiAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBBZGRpdGlvbmFsIGtleXdvcmQgYXJndW1lbnRzICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFkZGl0aW9uYWxfa3dhcmdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubmFtZSA9IGZpZWxkcy5uYW1lO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBmaWVsZHMuY29udGVudDtcbiAgICAgICAgdGhpcy5hZGRpdGlvbmFsX2t3YXJncyA9IGZpZWxkcy5hZGRpdGlvbmFsX2t3YXJncztcbiAgICB9XG4gICAgdG9EaWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdGhpcy5fZ2V0VHlwZSgpLFxuICAgICAgICAgICAgZGF0YTogdGhpcy50b0pTT04oKVxuICAgICAgICAgICAgICAgIC5rd2FyZ3MsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRvQ2h1bmsoKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLl9nZXRUeXBlKCk7XG4gICAgICAgIGlmICh0eXBlID09PSBcImh1bWFuXCIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgICAgIHJldHVybiBuZXcgSHVtYW5NZXNzYWdlQ2h1bmsoeyAuLi50aGlzIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiYWlcIikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBSU1lc3NhZ2VDaHVuayh7IC4uLnRoaXMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJzeXN0ZW1cIikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTeXN0ZW1NZXNzYWdlQ2h1bmsoeyAuLi50aGlzIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbk1lc3NhZ2VDaHVuayh7IC4uLnRoaXMgfSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQ2hhdE1lc3NhZ2UuaXNJbnN0YW5jZSh0aGlzKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGF0TWVzc2FnZUNodW5rKHsgLi4udGhpcyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbWVzc2FnZSB0eXBlLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzT3BlbkFJVG9vbENhbGxBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiZcbiAgICAgICAgdmFsdWUuZXZlcnkoKHYpID0+IHR5cGVvZiB2LmluZGV4ID09PSBcIm51bWJlclwiKSk7XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSBjaHVuayBvZiBhIG1lc3NhZ2UsIHdoaWNoIGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuICogbWVzc2FnZSBjaHVua3MuIEl0IGluY2x1ZGVzIGEgbWV0aG9kIGBfbWVyZ2Vfa3dhcmdzX2RpY3QoKWAgZm9yIG1lcmdpbmdcbiAqIGFkZGl0aW9uYWwga2V5d29yZCBhcmd1bWVudHMgZnJvbSBhbm90aGVyIGBCYXNlTWVzc2FnZUNodW5rYCBpbnRvIHRoaXNcbiAqIG9uZS4gSXQgYWxzbyBvdmVycmlkZXMgdGhlIGBfX2FkZF9fKClgIG1ldGhvZCB0byBzdXBwb3J0IGNvbmNhdGVuYXRpb25cbiAqIG9mIGBCYXNlTWVzc2FnZUNodW5rYCBpbnN0YW5jZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlTWVzc2FnZUNodW5rIGV4dGVuZHMgQmFzZU1lc3NhZ2Uge1xuICAgIHN0YXRpYyBfbWVyZ2VBZGRpdGlvbmFsS3dhcmdzKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IHsgLi4ubGVmdCB9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyaWdodCkpIHtcbiAgICAgICAgICAgIGlmIChtZXJnZWRba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtZXJnZWRba2V5XSAhPT0gdHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhZGRpdGlvbmFsX2t3YXJnc1ske2tleX1dIGFscmVhZHkgZXhpc3RzIGluIHRoZSBtZXNzYWdlIGNodW5rLCBidXQgd2l0aCBhIGRpZmZlcmVudCB0eXBlLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1lcmdlZFtrZXldID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkW2tleV0gPSBtZXJnZWRba2V5XSArIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkobWVyZ2VkW2tleV0pICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIG1lcmdlZFtrZXldID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkW2tleV0gPSB0aGlzLl9tZXJnZUFkZGl0aW9uYWxLd2FyZ3MobWVyZ2VkW2tleV0sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJ0b29sX2NhbGxzXCIgJiZcbiAgICAgICAgICAgICAgICBpc09wZW5BSVRvb2xDYWxsQXJyYXkobWVyZ2VkW2tleV0pICYmXG4gICAgICAgICAgICAgICAgaXNPcGVuQUlUb29sQ2FsbEFycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbENhbGwgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lcmdlZFtrZXldPy5bdG9vbENhbGwuaW5kZXhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlZFtrZXldID0gbWVyZ2VkW2tleV0/Lm1hcCgodmFsdWUsIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gdG9vbENhbGwuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udG9vbENhbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0b29sQ2FsbC5mdW5jdGlvbi5uYW1lID8/IHZhbHVlLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6ICh2YWx1ZS5mdW5jdGlvbi5hcmd1bWVudHMgPz8gXCJcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMgPz8gXCJcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VkW2tleV1bdG9vbENhbGwuaW5kZXhdID0gdG9vbENhbGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFkZGl0aW9uYWxfa3dhcmdzWyR7a2V5fV0gYWxyZWFkeSBleGlzdHMgaW4gdGhpcyBtZXNzYWdlIGNodW5rLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgaHVtYW4gbWVzc2FnZSBpbiBhIGNvbnZlcnNhdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEh1bWFuTWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiSHVtYW5NZXNzYWdlXCI7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJodW1hblwiO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIGNodW5rIG9mIGEgaHVtYW4gbWVzc2FnZSwgd2hpY2ggY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoXG4gKiBvdGhlciBodW1hbiBtZXNzYWdlIGNodW5rcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEh1bWFuTWVzc2FnZUNodW5rIGV4dGVuZHMgQmFzZU1lc3NhZ2VDaHVuayB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkh1bWFuTWVzc2FnZUNodW5rXCI7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJodW1hblwiO1xuICAgIH1cbiAgICBjb25jYXQoY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIdW1hbk1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICBjb250ZW50OiBtZXJnZUNvbnRlbnQodGhpcy5jb250ZW50LCBjaHVuay5jb250ZW50KSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxfa3dhcmdzOiBIdW1hbk1lc3NhZ2VDaHVuay5fbWVyZ2VBZGRpdGlvbmFsS3dhcmdzKHRoaXMuYWRkaXRpb25hbF9rd2FyZ3MsIGNodW5rLmFkZGl0aW9uYWxfa3dhcmdzKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIEFJIG1lc3NhZ2UgaW4gYSBjb252ZXJzYXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBBSU1lc3NhZ2UgZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkFJTWVzc2FnZVwiO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiYWlcIjtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSBjaHVuayBvZiBhbiBBSSBtZXNzYWdlLCB3aGljaCBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGhcbiAqIG90aGVyIEFJIG1lc3NhZ2UgY2h1bmtzLlxuICovXG5leHBvcnQgY2xhc3MgQUlNZXNzYWdlQ2h1bmsgZXh0ZW5kcyBCYXNlTWVzc2FnZUNodW5rIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQUlNZXNzYWdlQ2h1bmtcIjtcbiAgICB9XG4gICAgX2dldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImFpXCI7XG4gICAgfVxuICAgIGNvbmNhdChjaHVuaykge1xuICAgICAgICByZXR1cm4gbmV3IEFJTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IG1lcmdlQ29udGVudCh0aGlzLmNvbnRlbnQsIGNodW5rLmNvbnRlbnQpLFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IEFJTWVzc2FnZUNodW5rLl9tZXJnZUFkZGl0aW9uYWxLd2FyZ3ModGhpcy5hZGRpdGlvbmFsX2t3YXJncywgY2h1bmsuYWRkaXRpb25hbF9rd2FyZ3MpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSBzeXN0ZW0gbWVzc2FnZSBpbiBhIGNvbnZlcnNhdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFN5c3RlbU1lc3NhZ2UgZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlN5c3RlbU1lc3NhZ2VcIjtcbiAgICB9XG4gICAgX2dldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcInN5c3RlbVwiO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIGNodW5rIG9mIGEgc3lzdGVtIG1lc3NhZ2UsIHdoaWNoIGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aFxuICogb3RoZXIgc3lzdGVtIG1lc3NhZ2UgY2h1bmtzLlxuICovXG5leHBvcnQgY2xhc3MgU3lzdGVtTWVzc2FnZUNodW5rIGV4dGVuZHMgQmFzZU1lc3NhZ2VDaHVuayB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlN5c3RlbU1lc3NhZ2VDaHVua1wiO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwic3lzdGVtXCI7XG4gICAgfVxuICAgIGNvbmNhdChjaHVuaykge1xuICAgICAgICByZXR1cm4gbmV3IFN5c3RlbU1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICBjb250ZW50OiBtZXJnZUNvbnRlbnQodGhpcy5jb250ZW50LCBjaHVuay5jb250ZW50KSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxfa3dhcmdzOiBTeXN0ZW1NZXNzYWdlQ2h1bmsuX21lcmdlQWRkaXRpb25hbEt3YXJncyh0aGlzLmFkZGl0aW9uYWxfa3dhcmdzLCBjaHVuay5hZGRpdGlvbmFsX2t3YXJncyksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIGZ1bmN0aW9uIG1lc3NhZ2UgaW4gYSBjb252ZXJzYXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbk1lc3NhZ2UgZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkZ1bmN0aW9uTWVzc2FnZVwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIFxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgZmllbGRzID0geyBjb250ZW50OiBmaWVsZHMsIG5hbWU6IG5hbWUgfTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIjtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSBjaHVuayBvZiBhIGZ1bmN0aW9uIG1lc3NhZ2UsIHdoaWNoIGNhbiBiZSBjb25jYXRlbmF0ZWRcbiAqIHdpdGggb3RoZXIgZnVuY3Rpb24gbWVzc2FnZSBjaHVua3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbk1lc3NhZ2VDaHVuayBleHRlbmRzIEJhc2VNZXNzYWdlQ2h1bmsge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJGdW5jdGlvbk1lc3NhZ2VDaHVua1wiO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIjtcbiAgICB9XG4gICAgY29uY2F0KGNodW5rKSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25NZXNzYWdlQ2h1bmsoe1xuICAgICAgICAgICAgY29udGVudDogbWVyZ2VDb250ZW50KHRoaXMuY29udGVudCwgY2h1bmsuY29udGVudCksXG4gICAgICAgICAgICBhZGRpdGlvbmFsX2t3YXJnczogRnVuY3Rpb25NZXNzYWdlQ2h1bmsuX21lcmdlQWRkaXRpb25hbEt3YXJncyh0aGlzLmFkZGl0aW9uYWxfa3dhcmdzLCBjaHVuay5hZGRpdGlvbmFsX2t3YXJncyksXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUgPz8gXCJcIixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdG9vbCBtZXNzYWdlIGluIGEgY29udmVyc2F0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgVG9vbE1lc3NhZ2UgZXh0ZW5kcyBCYXNlTWVzc2FnZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlRvb2xNZXNzYWdlXCI7XG4gICAgfVxuICAgIGdldCBsY19hbGlhc2VzKCkge1xuICAgICAgICAvLyBleGNsdWRlIHNuYWtlIGNhc2UgY29udmVyc2lvbiB0byBwYXNjYWwgY2FzZVxuICAgICAgICByZXR1cm4geyB0b29sX2NhbGxfaWQ6IFwidG9vbF9jYWxsX2lkXCIgfTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCB0b29sX2NhbGxfaWQsIG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgZmllbGRzID0geyBjb250ZW50OiBmaWVsZHMsIG5hbWUsIHRvb2xfY2FsbF9pZDogdG9vbF9jYWxsX2lkIH07XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidG9vbF9jYWxsX2lkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG9vbF9jYWxsX2lkID0gZmllbGRzLnRvb2xfY2FsbF9pZDtcbiAgICB9XG4gICAgX2dldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcInRvb2xcIjtcbiAgICB9XG4gICAgc3RhdGljIGlzSW5zdGFuY2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZS5fZ2V0VHlwZSgpID09PSBcInRvb2xcIjtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSBjaHVuayBvZiBhIHRvb2wgbWVzc2FnZSwgd2hpY2ggY2FuIGJlIGNvbmNhdGVuYXRlZFxuICogd2l0aCBvdGhlciB0b29sIG1lc3NhZ2UgY2h1bmtzLlxuICovXG5leHBvcnQgY2xhc3MgVG9vbE1lc3NhZ2VDaHVuayBleHRlbmRzIEJhc2VNZXNzYWdlQ2h1bmsge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b29sX2NhbGxfaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b29sX2NhbGxfaWQgPSBmaWVsZHMudG9vbF9jYWxsX2lkO1xuICAgIH1cbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiVG9vbE1lc3NhZ2VDaHVua1wiO1xuICAgIH1cbiAgICBfZ2V0VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwidG9vbFwiO1xuICAgIH1cbiAgICBjb25jYXQoY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUb29sTWVzc2FnZUNodW5rKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IG1lcmdlQ29udGVudCh0aGlzLmNvbnRlbnQsIGNodW5rLmNvbnRlbnQpLFxuICAgICAgICAgICAgYWRkaXRpb25hbF9rd2FyZ3M6IFRvb2xNZXNzYWdlQ2h1bmsuX21lcmdlQWRkaXRpb25hbEt3YXJncyh0aGlzLmFkZGl0aW9uYWxfa3dhcmdzLCBjaHVuay5hZGRpdGlvbmFsX2t3YXJncyksXG4gICAgICAgICAgICB0b29sX2NhbGxfaWQ6IHRoaXMudG9vbF9jYWxsX2lkLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSBjaGF0IG1lc3NhZ2UgaW4gYSBjb252ZXJzYXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBDaGF0TWVzc2FnZSBleHRlbmRzIEJhc2VNZXNzYWdlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2hhdE1lc3NhZ2VcIjtcbiAgICB9XG4gICAgc3RhdGljIF9jaGF0TWVzc2FnZUNsYXNzKCkge1xuICAgICAgICByZXR1cm4gQ2hhdE1lc3NhZ2U7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgcm9sZSkge1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBmaWVsZHMgPSB7IGNvbnRlbnQ6IGZpZWxkcywgcm9sZTogcm9sZSB9O1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJvbGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yb2xlID0gZmllbGRzLnJvbGU7XG4gICAgfVxuICAgIF9nZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJnZW5lcmljXCI7XG4gICAgfVxuICAgIHN0YXRpYyBpc0luc3RhbmNlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2UuX2dldFR5cGUoKSA9PT0gXCJnZW5lcmljXCI7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQmFzZU1lc3NhZ2UobWVzc2FnZUxpa2UpIHtcbiAgICByZXR1cm4gdHlwZW9mIG1lc3NhZ2VMaWtlPy5fZ2V0VHlwZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQmFzZU1lc3NhZ2VDaHVuayhtZXNzYWdlTGlrZSkge1xuICAgIHJldHVybiAoaXNCYXNlTWVzc2FnZShtZXNzYWdlTGlrZSkgJiZcbiAgICAgICAgdHlwZW9mIG1lc3NhZ2VMaWtlLmNvbmNhdCA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb2VyY2VNZXNzYWdlTGlrZVRvTWVzc2FnZShtZXNzYWdlTGlrZSkge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZUxpa2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIdW1hbk1lc3NhZ2UobWVzc2FnZUxpa2UpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Jhc2VNZXNzYWdlKG1lc3NhZ2VMaWtlKSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZUxpa2U7XG4gICAgfVxuICAgIGNvbnN0IFt0eXBlLCBjb250ZW50XSA9IG1lc3NhZ2VMaWtlO1xuICAgIGlmICh0eXBlID09PSBcImh1bWFuXCIgfHwgdHlwZSA9PT0gXCJ1c2VyXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIdW1hbk1lc3NhZ2UoeyBjb250ZW50IH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSBcImFpXCIgfHwgdHlwZSA9PT0gXCJhc3Npc3RhbnRcIikge1xuICAgICAgICByZXR1cm4gbmV3IEFJTWVzc2FnZSh7IGNvbnRlbnQgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwic3lzdGVtXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTeXN0ZW1NZXNzYWdlKHsgY29udGVudCB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGNvZXJjZSBtZXNzYWdlIGZyb20gYXJyYXk6IG9ubHkgaHVtYW4sIEFJLCBvciBzeXN0ZW0gbWVzc2FnZSBjb2VyY2lvbiBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLmApO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIGNodW5rIG9mIGEgY2hhdCBtZXNzYWdlLCB3aGljaCBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGhcbiAqIG90aGVyIGNoYXQgbWVzc2FnZSBjaHVua3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBDaGF0TWVzc2FnZUNodW5rIGV4dGVuZHMgQmFzZU1lc3NhZ2VDaHVuayB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkNoYXRNZXNzYWdlQ2h1bmtcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzLCByb2xlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ24sIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGZpZWxkcyA9IHsgY29udGVudDogZmllbGRzLCByb2xlOiByb2xlIH07XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicm9sZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJvbGUgPSBmaWVsZHMucm9sZTtcbiAgICB9XG4gICAgX2dldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBcImdlbmVyaWNcIjtcbiAgICB9XG4gICAgY29uY2F0KGNodW5rKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhdE1lc3NhZ2VDaHVuayh7XG4gICAgICAgICAgICBjb250ZW50OiBtZXJnZUNvbnRlbnQodGhpcy5jb250ZW50LCBjaHVuay5jb250ZW50KSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxfa3dhcmdzOiBDaGF0TWVzc2FnZUNodW5rLl9tZXJnZUFkZGl0aW9uYWxLd2FyZ3ModGhpcy5hZGRpdGlvbmFsX2t3YXJncywgY2h1bmsuYWRkaXRpb25hbF9rd2FyZ3MpLFxuICAgICAgICAgICAgcm9sZTogdGhpcy5yb2xlLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBieSBtZW1vcnkgY2xhc3NlcyB0byBnZXQgYSBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqIG9mIHRoZSBjaGF0IG1lc3NhZ2UgaGlzdG9yeSwgYmFzZWQgb24gdGhlIG1lc3NhZ2UgY29udGVudCBhbmQgcm9sZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJ1ZmZlclN0cmluZyhtZXNzYWdlcywgaHVtYW5QcmVmaXggPSBcIkh1bWFuXCIsIGFpUHJlZml4ID0gXCJBSVwiKSB7XG4gICAgY29uc3Qgc3RyaW5nX21lc3NhZ2VzID0gW107XG4gICAgZm9yIChjb25zdCBtIG9mIG1lc3NhZ2VzKSB7XG4gICAgICAgIGxldCByb2xlO1xuICAgICAgICBpZiAobS5fZ2V0VHlwZSgpID09PSBcImh1bWFuXCIpIHtcbiAgICAgICAgICAgIHJvbGUgPSBodW1hblByZWZpeDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtLl9nZXRUeXBlKCkgPT09IFwiYWlcIikge1xuICAgICAgICAgICAgcm9sZSA9IGFpUHJlZml4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG0uX2dldFR5cGUoKSA9PT0gXCJzeXN0ZW1cIikge1xuICAgICAgICAgICAgcm9sZSA9IFwiU3lzdGVtXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobS5fZ2V0VHlwZSgpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJvbGUgPSBcIkZ1bmN0aW9uXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobS5fZ2V0VHlwZSgpID09PSBcInRvb2xcIikge1xuICAgICAgICAgICAgcm9sZSA9IFwiVG9vbFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG0uX2dldFR5cGUoKSA9PT0gXCJnZW5lcmljXCIpIHtcbiAgICAgICAgICAgIHJvbGUgPSBtLnJvbGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCB1bnN1cHBvcnRlZCBtZXNzYWdlIHR5cGU6ICR7bS5fZ2V0VHlwZSgpfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWVTdHIgPSBtLm5hbWUgPyBgJHttLm5hbWV9LCBgIDogXCJcIjtcbiAgICAgICAgc3RyaW5nX21lc3NhZ2VzLnB1c2goYCR7cm9sZX06ICR7bmFtZVN0cn0ke20uY29udGVudH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ19tZXNzYWdlcy5qb2luKFwiXFxuXCIpO1xufVxuLyoqXG4gKiBNYXBzIG1lc3NhZ2VzIGZyb20gYW4gb2xkZXIgZm9ybWF0IChWMSkgdG8gdGhlIGN1cnJlbnQgYFN0b3JlZE1lc3NhZ2VgXG4gKiBmb3JtYXQuIElmIHRoZSBtZXNzYWdlIGlzIGFscmVhZHkgaW4gdGhlIGBTdG9yZWRNZXNzYWdlYCBmb3JtYXQsIGl0IGlzXG4gKiByZXR1cm5lZCBhcyBpcy4gT3RoZXJ3aXNlLCBpdCB0cmFuc2Zvcm1zIHRoZSBWMSBtZXNzYWdlIGludG8gYVxuICogYFN0b3JlZE1lc3NhZ2VgLiBUaGlzIGZ1bmN0aW9uIGlzIGltcG9ydGFudCBmb3IgbWFpbnRhaW5pbmdcbiAqIGNvbXBhdGliaWxpdHkgd2l0aCBvbGRlciBtZXNzYWdlIGZvcm1hdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcFYxTWVzc2FnZVRvU3RvcmVkTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgbWFwcGVyIHdoZW4gd2UgZGVwcmVjYXRlIHRoZSBvbGQgbWVzc2FnZSBmb3JtYXQuXG4gICAgaWYgKG1lc3NhZ2UuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdjFNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHYxTWVzc2FnZS50eXBlLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHYxTWVzc2FnZS50ZXh0LFxuICAgICAgICAgICAgICAgIHJvbGU6IHYxTWVzc2FnZS5yb2xlLFxuICAgICAgICAgICAgICAgIG5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB0b29sX2NhbGxfaWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIG1hcFN0b3JlZE1lc3NhZ2VUb0NoYXRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBzdG9yZWRNZXNzYWdlID0gbWFwVjFNZXNzYWdlVG9TdG9yZWRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIHN3aXRjaCAoc3RvcmVkTWVzc2FnZS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJodW1hblwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBIdW1hbk1lc3NhZ2Uoc3RvcmVkTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgY2FzZSBcImFpXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFJTWVzc2FnZShzdG9yZWRNZXNzYWdlLmRhdGEpO1xuICAgICAgICBjYXNlIFwic3lzdGVtXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN5c3RlbU1lc3NhZ2Uoc3RvcmVkTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICBpZiAoc3RvcmVkTWVzc2FnZS5kYXRhLm5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5hbWUgbXVzdCBiZSBkZWZpbmVkIGZvciBmdW5jdGlvbiBtZXNzYWdlc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25NZXNzYWdlKHN0b3JlZE1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIGNhc2UgXCJ0b29sXCI6XG4gICAgICAgICAgICBpZiAoc3RvcmVkTWVzc2FnZS5kYXRhLnRvb2xfY2FsbF9pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG9vbCBjYWxsIElEIG11c3QgYmUgZGVmaW5lZCBmb3IgdG9vbCBtZXNzYWdlc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgVG9vbE1lc3NhZ2Uoc3RvcmVkTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgY2FzZSBcImNoYXRcIjoge1xuICAgICAgICAgICAgaWYgKHN0b3JlZE1lc3NhZ2UuZGF0YS5yb2xlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb2xlIG11c3QgYmUgZGVmaW5lZCBmb3IgY2hhdCBtZXNzYWdlc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhdE1lc3NhZ2Uoc3RvcmVkTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHb3QgdW5leHBlY3RlZCB0eXBlOiAke3N0b3JlZE1lc3NhZ2UudHlwZX1gKTtcbiAgICB9XG59XG4vKipcbiAqIFRyYW5zZm9ybXMgYW4gYXJyYXkgb2YgYFN0b3JlZE1lc3NhZ2VgIGluc3RhbmNlcyBpbnRvIGFuIGFycmF5IG9mXG4gKiBgQmFzZU1lc3NhZ2VgIGluc3RhbmNlcy4gSXQgdXNlcyB0aGUgYG1hcFYxTWVzc2FnZVRvU3RvcmVkTWVzc2FnZWBcbiAqIGZ1bmN0aW9uIHRvIGVuc3VyZSBhbGwgbWVzc2FnZXMgYXJlIGluIHRoZSBgU3RvcmVkTWVzc2FnZWAgZm9ybWF0LCB0aGVuXG4gKiBjcmVhdGVzIG5ldyBpbnN0YW5jZXMgb2YgdGhlIGFwcHJvcHJpYXRlIGBCYXNlTWVzc2FnZWAgc3ViY2xhc3MgYmFzZWRcbiAqIG9uIHRoZSB0eXBlIG9mIGVhY2ggbWVzc2FnZS4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHByZXBhcmUgc3RvcmVkXG4gKiBtZXNzYWdlcyBmb3IgdXNlIGluIGEgY2hhdCBjb250ZXh0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwU3RvcmVkTWVzc2FnZXNUb0NoYXRNZXNzYWdlcyhtZXNzYWdlcykge1xuICAgIHJldHVybiBtZXNzYWdlcy5tYXAobWFwU3RvcmVkTWVzc2FnZVRvQ2hhdE1lc3NhZ2UpO1xufVxuLyoqXG4gKiBUcmFuc2Zvcm1zIGFuIGFycmF5IG9mIGBCYXNlTWVzc2FnZWAgaW5zdGFuY2VzIGludG8gYW4gYXJyYXkgb2ZcbiAqIGBTdG9yZWRNZXNzYWdlYCBpbnN0YW5jZXMuIEl0IGRvZXMgdGhpcyBieSBjYWxsaW5nIHRoZSBgdG9EaWN0YCBtZXRob2RcbiAqIG9uIGVhY2ggYEJhc2VNZXNzYWdlYCwgd2hpY2ggcmV0dXJucyBhIGBTdG9yZWRNZXNzYWdlYC4gVGhpcyBmdW5jdGlvblxuICogaXMgdXNlZCB0byBwcmVwYXJlIGNoYXQgbWVzc2FnZXMgZm9yIHN0b3JhZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBDaGF0TWVzc2FnZXNUb1N0b3JlZE1lc3NhZ2VzKG1lc3NhZ2VzKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2VzLm1hcCgobWVzc2FnZSkgPT4gbWVzc2FnZS50b0RpY3QoKSk7XG59XG4iLCAiaW1wb3J0IHsgTGFuZ0NoYWluVHJhY2VyIH0gZnJvbSBcIi4vdHJhY2VyX2xhbmdjaGFpbi5qc1wiO1xuaW1wb3J0IHsgTGFuZ0NoYWluVHJhY2VyVjEgfSBmcm9tIFwiLi90cmFjZXJfbGFuZ2NoYWluX3YxLmpzXCI7XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSB0aGUgVjIgaGFuZGxlciBpbnN0ZWFkLlxuICpcbiAqIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBpbnN0YW5jZSBvZiBgTGFuZ0NoYWluVHJhY2VyVjFgLiBJZiBhIHNlc3Npb25cbiAqIGlzIHByb3ZpZGVkLCBpdCBsb2FkcyB0aGF0IHNlc3Npb24gaW50byB0aGUgdHJhY2VyOyBvdGhlcndpc2UsIGl0IGxvYWRzXG4gKiBhIGRlZmF1bHQgc2Vzc2lvbi5cbiAqIEBwYXJhbSBzZXNzaW9uIE9wdGlvbmFsIHNlc3Npb24gdG8gbG9hZCBpbnRvIHRoZSB0cmFjZXIuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBgTGFuZ0NoYWluVHJhY2VyVjFgLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VHJhY2luZ0NhbGxiYWNrSGFuZGxlcihzZXNzaW9uKSB7XG4gICAgY29uc3QgdHJhY2VyID0gbmV3IExhbmdDaGFpblRyYWNlclYxKCk7XG4gICAgaWYgKHNlc3Npb24pIHtcbiAgICAgICAgYXdhaXQgdHJhY2VyLmxvYWRTZXNzaW9uKHNlc3Npb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXdhaXQgdHJhY2VyLmxvYWREZWZhdWx0U2Vzc2lvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhY2VyO1xufVxuLyoqXG4gKiBGdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gaW5zdGFuY2Ugb2YgYExhbmdDaGFpblRyYWNlcmAuIEl0IGRvZXMgbm90XG4gKiBsb2FkIGFueSBzZXNzaW9uIGRhdGEuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBgTGFuZ0NoYWluVHJhY2VyYC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFRyYWNpbmdWMkNhbGxiYWNrSGFuZGxlcigpIHtcbiAgICByZXR1cm4gbmV3IExhbmdDaGFpblRyYWNlcigpO1xufVxuIiwgImltcG9ydCBQUXVldWVNb2QgZnJvbSBcInAtcXVldWVcIjtcbmxldCBxdWV1ZTtcbi8qKlxuICogQ3JlYXRlcyBhIHF1ZXVlIHVzaW5nIHRoZSBwLXF1ZXVlIGxpYnJhcnkuIFRoZSBxdWV1ZSBpcyBjb25maWd1cmVkIHRvXG4gKiBhdXRvLXN0YXJ0IGFuZCBoYXMgYSBjb25jdXJyZW5jeSBvZiAxLCBtZWFuaW5nIGl0IHdpbGwgcHJvY2VzcyB0YXNrc1xuICogb25lIGF0IGEgdGltZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUXVldWUoKSB7XG4gICAgY29uc3QgUFF1ZXVlID0gXCJkZWZhdWx0XCIgaW4gUFF1ZXVlTW9kID8gUFF1ZXVlTW9kLmRlZmF1bHQgOiBQUXVldWVNb2Q7XG4gICAgcmV0dXJuIG5ldyBQUXVldWUoe1xuICAgICAgICBhdXRvU3RhcnQ6IHRydWUsXG4gICAgICAgIGNvbmN1cnJlbmN5OiAxLFxuICAgIH0pO1xufVxuLyoqXG4gKiBDb25zdW1lIGEgcHJvbWlzZSwgZWl0aGVyIGFkZGluZyBpdCB0byB0aGUgcXVldWUgb3Igd2FpdGluZyBmb3IgaXQgdG8gcmVzb2x2ZVxuICogQHBhcmFtIHByb21pc2UgUHJvbWlzZSB0byBjb25zdW1lXG4gKiBAcGFyYW0gd2FpdCBXaGV0aGVyIHRvIHdhaXQgZm9yIHRoZSBwcm9taXNlIHRvIHJlc29sdmUgb3IgcmVzb2x2ZSBpbW1lZGlhdGVseVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29uc3VtZUNhbGxiYWNrKHByb21pc2VGbiwgd2FpdCkge1xuICAgIGlmICh3YWl0ID09PSB0cnVlKSB7XG4gICAgICAgIGF3YWl0IHByb21pc2VGbigpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBxdWV1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcXVldWUgPSBjcmVhdGVRdWV1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZvaWQgcXVldWUuYWRkKHByb21pc2VGbik7XG4gICAgfVxufVxuLyoqXG4gKiBXYWl0cyBmb3IgYWxsIHByb21pc2VzIGluIHRoZSBxdWV1ZSB0byByZXNvbHZlLiBJZiB0aGUgcXVldWUgaXNcbiAqIHVuZGVmaW5lZCwgaXQgaW1tZWRpYXRlbHkgcmVzb2x2ZXMgYSBwcm9taXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXdhaXRBbGxDYWxsYmFja3MoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBxdWV1ZSAhPT0gXCJ1bmRlZmluZWRcIiA/IHF1ZXVlLm9uSWRsZSgpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG59XG4iLCAiaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSBcInV1aWRcIjtcbmltcG9ydCB7IEJhc2VDYWxsYmFja0hhbmRsZXIsIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuaW1wb3J0IHsgQ29uc29sZUNhbGxiYWNrSGFuZGxlciB9IGZyb20gXCIuLi90cmFjZXJzL2NvbnNvbGUuanNcIjtcbmltcG9ydCB7IGdldFRyYWNpbmdWMkNhbGxiYWNrSGFuZGxlciB9IGZyb20gXCIuLi90cmFjZXJzL2luaXRpYWxpemUuanNcIjtcbmltcG9ydCB7IGdldEJ1ZmZlclN0cmluZyB9IGZyb20gXCIuLi9tZXNzYWdlcy9pbmRleC5qc1wiO1xuaW1wb3J0IHsgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSB9IGZyb20gXCIuLi91dGlscy9lbnYuanNcIjtcbmltcG9ydCB7IExhbmdDaGFpblRyYWNlciwgfSBmcm9tIFwiLi4vdHJhY2Vycy90cmFjZXJfbGFuZ2NoYWluLmpzXCI7XG5pbXBvcnQgeyBjb25zdW1lQ2FsbGJhY2sgfSBmcm9tIFwiLi9wcm9taXNlcy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ2FsbGJhY2tDb25maWdBcmcoYXJnKSB7XG4gICAgaWYgKCFhcmcpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykgfHwgXCJuYW1lXCIgaW4gYXJnKSB7XG4gICAgICAgIHJldHVybiB7IGNhbGxiYWNrczogYXJnIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYXJnO1xuICAgIH1cbn1cbi8qKlxuICogTWFuYWdlIGNhbGxiYWNrcyBmcm9tIGRpZmZlcmVudCBjb21wb25lbnRzIG9mIExhbmdDaGFpbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VDYWxsYmFja01hbmFnZXIge1xuICAgIHNldEhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRIYW5kbGVycyhbaGFuZGxlcl0pO1xuICAgIH1cbn1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgcnVuIG1hbmFnZXIgaW4gTGFuZ0NoYWluLlxuICovXG5jbGFzcyBCYXNlUnVuTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IocnVuSWQsIGhhbmRsZXJzLCBpbmhlcml0YWJsZUhhbmRsZXJzLCB0YWdzLCBpbmhlcml0YWJsZVRhZ3MsIG1ldGFkYXRhLCBpbmhlcml0YWJsZU1ldGFkYXRhLCBfcGFyZW50UnVuSWQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicnVuSWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHJ1bklkXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYW5kbGVyc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogaGFuZGxlcnNcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaGVyaXRhYmxlSGFuZGxlcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGluaGVyaXRhYmxlSGFuZGxlcnNcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRhZ3NcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaGVyaXRhYmxlVGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogaW5oZXJpdGFibGVUYWdzXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbWV0YWRhdGFcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaGVyaXRhYmxlTWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGluaGVyaXRhYmxlTWV0YWRhdGFcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9wYXJlbnRSdW5JZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogX3BhcmVudFJ1bklkXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVUZXh0KHRleHQpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlVGV4dD8uKHRleHQsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVUZXh0OiAke2Vycn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbn1cbi8qKlxuICogTWFuYWdlcyBjYWxsYmFja3MgZm9yIHJldHJpZXZlciBydW5zLlxuICovXG5leHBvcnQgY2xhc3MgQ2FsbGJhY2tNYW5hZ2VyRm9yUmV0cmlldmVyUnVuIGV4dGVuZHMgQmFzZVJ1bk1hbmFnZXIge1xuICAgIGdldENoaWxkKHRhZykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIGNvbnN0IG1hbmFnZXIgPSBuZXcgQ2FsbGJhY2tNYW5hZ2VyKHRoaXMucnVuSWQpO1xuICAgICAgICBtYW5hZ2VyLnNldEhhbmRsZXJzKHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycyk7XG4gICAgICAgIG1hbmFnZXIuYWRkVGFncyh0aGlzLmluaGVyaXRhYmxlVGFncyk7XG4gICAgICAgIG1hbmFnZXIuYWRkTWV0YWRhdGEodGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhKTtcbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgbWFuYWdlci5hZGRUYWdzKFt0YWddLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hbmFnZXI7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVJldHJpZXZlckVuZChkb2N1bWVudHMpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlUmV0cmlldmVyKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVSZXRyaWV2ZXJFbmQ/Lihkb2N1bWVudHMsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVSZXRyaWV2ZXJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlUmV0cmlldmVyRXJyb3IoZXJyKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiBjb25zdW1lQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZVJldHJpZXZlcikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlUmV0cmlldmVyRXJyb3I/LihlcnIsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZVJldHJpZXZlckVycm9yOiAke2Vycm9yfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDYWxsYmFja01hbmFnZXJGb3JMTE1SdW4gZXh0ZW5kcyBCYXNlUnVuTWFuYWdlciB7XG4gICAgYXN5bmMgaGFuZGxlTExNTmV3VG9rZW4odG9rZW4sIGlkeCwgX3J1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBmaWVsZHMpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlTExNKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVMTE1OZXdUb2tlbj8uKHRva2VuLCBpZHggPz8geyBwcm9tcHQ6IDAsIGNvbXBsZXRpb246IDAgfSwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncywgZmllbGRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlTExNTmV3VG9rZW46ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVMTE1FcnJvcihlcnIpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlTExNKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVMTE1FcnJvcj8uKGVyciwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZUxMTUVycm9yOiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTExNRW5kKG91dHB1dCkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVMTE0pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUxMTUVuZD8uKG91dHB1dCwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZUxMTUVuZDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENhbGxiYWNrTWFuYWdlckZvckNoYWluUnVuIGV4dGVuZHMgQmFzZVJ1bk1hbmFnZXIge1xuICAgIGdldENoaWxkKHRhZykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIGNvbnN0IG1hbmFnZXIgPSBuZXcgQ2FsbGJhY2tNYW5hZ2VyKHRoaXMucnVuSWQpO1xuICAgICAgICBtYW5hZ2VyLnNldEhhbmRsZXJzKHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycyk7XG4gICAgICAgIG1hbmFnZXIuYWRkVGFncyh0aGlzLmluaGVyaXRhYmxlVGFncyk7XG4gICAgICAgIG1hbmFnZXIuYWRkTWV0YWRhdGEodGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhKTtcbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgbWFuYWdlci5hZGRUYWdzKFt0YWddLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hbmFnZXI7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUNoYWluRXJyb3IoZXJyLCBfcnVuSWQsIF9wYXJlbnRSdW5JZCwgX3RhZ3MsIGt3YXJncykge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVDaGFpbikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlQ2hhaW5FcnJvcj8uKGVyciwgdGhpcy5ydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncywga3dhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlQ2hhaW5FcnJvcjogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUNoYWluRW5kKG91dHB1dCwgX3J1bklkLCBfcGFyZW50UnVuSWQsIF90YWdzLCBrd2FyZ3MpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQ2hhaW4pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUNoYWluRW5kPy4ob3V0cHV0LCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzLCBrd2FyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVDaGFpbkVuZDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUFnZW50QWN0aW9uKGFjdGlvbikge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVBZ2VudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlQWdlbnRBY3Rpb24/LihhY3Rpb24sIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVBZ2VudEFjdGlvbjogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUFnZW50RW5kKGFjdGlvbikge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVBZ2VudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlQWdlbnRFbmQ/LihhY3Rpb24sIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVBZ2VudEVuZDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENhbGxiYWNrTWFuYWdlckZvclRvb2xSdW4gZXh0ZW5kcyBCYXNlUnVuTWFuYWdlciB7XG4gICAgZ2V0Q2hpbGQodGFnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgY29uc3QgbWFuYWdlciA9IG5ldyBDYWxsYmFja01hbmFnZXIodGhpcy5ydW5JZCk7XG4gICAgICAgIG1hbmFnZXIuc2V0SGFuZGxlcnModGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzKTtcbiAgICAgICAgbWFuYWdlci5hZGRUYWdzKHRoaXMuaW5oZXJpdGFibGVUYWdzKTtcbiAgICAgICAgbWFuYWdlci5hZGRNZXRhZGF0YSh0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEpO1xuICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICBtYW5hZ2VyLmFkZFRhZ3MoW3RhZ10sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFuYWdlcjtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlVG9vbEVycm9yKGVycikge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVBZ2VudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlVG9vbEVycm9yPy4oZXJyLCB0aGlzLnJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgdGhpcy50YWdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlVG9vbEVycm9yOiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlVG9vbEVuZChvdXRwdXQpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQWdlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZVRvb2xFbmQ/LihvdXRwdXQsIHRoaXMucnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVUb29sRW5kOiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICB9XG59XG4vKipcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBwcm9tcHQgPSBQcm9tcHRUZW1wbGF0ZS5mcm9tVGVtcGxhdGUoXCJXaGF0IGlzIHRoZSBhbnN3ZXIgdG8ge3F1ZXN0aW9ufT9cIik7XG4gKlxuICogLy8gRXhhbXBsZSBvZiB1c2luZyBMTE1DaGFpbiB3aXRoIE9wZW5BSSBhbmQgYSBzaW1wbGUgcHJvbXB0XG4gKiBjb25zdCBjaGFpbiA9IG5ldyBMTE1DaGFpbih7XG4gKiAgIGxsbTogbmV3IENoYXRPcGVuQUkoeyB0ZW1wZXJhdHVyZTogMC45IH0pLFxuICogICBwcm9tcHQsXG4gKiB9KTtcbiAqXG4gKiAvLyBSdW5uaW5nIHRoZSBjaGFpbiB3aXRoIGEgc2luZ2xlIHF1ZXN0aW9uXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBjaGFpbi5jYWxsKHtcbiAqICAgcXVlc3Rpb246IFwiV2hhdCBpcyB0aGUgYWlyc3BlZWQgdmVsb2NpdHkgb2YgYW4gdW5sYWRlbiBzd2FsbG93P1wiLFxuICogfSk7XG4gKiBjb25zb2xlLmxvZyhcIlRoZSBhbnN3ZXIgaXM6XCIsIHJlc3VsdCk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIENhbGxiYWNrTWFuYWdlciBleHRlbmRzIEJhc2VDYWxsYmFja01hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudFJ1bklkLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhbmRsZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5oZXJpdGFibGVIYW5kbGVyc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmhlcml0YWJsZVRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluaGVyaXRhYmxlTWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBcImNhbGxiYWNrX21hbmFnZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3BhcmVudFJ1bklkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBvcHRpb25zPy5oYW5kbGVycyA/PyB0aGlzLmhhbmRsZXJzO1xuICAgICAgICB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnMgPVxuICAgICAgICAgICAgb3B0aW9ucz8uaW5oZXJpdGFibGVIYW5kbGVycyA/PyB0aGlzLmluaGVyaXRhYmxlSGFuZGxlcnM7XG4gICAgICAgIHRoaXMudGFncyA9IG9wdGlvbnM/LnRhZ3MgPz8gdGhpcy50YWdzO1xuICAgICAgICB0aGlzLmluaGVyaXRhYmxlVGFncyA9IG9wdGlvbnM/LmluaGVyaXRhYmxlVGFncyA/PyB0aGlzLmluaGVyaXRhYmxlVGFncztcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG9wdGlvbnM/Lm1ldGFkYXRhID8/IHRoaXMubWV0YWRhdGE7XG4gICAgICAgIHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSA9XG4gICAgICAgICAgICBvcHRpb25zPy5pbmhlcml0YWJsZU1ldGFkYXRhID8/IHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YTtcbiAgICAgICAgdGhpcy5fcGFyZW50UnVuSWQgPSBwYXJlbnRSdW5JZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGFyZW50IHJ1biBJRCwgaWYgYW55LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhcmVudCBydW4gSUQuXG4gICAgICovXG4gICAgZ2V0UGFyZW50UnVuSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnRSdW5JZDtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTExNU3RhcnQobGxtLCBwcm9tcHRzLCBfcnVuSWQgPSB1bmRlZmluZWQsIF9wYXJlbnRSdW5JZCA9IHVuZGVmaW5lZCwgZXh0cmFQYXJhbXMgPSB1bmRlZmluZWQsIF90YWdzID0gdW5kZWZpbmVkLCBfbWV0YWRhdGEgPSB1bmRlZmluZWQsIHJ1bk5hbWUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21wdHMubWFwKGFzeW5jIChwcm9tcHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bklkID0gdXVpZHY0KCk7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmhhbmRsZXJzLm1hcCgoaGFuZGxlcikgPT4gY29uc3VtZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlTExNKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZUxMTVN0YXJ0Py4obGxtLCBbcHJvbXB0XSwgcnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlTExNU3RhcnQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDYWxsYmFja01hbmFnZXJGb3JMTE1SdW4ocnVuSWQsIHRoaXMuaGFuZGxlcnMsIHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycywgdGhpcy50YWdzLCB0aGlzLmluaGVyaXRhYmxlVGFncywgdGhpcy5tZXRhZGF0YSwgdGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhLCB0aGlzLl9wYXJlbnRSdW5JZCk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlQ2hhdE1vZGVsU3RhcnQobGxtLCBtZXNzYWdlcywgX3J1bklkID0gdW5kZWZpbmVkLCBfcGFyZW50UnVuSWQgPSB1bmRlZmluZWQsIGV4dHJhUGFyYW1zID0gdW5kZWZpbmVkLCBfdGFncyA9IHVuZGVmaW5lZCwgX21ldGFkYXRhID0gdW5kZWZpbmVkLCBydW5OYW1lID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChtZXNzYWdlcy5tYXAoYXN5bmMgKG1lc3NhZ2VHcm91cCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcnVuSWQgPSB1dWlkdjQoKTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiBjb25zdW1lQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghaGFuZGxlci5pZ25vcmVMTE0pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLmhhbmRsZUNoYXRNb2RlbFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVDaGF0TW9kZWxTdGFydD8uKGxsbSwgW21lc3NhZ2VHcm91cF0sIHJ1bklkLCB0aGlzLl9wYXJlbnRSdW5JZCwgZXh0cmFQYXJhbXMsIHRoaXMudGFncywgdGhpcy5tZXRhZGF0YSwgcnVuTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChoYW5kbGVyLmhhbmRsZUxMTVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVN0cmluZyA9IGdldEJ1ZmZlclN0cmluZyhtZXNzYWdlR3JvdXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlTExNU3RhcnQ/LihsbG0sIFttZXNzYWdlU3RyaW5nXSwgcnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCBleHRyYVBhcmFtcywgdGhpcy50YWdzLCB0aGlzLm1ldGFkYXRhLCBydW5OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBpbiBoYW5kbGVyICR7aGFuZGxlci5jb25zdHJ1Y3Rvci5uYW1lfSwgaGFuZGxlTExNU3RhcnQ6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgaGFuZGxlci5hd2FpdEhhbmRsZXJzKSkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDYWxsYmFja01hbmFnZXJGb3JMTE1SdW4ocnVuSWQsIHRoaXMuaGFuZGxlcnMsIHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycywgdGhpcy50YWdzLCB0aGlzLmluaGVyaXRhYmxlVGFncywgdGhpcy5tZXRhZGF0YSwgdGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhLCB0aGlzLl9wYXJlbnRSdW5JZCk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlQ2hhaW5TdGFydChjaGFpbiwgaW5wdXRzLCBydW5JZCA9IHV1aWR2NCgpLCBydW5UeXBlID0gdW5kZWZpbmVkLCBfdGFncyA9IHVuZGVmaW5lZCwgX21ldGFkYXRhID0gdW5kZWZpbmVkLCBydW5OYW1lID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiBjb25zdW1lQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZUNoYWluKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVDaGFpblN0YXJ0Py4oY2hhaW4sIGlucHV0cywgcnVuSWQsIHRoaXMuX3BhcmVudFJ1bklkLCB0aGlzLnRhZ3MsIHRoaXMubWV0YWRhdGEsIHJ1blR5cGUsIHJ1bk5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGhhbmRsZXIgJHtoYW5kbGVyLmNvbnN0cnVjdG9yLm5hbWV9LCBoYW5kbGVDaGFpblN0YXJ0OiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDYWxsYmFja01hbmFnZXJGb3JDaGFpblJ1bihydW5JZCwgdGhpcy5oYW5kbGVycywgdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzLCB0aGlzLnRhZ3MsIHRoaXMuaW5oZXJpdGFibGVUYWdzLCB0aGlzLm1ldGFkYXRhLCB0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEsIHRoaXMuX3BhcmVudFJ1bklkKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlVG9vbFN0YXJ0KHRvb2wsIGlucHV0LCBydW5JZCA9IHV1aWR2NCgpLCBfcGFyZW50UnVuSWQgPSB1bmRlZmluZWQsIF90YWdzID0gdW5kZWZpbmVkLCBfbWV0YWRhdGEgPSB1bmRlZmluZWQsIHJ1bk5hbWUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5oYW5kbGVycy5tYXAoKGhhbmRsZXIpID0+IGNvbnN1bWVDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIuaWdub3JlQWdlbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVyLmhhbmRsZVRvb2xTdGFydD8uKHRvb2wsIGlucHV0LCBydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncywgdGhpcy5tZXRhZGF0YSwgcnVuTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZVRvb2xTdGFydDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBoYW5kbGVyLmF3YWl0SGFuZGxlcnMpKSk7XG4gICAgICAgIHJldHVybiBuZXcgQ2FsbGJhY2tNYW5hZ2VyRm9yVG9vbFJ1bihydW5JZCwgdGhpcy5oYW5kbGVycywgdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzLCB0aGlzLnRhZ3MsIHRoaXMuaW5oZXJpdGFibGVUYWdzLCB0aGlzLm1ldGFkYXRhLCB0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEsIHRoaXMuX3BhcmVudFJ1bklkKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlUmV0cmlldmVyU3RhcnQocmV0cmlldmVyLCBxdWVyeSwgcnVuSWQgPSB1dWlkdjQoKSwgX3BhcmVudFJ1bklkID0gdW5kZWZpbmVkLCBfdGFncyA9IHVuZGVmaW5lZCwgX21ldGFkYXRhID0gdW5kZWZpbmVkLCBydW5OYW1lID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuaGFuZGxlcnMubWFwKChoYW5kbGVyKSA9PiBjb25zdW1lQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyLmlnbm9yZVJldHJpZXZlcikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuaGFuZGxlUmV0cmlldmVyU3RhcnQ/LihyZXRyaWV2ZXIsIHF1ZXJ5LCBydW5JZCwgdGhpcy5fcGFyZW50UnVuSWQsIHRoaXMudGFncywgdGhpcy5tZXRhZGF0YSwgcnVuTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gaGFuZGxlciAke2hhbmRsZXIuY29uc3RydWN0b3IubmFtZX0sIGhhbmRsZVJldHJpZXZlclN0YXJ0OiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGhhbmRsZXIuYXdhaXRIYW5kbGVycykpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDYWxsYmFja01hbmFnZXJGb3JSZXRyaWV2ZXJSdW4ocnVuSWQsIHRoaXMuaGFuZGxlcnMsIHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycywgdGhpcy50YWdzLCB0aGlzLmluaGVyaXRhYmxlVGFncywgdGhpcy5tZXRhZGF0YSwgdGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhLCB0aGlzLl9wYXJlbnRSdW5JZCk7XG4gICAgfVxuICAgIGFkZEhhbmRsZXIoaGFuZGxlciwgaW5oZXJpdCA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgICAgICBpZiAoaW5oZXJpdCkge1xuICAgICAgICAgICAgdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzLmZpbHRlcigoX2hhbmRsZXIpID0+IF9oYW5kbGVyICE9PSBoYW5kbGVyKTtcbiAgICAgICAgdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzID0gdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzLmZpbHRlcigoX2hhbmRsZXIpID0+IF9oYW5kbGVyICE9PSBoYW5kbGVyKTtcbiAgICB9XG4gICAgc2V0SGFuZGxlcnMoaGFuZGxlcnMsIGluaGVyaXQgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5pbmhlcml0YWJsZUhhbmRsZXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBoYW5kbGVycykge1xuICAgICAgICAgICAgdGhpcy5hZGRIYW5kbGVyKGhhbmRsZXIsIGluaGVyaXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFRhZ3ModGFncywgaW5oZXJpdCA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVUYWdzKHRhZ3MpOyAvLyBSZW1vdmUgZHVwbGljYXRlc1xuICAgICAgICB0aGlzLnRhZ3MucHVzaCguLi50YWdzKTtcbiAgICAgICAgaWYgKGluaGVyaXQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5oZXJpdGFibGVUYWdzLnB1c2goLi4udGFncyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlVGFncyh0YWdzKSB7XG4gICAgICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gIXRhZ3MuaW5jbHVkZXModGFnKSk7XG4gICAgICAgIHRoaXMuaW5oZXJpdGFibGVUYWdzID0gdGhpcy5pbmhlcml0YWJsZVRhZ3MuZmlsdGVyKCh0YWcpID0+ICF0YWdzLmluY2x1ZGVzKHRhZykpO1xuICAgIH1cbiAgICBhZGRNZXRhZGF0YShtZXRhZGF0YSwgaW5oZXJpdCA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IHsgLi4udGhpcy5tZXRhZGF0YSwgLi4ubWV0YWRhdGEgfTtcbiAgICAgICAgaWYgKGluaGVyaXQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5oZXJpdGFibGVNZXRhZGF0YSA9IHsgLi4udGhpcy5pbmhlcml0YWJsZU1ldGFkYXRhLCAuLi5tZXRhZGF0YSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG1ldGFkYXRhKSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubWV0YWRhdGFba2V5XTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGFba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb3B5KGFkZGl0aW9uYWxIYW5kbGVycyA9IFtdLCBpbmhlcml0ID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBtYW5hZ2VyID0gbmV3IENhbGxiYWNrTWFuYWdlcih0aGlzLl9wYXJlbnRSdW5JZCk7XG4gICAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiB0aGlzLmhhbmRsZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBpbmhlcml0YWJsZSA9IHRoaXMuaW5oZXJpdGFibGVIYW5kbGVycy5pbmNsdWRlcyhoYW5kbGVyKTtcbiAgICAgICAgICAgIG1hbmFnZXIuYWRkSGFuZGxlcihoYW5kbGVyLCBpbmhlcml0YWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB0YWcgb2YgdGhpcy50YWdzKSB7XG4gICAgICAgICAgICBjb25zdCBpbmhlcml0YWJsZSA9IHRoaXMuaW5oZXJpdGFibGVUYWdzLmluY2x1ZGVzKHRhZyk7XG4gICAgICAgICAgICBtYW5hZ2VyLmFkZFRhZ3MoW3RhZ10sIGluaGVyaXRhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLm1ldGFkYXRhKSkge1xuICAgICAgICAgICAgY29uc3QgaW5oZXJpdGFibGUgPSBPYmplY3Qua2V5cyh0aGlzLmluaGVyaXRhYmxlTWV0YWRhdGEpLmluY2x1ZGVzKGtleSk7XG4gICAgICAgICAgICBtYW5hZ2VyLmFkZE1ldGFkYXRhKHsgW2tleV06IHRoaXMubWV0YWRhdGFba2V5XSB9LCBpbmhlcml0YWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGFkZGl0aW9uYWxIYW5kbGVycykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gUHJldmVudCBtdWx0aXBsZSBjb3BpZXMgb2YgY29uc29sZV9jYWxsYmFja19oYW5kbGVyXG4gICAgICAgICAgICBtYW5hZ2VyLmhhbmRsZXJzXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoaCkgPT4gaC5uYW1lID09PSBcImNvbnNvbGVfY2FsbGJhY2tfaGFuZGxlclwiKVxuICAgICAgICAgICAgICAgIC5zb21lKChoKSA9PiBoLm5hbWUgPT09IGhhbmRsZXIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hbmFnZXIuYWRkSGFuZGxlcihoYW5kbGVyLCBpbmhlcml0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFuYWdlcjtcbiAgICB9XG4gICAgc3RhdGljIGZyb21IYW5kbGVycyhoYW5kbGVycykge1xuICAgICAgICBjbGFzcyBIYW5kbGVyIGV4dGVuZHMgQmFzZUNhbGxiYWNrSGFuZGxlciB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdXVpZHY0KClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGhhbmRsZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYW5hZ2VyID0gbmV3IHRoaXMoKTtcbiAgICAgICAgbWFuYWdlci5hZGRIYW5kbGVyKG5ldyBIYW5kbGVyKCkpO1xuICAgICAgICByZXR1cm4gbWFuYWdlcjtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGNvbmZpZ3VyZShpbmhlcml0YWJsZUhhbmRsZXJzLCBsb2NhbEhhbmRsZXJzLCBpbmhlcml0YWJsZVRhZ3MsIGxvY2FsVGFncywgaW5oZXJpdGFibGVNZXRhZGF0YSwgbG9jYWxNZXRhZGF0YSwgb3B0aW9ucykge1xuICAgICAgICBsZXQgY2FsbGJhY2tNYW5hZ2VyO1xuICAgICAgICBpZiAoaW5oZXJpdGFibGVIYW5kbGVycyB8fCBsb2NhbEhhbmRsZXJzKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbmhlcml0YWJsZUhhbmRsZXJzKSB8fCAhaW5oZXJpdGFibGVIYW5kbGVycykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlciA9IG5ldyBDYWxsYmFja01hbmFnZXIoKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuc2V0SGFuZGxlcnMoaW5oZXJpdGFibGVIYW5kbGVycz8ubWFwKGVuc3VyZUhhbmRsZXIpID8/IFtdLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlciA9IGluaGVyaXRhYmxlSGFuZGxlcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFja01hbmFnZXIgPSBjYWxsYmFja01hbmFnZXIuY29weShBcnJheS5pc0FycmF5KGxvY2FsSGFuZGxlcnMpXG4gICAgICAgICAgICAgICAgPyBsb2NhbEhhbmRsZXJzLm1hcChlbnN1cmVIYW5kbGVyKVxuICAgICAgICAgICAgICAgIDogbG9jYWxIYW5kbGVycz8uaGFuZGxlcnMsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ZXJib3NlRW5hYmxlZCA9IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fVkVSQk9TRVwiKSA9PT0gXCJ0cnVlXCIgfHxcbiAgICAgICAgICAgIG9wdGlvbnM/LnZlcmJvc2U7XG4gICAgICAgIGNvbnN0IHRyYWNpbmdWMkVuYWJsZWQgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX1RSQUNJTkdfVjJcIikgPT09IFwidHJ1ZVwiO1xuICAgICAgICBjb25zdCB0cmFjaW5nRW5hYmxlZCA9IHRyYWNpbmdWMkVuYWJsZWQgfHxcbiAgICAgICAgICAgIChnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX1RSQUNJTkdcIikgPz8gZmFsc2UpO1xuICAgICAgICBpZiAodmVyYm9zZUVuYWJsZWQgfHwgdHJhY2luZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgIGlmICghY2FsbGJhY2tNYW5hZ2VyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyID0gbmV3IENhbGxiYWNrTWFuYWdlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZlcmJvc2VFbmFibGVkICYmXG4gICAgICAgICAgICAgICAgIWNhbGxiYWNrTWFuYWdlci5oYW5kbGVycy5zb21lKChoYW5kbGVyKSA9PiBoYW5kbGVyLm5hbWUgPT09IENvbnNvbGVDYWxsYmFja0hhbmRsZXIucHJvdG90eXBlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uc29sZUhhbmRsZXIgPSBuZXcgQ29uc29sZUNhbGxiYWNrSGFuZGxlcigpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlci5hZGRIYW5kbGVyKGNvbnNvbGVIYW5kbGVyLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmFjaW5nRW5hYmxlZCAmJlxuICAgICAgICAgICAgICAgICFjYWxsYmFja01hbmFnZXIuaGFuZGxlcnMuc29tZSgoaGFuZGxlcikgPT4gaGFuZGxlci5uYW1lID09PSBcImxhbmdjaGFpbl90cmFjZXJcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2luZ1YyRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuYWRkSGFuZGxlcihhd2FpdCBnZXRUcmFjaW5nVjJDYWxsYmFja0hhbmRsZXIoKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbmhlcml0YWJsZVRhZ3MgfHwgbG9jYWxUYWdzKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2tNYW5hZ2VyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyLmFkZFRhZ3MoaW5oZXJpdGFibGVUYWdzID8/IFtdKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFja01hbmFnZXIuYWRkVGFncyhsb2NhbFRhZ3MgPz8gW10sIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5oZXJpdGFibGVNZXRhZGF0YSB8fCBsb2NhbE1ldGFkYXRhKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2tNYW5hZ2VyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tNYW5hZ2VyLmFkZE1ldGFkYXRhKGluaGVyaXRhYmxlTWV0YWRhdGEgPz8ge30pO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrTWFuYWdlci5hZGRNZXRhZGF0YShsb2NhbE1ldGFkYXRhID8/IHt9LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrTWFuYWdlcjtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgaWYgKFwibmFtZVwiIGluIGhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXI7XG4gICAgfVxuICAgIHJldHVybiBCYXNlQ2FsbGJhY2tIYW5kbGVyLmZyb21NZXRob2RzKGhhbmRsZXIpO1xufVxuLyoqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgcHJvbXB0ID0gUHJvbXB0VGVtcGxhdGUuZnJvbVRlbXBsYXRlKGBXaGF0IGlzIHRoZSBhbnN3ZXIgdG8ge3F1ZXN0aW9ufT9gKTtcbiAqXG4gKiAvLyBFeGFtcGxlIG9mIHVzaW5nIExMTUNoYWluIHRvIHByb2Nlc3MgYSBzZXJpZXMgb2YgcXVlc3Rpb25zXG4gKiBjb25zdCBjaGFpbiA9IG5ldyBMTE1DaGFpbih7XG4gKiAgIGxsbTogbmV3IENoYXRPcGVuQUkoeyB0ZW1wZXJhdHVyZTogMC45IH0pLFxuICogICBwcm9tcHQsXG4gKiB9KTtcbiAqXG4gKiAvLyBQcm9jZXNzIHF1ZXN0aW9ucyB1c2luZyB0aGUgY2hhaW5cbiAqIGNvbnN0IHByb2Nlc3NRdWVzdGlvbnMgPSBhc3luYyAocXVlc3Rpb25zKSA9PiB7XG4gKiAgIGZvciAoY29uc3QgcXVlc3Rpb24gb2YgcXVlc3Rpb25zKSB7XG4gKiAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2hhaW4uY2FsbCh7IHF1ZXN0aW9uIH0pO1xuICogICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gKiAgIH1cbiAqIH07XG4gKlxuICogLy8gRXhhbXBsZSBxdWVzdGlvbnNcbiAqIGNvbnN0IHF1ZXN0aW9ucyA9IFtcbiAqICAgXCJXaGF0IGlzIHlvdXIgbmFtZT9cIixcbiAqICAgXCJXaGF0IGlzIHlvdXIgcXVlc3Q/XCIsXG4gKiAgIFwiV2hhdCBpcyB5b3VyIGZhdm9yaXRlIGNvbG9yP1wiLFxuICogXTtcbiAqXG4gKiAvLyBSdW4gdGhlIGV4YW1wbGVcbiAqIHByb2Nlc3NRdWVzdGlvbnMocXVlc3Rpb25zKS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAqXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFRyYWNlR3JvdXAge1xuICAgIGNvbnN0cnVjdG9yKGdyb3VwTmFtZSwgb3B0aW9ucykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJncm91cE5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGdyb3VwTmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib3B0aW9uc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogb3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicnVuTWFuYWdlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBnZXRUcmFjZUdyb3VwQ2FsbGJhY2tNYW5hZ2VyKGdyb3VwX25hbWUsIGlucHV0cywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjYiA9IG5ldyBMYW5nQ2hhaW5UcmFjZXIob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNtID0gYXdhaXQgQ2FsbGJhY2tNYW5hZ2VyLmNvbmZpZ3VyZShbY2JdKTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlciA9IGF3YWl0IGNtPy5oYW5kbGVDaGFpblN0YXJ0KHtcbiAgICAgICAgICAgIGxjOiAxLFxuICAgICAgICAgICAgdHlwZTogXCJub3RfaW1wbGVtZW50ZWRcIixcbiAgICAgICAgICAgIGlkOiBbXCJsYW5nY2hhaW5cIiwgXCJjYWxsYmFja3NcIiwgXCJncm91cHNcIiwgZ3JvdXBfbmFtZV0sXG4gICAgICAgIH0sIGlucHV0cyA/PyB7fSk7XG4gICAgICAgIGlmICghcnVuTWFuYWdlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBydW4gZ3JvdXAgY2FsbGJhY2sgbWFuYWdlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bk1hbmFnZXI7XG4gICAgfVxuICAgIGFzeW5jIHN0YXJ0KGlucHV0cykge1xuICAgICAgICBpZiAoIXRoaXMucnVuTWFuYWdlcikge1xuICAgICAgICAgICAgdGhpcy5ydW5NYW5hZ2VyID0gYXdhaXQgdGhpcy5nZXRUcmFjZUdyb3VwQ2FsbGJhY2tNYW5hZ2VyKHRoaXMuZ3JvdXBOYW1lLCBpbnB1dHMsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucnVuTWFuYWdlci5nZXRDaGlsZCgpO1xuICAgIH1cbiAgICBhc3luYyBlcnJvcihlcnIpIHtcbiAgICAgICAgaWYgKHRoaXMucnVuTWFuYWdlcikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5ydW5NYW5hZ2VyLmhhbmRsZUNoYWluRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHRoaXMucnVuTWFuYWdlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBlbmQob3V0cHV0KSB7XG4gICAgICAgIGlmICh0aGlzLnJ1bk1hbmFnZXIpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucnVuTWFuYWdlci5oYW5kbGVDaGFpbkVuZChvdXRwdXQgPz8ge30pO1xuICAgICAgICAgICAgdGhpcy5ydW5NYW5hZ2VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIF9jb2VyY2VUb0RpY3QodmFsdWUsIGRlZmF1bHRLZXkpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIlxuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogeyBbZGVmYXVsdEtleV06IHZhbHVlIH07XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRyYWNlQXNHcm91cChncm91cE9wdGlvbnMsIGVuY2xvc2VkQ29kZSwgLi4uYXJncykge1xuICAgIGNvbnN0IHRyYWNlR3JvdXAgPSBuZXcgVHJhY2VHcm91cChncm91cE9wdGlvbnMubmFtZSwgZ3JvdXBPcHRpb25zKTtcbiAgICBjb25zdCBjYWxsYmFja01hbmFnZXIgPSBhd2FpdCB0cmFjZUdyb3VwLnN0YXJ0KHsgLi4uYXJncyB9KTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBlbmNsb3NlZENvZGUoY2FsbGJhY2tNYW5hZ2VyLCAuLi5hcmdzKTtcbiAgICAgICAgYXdhaXQgdHJhY2VHcm91cC5lbmQoX2NvZXJjZVRvRGljdChyZXN1bHQsIFwib3V0cHV0XCIpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBhd2FpdCB0cmFjZUdyb3VwLmVycm9yKGVycik7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59XG4iLCAiZXhwb3J0IGNvbnN0IFJVTl9LRVkgPSBcIl9fcnVuXCI7XG4vKipcbiAqIENodW5rIG9mIGEgc2luZ2xlIGdlbmVyYXRpb24uIFVzZWQgZm9yIHN0cmVhbWluZy5cbiAqL1xuZXhwb3J0IGNsYXNzIEdlbmVyYXRpb25DaHVuayB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRleHRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2VuZXJhdGlvbkluZm9cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50ZXh0ID0gZmllbGRzLnRleHQ7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGlvbkluZm8gPSBmaWVsZHMuZ2VuZXJhdGlvbkluZm87XG4gICAgfVxuICAgIGNvbmNhdChjaHVuaykge1xuICAgICAgICByZXR1cm4gbmV3IEdlbmVyYXRpb25DaHVuayh7XG4gICAgICAgICAgICB0ZXh0OiB0aGlzLnRleHQgKyBjaHVuay50ZXh0LFxuICAgICAgICAgICAgZ2VuZXJhdGlvbkluZm86IHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLmdlbmVyYXRpb25JbmZvLFxuICAgICAgICAgICAgICAgIC4uLmNodW5rLmdlbmVyYXRpb25JbmZvLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENoYXRHZW5lcmF0aW9uQ2h1bmsgZXh0ZW5kcyBHZW5lcmF0aW9uQ2h1bmsge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXNzYWdlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGZpZWxkcy5tZXNzYWdlO1xuICAgIH1cbiAgICBjb25jYXQoY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGF0R2VuZXJhdGlvbkNodW5rKHtcbiAgICAgICAgICAgIHRleHQ6IHRoaXMudGV4dCArIGNodW5rLnRleHQsXG4gICAgICAgICAgICBnZW5lcmF0aW9uSW5mbzoge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuZ2VuZXJhdGlvbkluZm8sXG4gICAgICAgICAgICAgICAgLi4uY2h1bmsuZ2VuZXJhdGlvbkluZm8sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLmNvbmNhdChjaHVuay5tZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwgIi8vIEB0cy1ub2NoZWNrXG4vLyBJbmxpbmVkIHRvIGRlYWwgd2l0aCBwb3J0YWJpbGl0eSBpc3N1ZXMgd2l0aCBpbXBvcnRpbmcgY3J5cHRvIG1vZHVsZVxuLypcbiAqIFtqcy1zaGExXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZW1uMTc4L2pzLXNoYTF9XG4gKlxuICogQHZlcnNpb24gMC42LjBcbiAqIEBhdXRob3IgQ2hlbiwgWWktQ3l1YW4gW2VtbjE3OEBnbWFpbC5jb21dXG4gKiBAY29weXJpZ2h0IENoZW4sIFlpLUN5dWFuIDIwMTQtMjAxN1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cbi8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cblwidXNlIHN0cmljdFwiO1xudmFyIHJvb3QgPSB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiID8gd2luZG93IDoge307XG52YXIgSEVYX0NIQVJTID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCIuc3BsaXQoXCJcIik7XG52YXIgRVhUUkEgPSBbLTIxNDc0ODM2NDgsIDgzODg2MDgsIDMyNzY4LCAxMjhdO1xudmFyIFNISUZUID0gWzI0LCAxNiwgOCwgMF07XG52YXIgT1VUUFVUX1RZUEVTID0gW1wiaGV4XCIsIFwiYXJyYXlcIiwgXCJkaWdlc3RcIiwgXCJhcnJheUJ1ZmZlclwiXTtcbnZhciBibG9ja3MgPSBbXTtcbmZ1bmN0aW9uIFNoYTEoc2hhcmVkTWVtb3J5KSB7XG4gICAgaWYgKHNoYXJlZE1lbW9yeSkge1xuICAgICAgICBibG9ja3NbMF0gPVxuICAgICAgICAgICAgYmxvY2tzWzE2XSA9XG4gICAgICAgICAgICAgICAgYmxvY2tzWzFdID1cbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzJdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1szXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzRdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s2XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzddID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzhdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s5XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzEwXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzEyXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzEzXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxNF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzE1XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDtcbiAgICAgICAgdGhpcy5ibG9ja3MgPSBibG9ja3M7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmJsb2NrcyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgICB9XG4gICAgdGhpcy5oMCA9IDB4Njc0NTIzMDE7XG4gICAgdGhpcy5oMSA9IDB4ZWZjZGFiODk7XG4gICAgdGhpcy5oMiA9IDB4OThiYWRjZmU7XG4gICAgdGhpcy5oMyA9IDB4MTAzMjU0NzY7XG4gICAgdGhpcy5oNCA9IDB4YzNkMmUxZjA7XG4gICAgdGhpcy5ibG9jayA9IHRoaXMuc3RhcnQgPSB0aGlzLmJ5dGVzID0gdGhpcy5oQnl0ZXMgPSAwO1xuICAgIHRoaXMuZmluYWxpemVkID0gdGhpcy5oYXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLmZpcnN0ID0gdHJ1ZTtcbn1cblNoYTEucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vdFN0cmluZyA9IHR5cGVvZiBtZXNzYWdlICE9PSBcInN0cmluZ1wiO1xuICAgIGlmIChub3RTdHJpbmcgJiYgbWVzc2FnZS5jb25zdHJ1Y3RvciA9PT0gcm9vdC5BcnJheUJ1ZmZlcikge1xuICAgICAgICBtZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkobWVzc2FnZSk7XG4gICAgfVxuICAgIHZhciBjb2RlLCBpbmRleCA9IDAsIGksIGxlbmd0aCA9IG1lc3NhZ2UubGVuZ3RoIHx8IDAsIGJsb2NrcyA9IHRoaXMuYmxvY2tzO1xuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy5oYXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBibG9ja3NbMF0gPSB0aGlzLmJsb2NrO1xuICAgICAgICAgICAgYmxvY2tzWzE2XSA9XG4gICAgICAgICAgICAgICAgYmxvY2tzWzFdID1cbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzJdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1szXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzRdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s2XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzddID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzhdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1s5XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzEwXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzEyXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzEzXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxNF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzE1XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm90U3RyaW5nKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSB0aGlzLnN0YXJ0OyBpbmRleCA8IGxlbmd0aCAmJiBpIDwgNjQ7ICsraW5kZXgpIHtcbiAgICAgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSBtZXNzYWdlW2luZGV4XSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaSA9IHRoaXMuc3RhcnQ7IGluZGV4IDwgbGVuZ3RoICYmIGkgPCA2NDsgKytpbmRleCkge1xuICAgICAgICAgICAgICAgIGNvZGUgPSBtZXNzYWdlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlIDwgMHg4MCkge1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSBjb2RlIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb2RlIDwgMHg4MDApIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4YzAgfCAoY29kZSA+PiA2KSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvZGUgPCAweGQ4MDAgfHwgY29kZSA+PSAweGUwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ZTAgfCAoY29kZSA+PiAxMikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgMHgxMDAwMCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCgoY29kZSAmIDB4M2ZmKSA8PCAxMCkgfCAobWVzc2FnZS5jaGFyQ29kZUF0KCsraW5kZXgpICYgMHgzZmYpKTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ZjAgfCAoY29kZSA+PiAxOCkpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiAxMikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDYpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RCeXRlSW5kZXggPSBpO1xuICAgICAgICB0aGlzLmJ5dGVzICs9IGkgLSB0aGlzLnN0YXJ0O1xuICAgICAgICBpZiAoaSA+PSA2NCkge1xuICAgICAgICAgICAgdGhpcy5ibG9jayA9IGJsb2Nrc1sxNl07XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gaSAtIDY0O1xuICAgICAgICAgICAgdGhpcy5oYXNoKCk7XG4gICAgICAgICAgICB0aGlzLmhhc2hlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5ieXRlcyA+IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgdGhpcy5oQnl0ZXMgKz0gKHRoaXMuYnl0ZXMgLyA0Mjk0OTY3Mjk2KSA8PCAwO1xuICAgICAgICB0aGlzLmJ5dGVzID0gdGhpcy5ieXRlcyAlIDQyOTQ5NjcyOTY7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblNoYTEucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZmluYWxpemVkID0gdHJ1ZTtcbiAgICB2YXIgYmxvY2tzID0gdGhpcy5ibG9ja3MsIGkgPSB0aGlzLmxhc3RCeXRlSW5kZXg7XG4gICAgYmxvY2tzWzE2XSA9IHRoaXMuYmxvY2s7XG4gICAgYmxvY2tzW2kgPj4gMl0gfD0gRVhUUkFbaSAmIDNdO1xuICAgIHRoaXMuYmxvY2sgPSBibG9ja3NbMTZdO1xuICAgIGlmIChpID49IDU2KSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGJsb2Nrc1swXSA9IHRoaXMuYmxvY2s7XG4gICAgICAgIGJsb2Nrc1sxNl0gPVxuICAgICAgICAgICAgYmxvY2tzWzFdID1cbiAgICAgICAgICAgICAgICBibG9ja3NbMl0gPVxuICAgICAgICAgICAgICAgICAgICBibG9ja3NbM10gPVxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzRdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbNl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzddID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbOF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbOV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzEwXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzExXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxMl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzEzXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzWzE0XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc1sxNV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDtcbiAgICB9XG4gICAgYmxvY2tzWzE0XSA9ICh0aGlzLmhCeXRlcyA8PCAzKSB8ICh0aGlzLmJ5dGVzID4+PiAyOSk7XG4gICAgYmxvY2tzWzE1XSA9IHRoaXMuYnl0ZXMgPDwgMztcbiAgICB0aGlzLmhhc2goKTtcbn07XG5TaGExLnByb3RvdHlwZS5oYXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhID0gdGhpcy5oMCwgYiA9IHRoaXMuaDEsIGMgPSB0aGlzLmgyLCBkID0gdGhpcy5oMywgZSA9IHRoaXMuaDQ7XG4gICAgdmFyIGYsIGosIHQsIGJsb2NrcyA9IHRoaXMuYmxvY2tzO1xuICAgIGZvciAoaiA9IDE2OyBqIDwgODA7ICsraikge1xuICAgICAgICB0ID0gYmxvY2tzW2ogLSAzXSBeIGJsb2Nrc1tqIC0gOF0gXiBibG9ja3NbaiAtIDE0XSBeIGJsb2Nrc1tqIC0gMTZdO1xuICAgICAgICBibG9ja3Nbal0gPSAodCA8PCAxKSB8ICh0ID4+PiAzMSk7XG4gICAgfVxuICAgIGZvciAoaiA9IDA7IGogPCAyMDsgaiArPSA1KSB7XG4gICAgICAgIGYgPSAoYiAmIGMpIHwgKH5iICYgZCk7XG4gICAgICAgIHQgPSAoYSA8PCA1KSB8IChhID4+PiAyNyk7XG4gICAgICAgIGUgPSAodCArIGYgKyBlICsgMTUxODUwMDI0OSArIGJsb2Nrc1tqXSkgPDwgMDtcbiAgICAgICAgYiA9IChiIDw8IDMwKSB8IChiID4+PiAyKTtcbiAgICAgICAgZiA9IChhICYgYikgfCAofmEgJiBjKTtcbiAgICAgICAgdCA9IChlIDw8IDUpIHwgKGUgPj4+IDI3KTtcbiAgICAgICAgZCA9ICh0ICsgZiArIGQgKyAxNTE4NTAwMjQ5ICsgYmxvY2tzW2ogKyAxXSkgPDwgMDtcbiAgICAgICAgYSA9IChhIDw8IDMwKSB8IChhID4+PiAyKTtcbiAgICAgICAgZiA9IChlICYgYSkgfCAofmUgJiBiKTtcbiAgICAgICAgdCA9IChkIDw8IDUpIHwgKGQgPj4+IDI3KTtcbiAgICAgICAgYyA9ICh0ICsgZiArIGMgKyAxNTE4NTAwMjQ5ICsgYmxvY2tzW2ogKyAyXSkgPDwgMDtcbiAgICAgICAgZSA9IChlIDw8IDMwKSB8IChlID4+PiAyKTtcbiAgICAgICAgZiA9IChkICYgZSkgfCAofmQgJiBhKTtcbiAgICAgICAgdCA9IChjIDw8IDUpIHwgKGMgPj4+IDI3KTtcbiAgICAgICAgYiA9ICh0ICsgZiArIGIgKyAxNTE4NTAwMjQ5ICsgYmxvY2tzW2ogKyAzXSkgPDwgMDtcbiAgICAgICAgZCA9IChkIDw8IDMwKSB8IChkID4+PiAyKTtcbiAgICAgICAgZiA9IChjICYgZCkgfCAofmMgJiBlKTtcbiAgICAgICAgdCA9IChiIDw8IDUpIHwgKGIgPj4+IDI3KTtcbiAgICAgICAgYSA9ICh0ICsgZiArIGEgKyAxNTE4NTAwMjQ5ICsgYmxvY2tzW2ogKyA0XSkgPDwgMDtcbiAgICAgICAgYyA9IChjIDw8IDMwKSB8IChjID4+PiAyKTtcbiAgICB9XG4gICAgZm9yICg7IGogPCA0MDsgaiArPSA1KSB7XG4gICAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICAgIHQgPSAoYSA8PCA1KSB8IChhID4+PiAyNyk7XG4gICAgICAgIGUgPSAodCArIGYgKyBlICsgMTg1OTc3NTM5MyArIGJsb2Nrc1tqXSkgPDwgMDtcbiAgICAgICAgYiA9IChiIDw8IDMwKSB8IChiID4+PiAyKTtcbiAgICAgICAgZiA9IGEgXiBiIF4gYztcbiAgICAgICAgdCA9IChlIDw8IDUpIHwgKGUgPj4+IDI3KTtcbiAgICAgICAgZCA9ICh0ICsgZiArIGQgKyAxODU5Nzc1MzkzICsgYmxvY2tzW2ogKyAxXSkgPDwgMDtcbiAgICAgICAgYSA9IChhIDw8IDMwKSB8IChhID4+PiAyKTtcbiAgICAgICAgZiA9IGUgXiBhIF4gYjtcbiAgICAgICAgdCA9IChkIDw8IDUpIHwgKGQgPj4+IDI3KTtcbiAgICAgICAgYyA9ICh0ICsgZiArIGMgKyAxODU5Nzc1MzkzICsgYmxvY2tzW2ogKyAyXSkgPDwgMDtcbiAgICAgICAgZSA9IChlIDw8IDMwKSB8IChlID4+PiAyKTtcbiAgICAgICAgZiA9IGQgXiBlIF4gYTtcbiAgICAgICAgdCA9IChjIDw8IDUpIHwgKGMgPj4+IDI3KTtcbiAgICAgICAgYiA9ICh0ICsgZiArIGIgKyAxODU5Nzc1MzkzICsgYmxvY2tzW2ogKyAzXSkgPDwgMDtcbiAgICAgICAgZCA9IChkIDw8IDMwKSB8IChkID4+PiAyKTtcbiAgICAgICAgZiA9IGMgXiBkIF4gZTtcbiAgICAgICAgdCA9IChiIDw8IDUpIHwgKGIgPj4+IDI3KTtcbiAgICAgICAgYSA9ICh0ICsgZiArIGEgKyAxODU5Nzc1MzkzICsgYmxvY2tzW2ogKyA0XSkgPDwgMDtcbiAgICAgICAgYyA9IChjIDw8IDMwKSB8IChjID4+PiAyKTtcbiAgICB9XG4gICAgZm9yICg7IGogPCA2MDsgaiArPSA1KSB7XG4gICAgICAgIGYgPSAoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZCk7XG4gICAgICAgIHQgPSAoYSA8PCA1KSB8IChhID4+PiAyNyk7XG4gICAgICAgIGUgPSAodCArIGYgKyBlIC0gMTg5NDAwNzU4OCArIGJsb2Nrc1tqXSkgPDwgMDtcbiAgICAgICAgYiA9IChiIDw8IDMwKSB8IChiID4+PiAyKTtcbiAgICAgICAgZiA9IChhICYgYikgfCAoYSAmIGMpIHwgKGIgJiBjKTtcbiAgICAgICAgdCA9IChlIDw8IDUpIHwgKGUgPj4+IDI3KTtcbiAgICAgICAgZCA9ICh0ICsgZiArIGQgLSAxODk0MDA3NTg4ICsgYmxvY2tzW2ogKyAxXSkgPDwgMDtcbiAgICAgICAgYSA9IChhIDw8IDMwKSB8IChhID4+PiAyKTtcbiAgICAgICAgZiA9IChlICYgYSkgfCAoZSAmIGIpIHwgKGEgJiBiKTtcbiAgICAgICAgdCA9IChkIDw8IDUpIHwgKGQgPj4+IDI3KTtcbiAgICAgICAgYyA9ICh0ICsgZiArIGMgLSAxODk0MDA3NTg4ICsgYmxvY2tzW2ogKyAyXSkgPDwgMDtcbiAgICAgICAgZSA9IChlIDw8IDMwKSB8IChlID4+PiAyKTtcbiAgICAgICAgZiA9IChkICYgZSkgfCAoZCAmIGEpIHwgKGUgJiBhKTtcbiAgICAgICAgdCA9IChjIDw8IDUpIHwgKGMgPj4+IDI3KTtcbiAgICAgICAgYiA9ICh0ICsgZiArIGIgLSAxODk0MDA3NTg4ICsgYmxvY2tzW2ogKyAzXSkgPDwgMDtcbiAgICAgICAgZCA9IChkIDw8IDMwKSB8IChkID4+PiAyKTtcbiAgICAgICAgZiA9IChjICYgZCkgfCAoYyAmIGUpIHwgKGQgJiBlKTtcbiAgICAgICAgdCA9IChiIDw8IDUpIHwgKGIgPj4+IDI3KTtcbiAgICAgICAgYSA9ICh0ICsgZiArIGEgLSAxODk0MDA3NTg4ICsgYmxvY2tzW2ogKyA0XSkgPDwgMDtcbiAgICAgICAgYyA9IChjIDw8IDMwKSB8IChjID4+PiAyKTtcbiAgICB9XG4gICAgZm9yICg7IGogPCA4MDsgaiArPSA1KSB7XG4gICAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICAgIHQgPSAoYSA8PCA1KSB8IChhID4+PiAyNyk7XG4gICAgICAgIGUgPSAodCArIGYgKyBlIC0gODk5NDk3NTE0ICsgYmxvY2tzW2pdKSA8PCAwO1xuICAgICAgICBiID0gKGIgPDwgMzApIHwgKGIgPj4+IDIpO1xuICAgICAgICBmID0gYSBeIGIgXiBjO1xuICAgICAgICB0ID0gKGUgPDwgNSkgfCAoZSA+Pj4gMjcpO1xuICAgICAgICBkID0gKHQgKyBmICsgZCAtIDg5OTQ5NzUxNCArIGJsb2Nrc1tqICsgMV0pIDw8IDA7XG4gICAgICAgIGEgPSAoYSA8PCAzMCkgfCAoYSA+Pj4gMik7XG4gICAgICAgIGYgPSBlIF4gYSBeIGI7XG4gICAgICAgIHQgPSAoZCA8PCA1KSB8IChkID4+PiAyNyk7XG4gICAgICAgIGMgPSAodCArIGYgKyBjIC0gODk5NDk3NTE0ICsgYmxvY2tzW2ogKyAyXSkgPDwgMDtcbiAgICAgICAgZSA9IChlIDw8IDMwKSB8IChlID4+PiAyKTtcbiAgICAgICAgZiA9IGQgXiBlIF4gYTtcbiAgICAgICAgdCA9IChjIDw8IDUpIHwgKGMgPj4+IDI3KTtcbiAgICAgICAgYiA9ICh0ICsgZiArIGIgLSA4OTk0OTc1MTQgKyBibG9ja3NbaiArIDNdKSA8PCAwO1xuICAgICAgICBkID0gKGQgPDwgMzApIHwgKGQgPj4+IDIpO1xuICAgICAgICBmID0gYyBeIGQgXiBlO1xuICAgICAgICB0ID0gKGIgPDwgNSkgfCAoYiA+Pj4gMjcpO1xuICAgICAgICBhID0gKHQgKyBmICsgYSAtIDg5OTQ5NzUxNCArIGJsb2Nrc1tqICsgNF0pIDw8IDA7XG4gICAgICAgIGMgPSAoYyA8PCAzMCkgfCAoYyA+Pj4gMik7XG4gICAgfVxuICAgIHRoaXMuaDAgPSAodGhpcy5oMCArIGEpIDw8IDA7XG4gICAgdGhpcy5oMSA9ICh0aGlzLmgxICsgYikgPDwgMDtcbiAgICB0aGlzLmgyID0gKHRoaXMuaDIgKyBjKSA8PCAwO1xuICAgIHRoaXMuaDMgPSAodGhpcy5oMyArIGQpIDw8IDA7XG4gICAgdGhpcy5oNCA9ICh0aGlzLmg0ICsgZSkgPDwgMDtcbn07XG5TaGExLnByb3RvdHlwZS5oZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5maW5hbGl6ZSgpO1xuICAgIHZhciBoMCA9IHRoaXMuaDAsIGgxID0gdGhpcy5oMSwgaDIgPSB0aGlzLmgyLCBoMyA9IHRoaXMuaDMsIGg0ID0gdGhpcy5oNDtcbiAgICByZXR1cm4gKEhFWF9DSEFSU1soaDAgPj4gMjgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgwID4+IDI0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMCA+PiAyMCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDAgPj4gMTYpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgwID4+IDEyKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMCA+PiA4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMCA+PiA0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTW2gwICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgxID4+IDI4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMSA+PiAyNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDEgPj4gMjApICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgxID4+IDE2KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMSA+PiAxMikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDEgPj4gOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDEgPj4gNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1toMSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMiA+PiAyOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDIgPj4gMjQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgyID4+IDIwKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMiA+PiAxNikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDIgPj4gMTIpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgyID4+IDgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgyID4+IDQpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbaDIgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDMgPj4gMjgpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgzID4+IDI0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMyA+PiAyMCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDMgPj4gMTYpICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGgzID4+IDEyKSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMyA+PiA4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoMyA+PiA0KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTW2gzICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg0ID4+IDI4KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNCA+PiAyNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDQgPj4gMjApICYgMHgwZl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg0ID4+IDE2KSAmIDB4MGZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNCA+PiAxMikgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDQgPj4gOCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDQgPj4gNCkgJiAweDBmXSArXG4gICAgICAgIEhFWF9DSEFSU1toNCAmIDB4MGZdKTtcbn07XG5TaGExLnByb3RvdHlwZS50b1N0cmluZyA9IFNoYTEucHJvdG90eXBlLmhleDtcblNoYTEucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbmFsaXplKCk7XG4gICAgdmFyIGgwID0gdGhpcy5oMCwgaDEgPSB0aGlzLmgxLCBoMiA9IHRoaXMuaDIsIGgzID0gdGhpcy5oMywgaDQgPSB0aGlzLmg0O1xuICAgIHJldHVybiBbXG4gICAgICAgIChoMCA+PiAyNCkgJiAweGZmLFxuICAgICAgICAoaDAgPj4gMTYpICYgMHhmZixcbiAgICAgICAgKGgwID4+IDgpICYgMHhmZixcbiAgICAgICAgaDAgJiAweGZmLFxuICAgICAgICAoaDEgPj4gMjQpICYgMHhmZixcbiAgICAgICAgKGgxID4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIChoMSA+PiA4KSAmIDB4ZmYsXG4gICAgICAgIGgxICYgMHhmZixcbiAgICAgICAgKGgyID4+IDI0KSAmIDB4ZmYsXG4gICAgICAgIChoMiA+PiAxNikgJiAweGZmLFxuICAgICAgICAoaDIgPj4gOCkgJiAweGZmLFxuICAgICAgICBoMiAmIDB4ZmYsXG4gICAgICAgIChoMyA+PiAyNCkgJiAweGZmLFxuICAgICAgICAoaDMgPj4gMTYpICYgMHhmZixcbiAgICAgICAgKGgzID4+IDgpICYgMHhmZixcbiAgICAgICAgaDMgJiAweGZmLFxuICAgICAgICAoaDQgPj4gMjQpICYgMHhmZixcbiAgICAgICAgKGg0ID4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIChoNCA+PiA4KSAmIDB4ZmYsXG4gICAgICAgIGg0ICYgMHhmZixcbiAgICBdO1xufTtcblNoYTEucHJvdG90eXBlLmFycmF5ID0gU2hhMS5wcm90b3R5cGUuZGlnZXN0O1xuU2hhMS5wcm90b3R5cGUuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5maW5hbGl6ZSgpO1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoMjApO1xuICAgIHZhciBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMigwLCB0aGlzLmgwKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoNCwgdGhpcy5oMSk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDgsIHRoaXMuaDIpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMigxMiwgdGhpcy5oMyk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDE2LCB0aGlzLmg0KTtcbiAgICByZXR1cm4gYnVmZmVyO1xufTtcbmV4cG9ydCBjb25zdCBpbnNlY3VyZUhhc2ggPSAobWVzc2FnZSkgPT4ge1xuICAgIHJldHVybiBuZXcgU2hhMSh0cnVlKS51cGRhdGUobWVzc2FnZSlbXCJoZXhcIl0oKTtcbn07XG4iLCAiaW1wb3J0IHsgaW5zZWN1cmVIYXNoIH0gZnJvbSBcIi4vdXRpbHMvaGFzaC5qc1wiO1xuaW1wb3J0IHsgbWFwU3RvcmVkTWVzc2FnZVRvQ2hhdE1lc3NhZ2UsIH0gZnJvbSBcIi4vbWVzc2FnZXMvaW5kZXguanNcIjtcbi8qKlxuICogVGhpcyBjYWNoZSBrZXkgc2hvdWxkIGJlIGNvbnNpc3RlbnQgYWNyb3NzIGFsbCB2ZXJzaW9ucyBvZiBsYW5nY2hhaW4uXG4gKiBJdCBpcyBjdXJyZW50bHkgTk9UIGNvbnNpc3RlbnQgYWNyb3NzIHZlcnNpb25zIG9mIGxhbmdjaGFpbi5cbiAqXG4gKiBBIGh1Z2UgYmVuZWZpdCBvZiBoYXZpbmcgYSByZW1vdGUgY2FjaGUgKGxpa2UgcmVkaXMpIGlzIHRoYXQgeW91IGNhblxuICogYWNjZXNzIHRoZSBjYWNoZSBmcm9tIGRpZmZlcmVudCBwcm9jZXNzZXMvbWFjaGluZXMuIFRoZSBhbGxvd3MgeW91IHRvXG4gKiBzZXBlcmF0ZSBjb25jZXJucyBhbmQgc2NhbGUgaG9yaXpvbnRhbGx5LlxuICpcbiAqIFRPRE86IE1ha2UgY2FjaGUga2V5IGNvbnNpc3RlbnQgYWNyb3NzIHZlcnNpb25zIG9mIGxhbmdjaGFpbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldENhY2hlS2V5ID0gKC4uLnN0cmluZ3MpID0+IGluc2VjdXJlSGFzaChzdHJpbmdzLmpvaW4oXCJfXCIpKTtcbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZVN0b3JlZEdlbmVyYXRpb24oc3RvcmVkR2VuZXJhdGlvbikge1xuICAgIGlmIChzdG9yZWRHZW5lcmF0aW9uLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogc3RvcmVkR2VuZXJhdGlvbi50ZXh0LFxuICAgICAgICAgICAgbWVzc2FnZTogbWFwU3RvcmVkTWVzc2FnZVRvQ2hhdE1lc3NhZ2Uoc3RvcmVkR2VuZXJhdGlvbi5tZXNzYWdlKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHRleHQ6IHN0b3JlZEdlbmVyYXRpb24udGV4dCB9O1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVHZW5lcmF0aW9uKGdlbmVyYXRpb24pIHtcbiAgICBjb25zdCBzZXJpYWxpemVkVmFsdWUgPSB7XG4gICAgICAgIHRleHQ6IGdlbmVyYXRpb24udGV4dCxcbiAgICB9O1xuICAgIGlmIChnZW5lcmF0aW9uLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXJpYWxpemVkVmFsdWUubWVzc2FnZSA9IGdlbmVyYXRpb24ubWVzc2FnZS50b0RpY3QoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRWYWx1ZTtcbn1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIGNhY2hlcy4gQWxsIGNhY2hlcyBzaG91bGQgZXh0ZW5kIHRoaXMgY2xhc3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlQ2FjaGUge1xufVxuY29uc3QgR0xPQkFMX01BUCA9IG5ldyBNYXAoKTtcbi8qKlxuICogQSBjYWNoZSBmb3Igc3RvcmluZyBMTE0gZ2VuZXJhdGlvbnMgdGhhdCBzdG9yZXMgZGF0YSBpbiBtZW1vcnkuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbk1lbW9yeUNhY2hlIGV4dGVuZHMgQmFzZUNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihtYXApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FjaGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYWNoZSA9IG1hcCA/PyBuZXcgTWFwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBkYXRhIGZyb20gdGhlIGNhY2hlIHVzaW5nIGEgcHJvbXB0IGFuZCBhbiBMTE0ga2V5LiBJZiB0aGVcbiAgICAgKiBkYXRhIGlzIG5vdCBmb3VuZCwgaXQgcmV0dXJucyBudWxsLlxuICAgICAqIEBwYXJhbSBwcm9tcHQgVGhlIHByb21wdCB1c2VkIHRvIGZpbmQgdGhlIGRhdGEuXG4gICAgICogQHBhcmFtIGxsbUtleSBUaGUgTExNIGtleSB1c2VkIHRvIGZpbmQgdGhlIGRhdGEuXG4gICAgICogQHJldHVybnMgVGhlIGRhdGEgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvbXB0IGFuZCBMTE0ga2V5LCBvciBudWxsIGlmIG5vdCBmb3VuZC5cbiAgICAgKi9cbiAgICBsb29rdXAocHJvbXB0LCBsbG1LZXkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmNhY2hlLmdldChnZXRDYWNoZUtleShwcm9tcHQsIGxsbUtleSkpID8/IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjYWNoZSB3aXRoIG5ldyBkYXRhIHVzaW5nIGEgcHJvbXB0IGFuZCBhbiBMTE0ga2V5LlxuICAgICAqIEBwYXJhbSBwcm9tcHQgVGhlIHByb21wdCB1c2VkIHRvIHN0b3JlIHRoZSBkYXRhLlxuICAgICAqIEBwYXJhbSBsbG1LZXkgVGhlIExMTSBrZXkgdXNlZCB0byBzdG9yZSB0aGUgZGF0YS5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIGRhdGEgdG8gYmUgc3RvcmVkLlxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZShwcm9tcHQsIGxsbUtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5jYWNoZS5zZXQoZ2V0Q2FjaGVLZXkocHJvbXB0LCBsbG1LZXkpLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBnbG9iYWwgaW5zdGFuY2Ugb2YgSW5NZW1vcnlDYWNoZSB1c2luZyBhIHByZWRlZmluZWQgZ2xvYmFsXG4gICAgICogbWFwIGFzIHRoZSBpbml0aWFsIGNhY2hlLlxuICAgICAqIEByZXR1cm5zIEEgZ2xvYmFsIGluc3RhbmNlIG9mIEluTWVtb3J5Q2FjaGUuXG4gICAgICovXG4gICAgc3RhdGljIGdsb2JhbCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbk1lbW9yeUNhY2hlKEdMT0JBTF9NQVApO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBTZXJpYWxpemFibGUgfSBmcm9tIFwiLi9sb2FkL3NlcmlhbGl6YWJsZS5qc1wiO1xuaW1wb3J0IHsgSHVtYW5NZXNzYWdlLCBnZXRCdWZmZXJTdHJpbmcsIH0gZnJvbSBcIi4vbWVzc2FnZXMvaW5kZXguanNcIjtcbi8qKlxuICogQmFzZSBQcm9tcHRWYWx1ZSBjbGFzcy4gQWxsIHByb21wdCB2YWx1ZXMgc2hvdWxkIGV4dGVuZCB0aGlzIGNsYXNzLlxuICovXG5leHBvcnQgY2xhc3MgQmFzZVByb21wdFZhbHVlIGV4dGVuZHMgU2VyaWFsaXphYmxlIHtcbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIHByb21wdCB2YWx1ZSBhcyBhIHN0cmluZy4gSXQgZXh0ZW5kcyB0aGUgQmFzZVByb21wdFZhbHVlXG4gKiBjbGFzcyBhbmQgb3ZlcnJpZGVzIHRoZSB0b1N0cmluZyBhbmQgdG9DaGF0TWVzc2FnZXMgbWV0aG9kcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmluZ1Byb21wdFZhbHVlIGV4dGVuZHMgQmFzZVByb21wdFZhbHVlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiU3RyaW5nUHJvbXB0VmFsdWVcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoeyB2YWx1ZSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInByb21wdF92YWx1ZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHRvQ2hhdE1lc3NhZ2VzKCkge1xuICAgICAgICByZXR1cm4gW25ldyBIdW1hbk1lc3NhZ2UodGhpcy52YWx1ZSldO1xuICAgIH1cbn1cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGEgY2hhdCBwcm9tcHQgdmFsdWUuIEl0IGV4dGVuZHMgdGhlXG4gKiBCYXNlUHJvbXB0VmFsdWUgYW5kIGluY2x1ZGVzIGFuIGFycmF5IG9mIEJhc2VNZXNzYWdlIGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIENoYXRQcm9tcHRWYWx1ZSBleHRlbmRzIEJhc2VQcm9tcHRWYWx1ZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIkNoYXRQcm9tcHRWYWx1ZVwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGRzKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBmaWVsZHMgPSB7IG1lc3NhZ2VzOiBmaWVsZHMgfTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicHJvbXB0X3ZhbHVlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXNzYWdlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzID0gZmllbGRzLm1lc3NhZ2VzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGdldEJ1ZmZlclN0cmluZyh0aGlzLm1lc3NhZ2VzKTtcbiAgICB9XG4gICAgdG9DaGF0TWVzc2FnZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzO1xuICAgIH1cbn1cbi8qKlxuICogQ2xhc3MgdGhhdCByZXByZXNlbnRzIGFuIGltYWdlIHByb21wdCB2YWx1ZS4gSXQgZXh0ZW5kcyB0aGVcbiAqIEJhc2VQcm9tcHRWYWx1ZSBhbmQgaW5jbHVkZXMgYW4gSW1hZ2VVUkwgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbWFnZVByb21wdFZhbHVlIGV4dGVuZHMgQmFzZVByb21wdFZhbHVlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiSW1hZ2VQcm9tcHRWYWx1ZVwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgaWYgKCEoXCJpbWFnZVVybFwiIGluIGZpZWxkcykpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgZmllbGRzID0geyBpbWFnZVVybDogZmllbGRzIH07XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInByb21wdF92YWx1ZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW1hZ2VVcmxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEBpZ25vcmUgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbWFnZVVybCA9IGZpZWxkcy5pbWFnZVVybDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlVXJsLnVybDtcbiAgICB9XG4gICAgdG9DaGF0TWVzc2FnZXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgSHVtYW5NZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VfdXJsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZV91cmw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IHRoaXMuaW1hZ2VVcmwuZGV0YWlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdGhpcy5pbWFnZVVybC51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHBSZXRyeSBmcm9tIFwicC1yZXRyeVwiO1xuaW1wb3J0IFBRdWV1ZU1vZCBmcm9tIFwicC1xdWV1ZVwiO1xuY29uc3QgU1RBVFVTX05PX1JFVFJZID0gW1xuICAgIDQwMCxcbiAgICA0MDEsXG4gICAgNDAyLFxuICAgIDQwMyxcbiAgICA0MDQsXG4gICAgNDA1LFxuICAgIDQwNixcbiAgICA0MDcsXG4gICAgNDA4LFxuICAgIDQwOSwgLy8gQ29uZmxpY3Rcbl07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgZGVmYXVsdEZhaWxlZEF0dGVtcHRIYW5kbGVyID0gKGVycm9yKSA9PiB7XG4gICAgaWYgKGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIkNhbmNlbFwiKSB8fFxuICAgICAgICBlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJUaW1lb3V0RXJyb3JcIikgfHxcbiAgICAgICAgZXJyb3IubmFtZSA9PT0gXCJUaW1lb3V0RXJyb3JcIiB8fFxuICAgICAgICBlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJBYm9ydEVycm9yXCIpIHx8XG4gICAgICAgIGVycm9yLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGlmIChlcnJvcj8uY29kZSA9PT0gXCJFQ09OTkFCT1JURURcIikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHVzID0gXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBlcnJvcj8ucmVzcG9uc2U/LnN0YXR1cyA/PyBlcnJvcj8uc3RhdHVzO1xuICAgIGlmIChzdGF0dXMgJiYgU1RBVFVTX05PX1JFVFJZLmluY2x1ZGVzKCtzdGF0dXMpKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGlmIChlcnJvcj8uZXJyb3I/LmNvZGUgPT09IFwiaW5zdWZmaWNpZW50X3F1b3RhXCIpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGVycm9yPy5tZXNzYWdlKTtcbiAgICAgICAgZXJyLm5hbWUgPSBcIkluc3VmZmljaWVudFF1b3RhRXJyb3JcIjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn07XG4vKipcbiAqIEEgY2xhc3MgdGhhdCBjYW4gYmUgdXNlZCB0byBtYWtlIGFzeW5jIGNhbGxzIHdpdGggY29uY3VycmVuY3kgYW5kIHJldHJ5IGxvZ2ljLlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBtYWtpbmcgY2FsbHMgdG8gYW55IGtpbmQgb2YgXCJleHBlbnNpdmVcIiBleHRlcm5hbCByZXNvdXJjZSxcbiAqIGJlIGl0IGJlY2F1c2UgaXQncyByYXRlLWxpbWl0ZWQsIHN1YmplY3QgdG8gbmV0d29yayBpc3N1ZXMsIGV0Yy5cbiAqXG4gKiBDb25jdXJyZW50IGNhbGxzIGFyZSBsaW1pdGVkIGJ5IHRoZSBgbWF4Q29uY3VycmVuY3lgIHBhcmFtZXRlciwgd2hpY2ggZGVmYXVsdHNcbiAqIHRvIGBJbmZpbml0eWAuIFRoaXMgbWVhbnMgdGhhdCBieSBkZWZhdWx0LCBhbGwgY2FsbHMgd2lsbCBiZSBtYWRlIGluIHBhcmFsbGVsLlxuICpcbiAqIFJldHJpZXMgYXJlIGxpbWl0ZWQgYnkgdGhlIGBtYXhSZXRyaWVzYCBwYXJhbWV0ZXIsIHdoaWNoIGRlZmF1bHRzIHRvIDYuIFRoaXNcbiAqIG1lYW5zIHRoYXQgYnkgZGVmYXVsdCwgZWFjaCBjYWxsIHdpbGwgYmUgcmV0cmllZCB1cCB0byA2IHRpbWVzLCB3aXRoIGFuXG4gKiBleHBvbmVudGlhbCBiYWNrb2ZmIGJldHdlZW4gZWFjaCBhdHRlbXB0LlxuICovXG5leHBvcnQgY2xhc3MgQXN5bmNDYWxsZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhDb25jdXJyZW5jeVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhSZXRyaWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uRmFpbGVkQXR0ZW1wdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJxdWV1ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1heENvbmN1cnJlbmN5ID0gcGFyYW1zLm1heENvbmN1cnJlbmN5ID8/IEluZmluaXR5O1xuICAgICAgICB0aGlzLm1heFJldHJpZXMgPSBwYXJhbXMubWF4UmV0cmllcyA/PyA2O1xuICAgICAgICB0aGlzLm9uRmFpbGVkQXR0ZW1wdCA9XG4gICAgICAgICAgICBwYXJhbXMub25GYWlsZWRBdHRlbXB0ID8/IGRlZmF1bHRGYWlsZWRBdHRlbXB0SGFuZGxlcjtcbiAgICAgICAgY29uc3QgUFF1ZXVlID0gXCJkZWZhdWx0XCIgaW4gUFF1ZXVlTW9kID8gUFF1ZXVlTW9kLmRlZmF1bHQgOiBQUXVldWVNb2Q7XG4gICAgICAgIHRoaXMucXVldWUgPSBuZXcgUFF1ZXVlKHsgY29uY3VycmVuY3k6IHRoaXMubWF4Q29uY3VycmVuY3kgfSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY2FsbChjYWxsYWJsZSwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZS5hZGQoKCkgPT4gcFJldHJ5KCgpID0+IGNhbGxhYmxlKC4uLmFyZ3MpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgICBvbkZhaWxlZEF0dGVtcHQ6IHRoaXMub25GYWlsZWRBdHRlbXB0LFxuICAgICAgICAgICAgcmV0cmllczogdGhpcy5tYXhSZXRyaWVzLFxuICAgICAgICAgICAgcmFuZG9taXplOiB0cnVlLFxuICAgICAgICAgICAgLy8gSWYgbmVlZGVkIHdlIGNhbiBjaGFuZ2Ugc29tZSBvZiB0aGUgZGVmYXVsdHMgaGVyZSxcbiAgICAgICAgICAgIC8vIGJ1dCB0aGV5J3JlIHF1aXRlIHNlbnNpYmxlLlxuICAgICAgICB9KSwgeyB0aHJvd09uVGltZW91dDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjYWxsV2l0aE9wdGlvbnMob3B0aW9ucywgY2FsbGFibGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gTm90ZSB0aGlzIGRvZXNuJ3QgY2FuY2VsIHRoZSB1bmRlcmx5aW5nIHJlcXVlc3QsXG4gICAgICAgIC8vIHdoZW4gYXZhaWxhYmxlIHByZWZlciB0byB1c2UgdGhlIHNpZ25hbCBvcHRpb24gb2YgdGhlIHVuZGVybHlpbmcgY2FsbFxuICAgICAgICBpZiAob3B0aW9ucy5zaWduYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbChjYWxsYWJsZSwgLi4uYXJncyksXG4gICAgICAgICAgICAgICAgbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNpZ25hbD8uYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJBYm9ydEVycm9yXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jYWxsKGNhbGxhYmxlLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgZmV0Y2goLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsKCgpID0+IGZldGNoKC4uLmFyZ3MpLnRoZW4oKHJlcykgPT4gKHJlcy5vayA/IHJlcyA6IFByb21pc2UucmVqZWN0KHJlcykpKSk7XG4gICAgfVxufVxuIiwgImltcG9ydCBiYXNlNjQgZnJvbSAnYmFzZTY0LWpzJztcblxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vLyBzcmMvdXRpbHMudHNcbmZ1bmN0aW9uIG5ldmVyKF8pIHtcbn1cbmZ1bmN0aW9uIGJ5dGVQYWlyTWVyZ2UocGllY2UsIHJhbmtzKSB7XG4gIGxldCBwYXJ0cyA9IEFycmF5LmZyb20oXG4gICAgeyBsZW5ndGg6IHBpZWNlLmxlbmd0aCB9LFxuICAgIChfLCBpKSA9PiAoeyBzdGFydDogaSwgZW5kOiBpICsgMSB9KVxuICApO1xuICB3aGlsZSAocGFydHMubGVuZ3RoID4gMSkge1xuICAgIGxldCBtaW5SYW5rID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgY29uc3Qgc2xpY2UgPSBwaWVjZS5zbGljZShwYXJ0c1tpXS5zdGFydCwgcGFydHNbaSArIDFdLmVuZCk7XG4gICAgICBjb25zdCByYW5rID0gcmFua3MuZ2V0KHNsaWNlLmpvaW4oXCIsXCIpKTtcbiAgICAgIGlmIChyYW5rID09IG51bGwpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKG1pblJhbmsgPT0gbnVsbCB8fCByYW5rIDwgbWluUmFua1swXSkge1xuICAgICAgICBtaW5SYW5rID0gW3JhbmssIGldO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWluUmFuayAhPSBudWxsKSB7XG4gICAgICBjb25zdCBpID0gbWluUmFua1sxXTtcbiAgICAgIHBhcnRzW2ldID0geyBzdGFydDogcGFydHNbaV0uc3RhcnQsIGVuZDogcGFydHNbaSArIDFdLmVuZCB9O1xuICAgICAgcGFydHMuc3BsaWNlKGkgKyAxLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJ0cztcbn1cbmZ1bmN0aW9uIGJ5dGVQYWlyRW5jb2RlKHBpZWNlLCByYW5rcykge1xuICBpZiAocGllY2UubGVuZ3RoID09PSAxKVxuICAgIHJldHVybiBbcmFua3MuZ2V0KHBpZWNlLmpvaW4oXCIsXCIpKV07XG4gIHJldHVybiBieXRlUGFpck1lcmdlKHBpZWNlLCByYW5rcykubWFwKChwKSA9PiByYW5rcy5nZXQocGllY2Uuc2xpY2UocC5zdGFydCwgcC5lbmQpLmpvaW4oXCIsXCIpKSkuZmlsdGVyKCh4KSA9PiB4ICE9IG51bGwpO1xufVxuZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvW1xcXFxeJCorPy4oKXxbXFxde31dL2csIFwiXFxcXCQmXCIpO1xufVxudmFyIF9UaWt0b2tlbiA9IGNsYXNzIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzcGVjaWFsVG9rZW5zO1xuICAvKiogQGludGVybmFsICovXG4gIGludmVyc2VTcGVjaWFsVG9rZW5zO1xuICAvKiogQGludGVybmFsICovXG4gIHBhdFN0cjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAvKiogQGludGVybmFsICovXG4gIHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIik7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcmFua01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgdGV4dE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0cnVjdG9yKHJhbmtzLCBleHRlbmRlZFNwZWNpYWxUb2tlbnMpIHtcbiAgICB0aGlzLnBhdFN0ciA9IHJhbmtzLnBhdF9zdHI7XG4gICAgY29uc3QgdW5jb21wcmVzc2VkID0gcmFua3MuYnBlX3JhbmtzLnNwbGl0KFwiXFxuXCIpLmZpbHRlcihCb29sZWFuKS5yZWR1Y2UoKG1lbW8sIHgpID0+IHtcbiAgICAgIGNvbnN0IFtfLCBvZmZzZXRTdHIsIC4uLnRva2Vuc10gPSB4LnNwbGl0KFwiIFwiKTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IE51bWJlci5wYXJzZUludChvZmZzZXRTdHIsIDEwKTtcbiAgICAgIHRva2Vucy5mb3JFYWNoKCh0b2tlbiwgaSkgPT4gbWVtb1t0b2tlbl0gPSBvZmZzZXQgKyBpKTtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIHt9KTtcbiAgICBmb3IgKGNvbnN0IFt0b2tlbiwgcmFua10gb2YgT2JqZWN0LmVudHJpZXModW5jb21wcmVzc2VkKSkge1xuICAgICAgY29uc3QgYnl0ZXMgPSBiYXNlNjQudG9CeXRlQXJyYXkodG9rZW4pO1xuICAgICAgdGhpcy5yYW5rTWFwLnNldChieXRlcy5qb2luKFwiLFwiKSwgcmFuayk7XG4gICAgICB0aGlzLnRleHRNYXAuc2V0KHJhbmssIGJ5dGVzKTtcbiAgICB9XG4gICAgdGhpcy5zcGVjaWFsVG9rZW5zID0geyAuLi5yYW5rcy5zcGVjaWFsX3Rva2VucywgLi4uZXh0ZW5kZWRTcGVjaWFsVG9rZW5zIH07XG4gICAgdGhpcy5pbnZlcnNlU3BlY2lhbFRva2VucyA9IE9iamVjdC5lbnRyaWVzKHRoaXMuc3BlY2lhbFRva2VucykucmVkdWNlKChtZW1vLCBbdGV4dCwgcmFua10pID0+IHtcbiAgICAgIG1lbW9bcmFua10gPSB0aGlzLnRleHRFbmNvZGVyLmVuY29kZSh0ZXh0KTtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIHt9KTtcbiAgfVxuICBlbmNvZGUodGV4dCwgYWxsb3dlZFNwZWNpYWwgPSBbXSwgZGlzYWxsb3dlZFNwZWNpYWwgPSBcImFsbFwiKSB7XG4gICAgY29uc3QgcmVnZXhlcyA9IG5ldyBSZWdFeHAodGhpcy5wYXRTdHIsIFwidWdcIik7XG4gICAgY29uc3Qgc3BlY2lhbFJlZ2V4ID0gX1Rpa3Rva2VuLnNwZWNpYWxUb2tlblJlZ2V4KFxuICAgICAgT2JqZWN0LmtleXModGhpcy5zcGVjaWFsVG9rZW5zKVxuICAgICk7XG4gICAgY29uc3QgcmV0ID0gW107XG4gICAgY29uc3QgYWxsb3dlZFNwZWNpYWxTZXQgPSBuZXcgU2V0KFxuICAgICAgYWxsb3dlZFNwZWNpYWwgPT09IFwiYWxsXCIgPyBPYmplY3Qua2V5cyh0aGlzLnNwZWNpYWxUb2tlbnMpIDogYWxsb3dlZFNwZWNpYWxcbiAgICApO1xuICAgIGNvbnN0IGRpc2FsbG93ZWRTcGVjaWFsU2V0ID0gbmV3IFNldChcbiAgICAgIGRpc2FsbG93ZWRTcGVjaWFsID09PSBcImFsbFwiID8gT2JqZWN0LmtleXModGhpcy5zcGVjaWFsVG9rZW5zKS5maWx0ZXIoXG4gICAgICAgICh4KSA9PiAhYWxsb3dlZFNwZWNpYWxTZXQuaGFzKHgpXG4gICAgICApIDogZGlzYWxsb3dlZFNwZWNpYWxcbiAgICApO1xuICAgIGlmIChkaXNhbGxvd2VkU3BlY2lhbFNldC5zaXplID4gMCkge1xuICAgICAgY29uc3QgZGlzYWxsb3dlZFNwZWNpYWxSZWdleCA9IF9UaWt0b2tlbi5zcGVjaWFsVG9rZW5SZWdleChbXG4gICAgICAgIC4uLmRpc2FsbG93ZWRTcGVjaWFsU2V0XG4gICAgICBdKTtcbiAgICAgIGNvbnN0IHNwZWNpYWxNYXRjaCA9IHRleHQubWF0Y2goZGlzYWxsb3dlZFNwZWNpYWxSZWdleCk7XG4gICAgICBpZiAoc3BlY2lhbE1hdGNoICE9IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBUaGUgdGV4dCBjb250YWlucyBhIHNwZWNpYWwgdG9rZW4gdGhhdCBpcyBub3QgYWxsb3dlZDogJHtzcGVjaWFsTWF0Y2hbMF19YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgbmV4dFNwZWNpYWwgPSBudWxsO1xuICAgICAgbGV0IHN0YXJ0RmluZCA9IHN0YXJ0O1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgc3BlY2lhbFJlZ2V4Lmxhc3RJbmRleCA9IHN0YXJ0RmluZDtcbiAgICAgICAgbmV4dFNwZWNpYWwgPSBzcGVjaWFsUmVnZXguZXhlYyh0ZXh0KTtcbiAgICAgICAgaWYgKG5leHRTcGVjaWFsID09IG51bGwgfHwgYWxsb3dlZFNwZWNpYWxTZXQuaGFzKG5leHRTcGVjaWFsWzBdKSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgc3RhcnRGaW5kID0gbmV4dFNwZWNpYWwuaW5kZXggKyAxO1xuICAgICAgfVxuICAgICAgY29uc3QgZW5kID0gbmV4dFNwZWNpYWw/LmluZGV4ID8/IHRleHQubGVuZ3RoO1xuICAgICAgZm9yIChjb25zdCBtYXRjaCBvZiB0ZXh0LnN1YnN0cmluZyhzdGFydCwgZW5kKS5tYXRjaEFsbChyZWdleGVzKSkge1xuICAgICAgICBjb25zdCBwaWVjZSA9IHRoaXMudGV4dEVuY29kZXIuZW5jb2RlKG1hdGNoWzBdKTtcbiAgICAgICAgY29uc3QgdG9rZW4yID0gdGhpcy5yYW5rTWFwLmdldChwaWVjZS5qb2luKFwiLFwiKSk7XG4gICAgICAgIGlmICh0b2tlbjIgIT0gbnVsbCkge1xuICAgICAgICAgIHJldC5wdXNoKHRva2VuMik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0LnB1c2goLi4uYnl0ZVBhaXJFbmNvZGUocGllY2UsIHRoaXMucmFua01hcCkpO1xuICAgICAgfVxuICAgICAgaWYgKG5leHRTcGVjaWFsID09IG51bGwpXG4gICAgICAgIGJyZWFrO1xuICAgICAgbGV0IHRva2VuID0gdGhpcy5zcGVjaWFsVG9rZW5zW25leHRTcGVjaWFsWzBdXTtcbiAgICAgIHJldC5wdXNoKHRva2VuKTtcbiAgICAgIHN0YXJ0ID0gbmV4dFNwZWNpYWwuaW5kZXggKyBuZXh0U3BlY2lhbFswXS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZGVjb2RlKHRva2Vucykge1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCB0b2tlbnMubGVuZ3RoOyArK2kyKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpMl07XG4gICAgICBjb25zdCBieXRlcyA9IHRoaXMudGV4dE1hcC5nZXQodG9rZW4pID8/IHRoaXMuaW52ZXJzZVNwZWNpYWxUb2tlbnNbdG9rZW5dO1xuICAgICAgaWYgKGJ5dGVzICE9IG51bGwpIHtcbiAgICAgICAgcmVzLnB1c2goYnl0ZXMpO1xuICAgICAgICBsZW5ndGggKz0gYnl0ZXMubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXJnZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3QgYnl0ZXMgb2YgcmVzKSB7XG4gICAgICBtZXJnZWRBcnJheS5zZXQoYnl0ZXMsIGkpO1xuICAgICAgaSArPSBieXRlcy5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRleHREZWNvZGVyLmRlY29kZShtZXJnZWRBcnJheSk7XG4gIH1cbn07XG52YXIgVGlrdG9rZW4gPSBfVGlrdG9rZW47XG5fX3B1YmxpY0ZpZWxkKFRpa3Rva2VuLCBcInNwZWNpYWxUb2tlblJlZ2V4XCIsICh0b2tlbnMpID0+IHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAodG9rZW5zLm1hcCgoaSkgPT4gZXNjYXBlUmVnZXgoaSkpLmpvaW4oXCJ8XCIpLCBcImdcIik7XG59KTtcbmZ1bmN0aW9uIGdldEVuY29kaW5nTmFtZUZvck1vZGVsKG1vZGVsKSB7XG4gIHN3aXRjaCAobW9kZWwpIHtcbiAgICBjYXNlIFwiZ3B0MlwiOiB7XG4gICAgICByZXR1cm4gXCJncHQyXCI7XG4gICAgfVxuICAgIGNhc2UgXCJjb2RlLWN1c2htYW4tMDAxXCI6XG4gICAgY2FzZSBcImNvZGUtY3VzaG1hbi0wMDJcIjpcbiAgICBjYXNlIFwiY29kZS1kYXZpbmNpLTAwMVwiOlxuICAgIGNhc2UgXCJjb2RlLWRhdmluY2ktMDAyXCI6XG4gICAgY2FzZSBcImN1c2htYW4tY29kZXhcIjpcbiAgICBjYXNlIFwiZGF2aW5jaS1jb2RleFwiOlxuICAgIGNhc2UgXCJkYXZpbmNpLTAwMlwiOlxuICAgIGNhc2UgXCJ0ZXh0LWRhdmluY2ktMDAyXCI6XG4gICAgY2FzZSBcInRleHQtZGF2aW5jaS0wMDNcIjoge1xuICAgICAgcmV0dXJuIFwicDUwa19iYXNlXCI7XG4gICAgfVxuICAgIGNhc2UgXCJjb2RlLWRhdmluY2ktZWRpdC0wMDFcIjpcbiAgICBjYXNlIFwidGV4dC1kYXZpbmNpLWVkaXQtMDAxXCI6IHtcbiAgICAgIHJldHVybiBcInA1MGtfZWRpdFwiO1xuICAgIH1cbiAgICBjYXNlIFwiYWRhXCI6XG4gICAgY2FzZSBcImJhYmJhZ2VcIjpcbiAgICBjYXNlIFwiYmFiYmFnZS0wMDJcIjpcbiAgICBjYXNlIFwiY29kZS1zZWFyY2gtYWRhLWNvZGUtMDAxXCI6XG4gICAgY2FzZSBcImNvZGUtc2VhcmNoLWJhYmJhZ2UtY29kZS0wMDFcIjpcbiAgICBjYXNlIFwiY3VyaWVcIjpcbiAgICBjYXNlIFwiZGF2aW5jaVwiOlxuICAgIGNhc2UgXCJ0ZXh0LWFkYS0wMDFcIjpcbiAgICBjYXNlIFwidGV4dC1iYWJiYWdlLTAwMVwiOlxuICAgIGNhc2UgXCJ0ZXh0LWN1cmllLTAwMVwiOlxuICAgIGNhc2UgXCJ0ZXh0LWRhdmluY2ktMDAxXCI6XG4gICAgY2FzZSBcInRleHQtc2VhcmNoLWFkYS1kb2MtMDAxXCI6XG4gICAgY2FzZSBcInRleHQtc2VhcmNoLWJhYmJhZ2UtZG9jLTAwMVwiOlxuICAgIGNhc2UgXCJ0ZXh0LXNlYXJjaC1jdXJpZS1kb2MtMDAxXCI6XG4gICAgY2FzZSBcInRleHQtc2VhcmNoLWRhdmluY2ktZG9jLTAwMVwiOlxuICAgIGNhc2UgXCJ0ZXh0LXNpbWlsYXJpdHktYWRhLTAwMVwiOlxuICAgIGNhc2UgXCJ0ZXh0LXNpbWlsYXJpdHktYmFiYmFnZS0wMDFcIjpcbiAgICBjYXNlIFwidGV4dC1zaW1pbGFyaXR5LWN1cmllLTAwMVwiOlxuICAgIGNhc2UgXCJ0ZXh0LXNpbWlsYXJpdHktZGF2aW5jaS0wMDFcIjoge1xuICAgICAgcmV0dXJuIFwicjUwa19iYXNlXCI7XG4gICAgfVxuICAgIGNhc2UgXCJncHQtMy41LXR1cmJvLWluc3RydWN0LTA5MTRcIjpcbiAgICBjYXNlIFwiZ3B0LTMuNS10dXJiby1pbnN0cnVjdFwiOlxuICAgIGNhc2UgXCJncHQtMy41LXR1cmJvLTE2ay0wNjEzXCI6XG4gICAgY2FzZSBcImdwdC0zLjUtdHVyYm8tMTZrXCI6XG4gICAgY2FzZSBcImdwdC0zLjUtdHVyYm8tMDYxM1wiOlxuICAgIGNhc2UgXCJncHQtMy41LXR1cmJvLTAzMDFcIjpcbiAgICBjYXNlIFwiZ3B0LTMuNS10dXJib1wiOlxuICAgIGNhc2UgXCJncHQtNC0zMmstMDYxM1wiOlxuICAgIGNhc2UgXCJncHQtNC0zMmstMDMxNFwiOlxuICAgIGNhc2UgXCJncHQtNC0zMmtcIjpcbiAgICBjYXNlIFwiZ3B0LTQtMDYxM1wiOlxuICAgIGNhc2UgXCJncHQtNC0wMzE0XCI6XG4gICAgY2FzZSBcImdwdC00XCI6XG4gICAgY2FzZSBcImdwdC0zLjUtdHVyYm8tMTEwNlwiOlxuICAgIGNhc2UgXCJncHQtMzUtdHVyYm9cIjpcbiAgICBjYXNlIFwiZ3B0LTQtMTEwNi1wcmV2aWV3XCI6XG4gICAgY2FzZSBcImdwdC00LXZpc2lvbi1wcmV2aWV3XCI6XG4gICAgY2FzZSBcImdwdC0zLjUtdHVyYm8tMDEyNVwiOlxuICAgIGNhc2UgXCJncHQtNC10dXJiby1wcmV2aWV3XCI6XG4gICAgY2FzZSBcImdwdC00LTAxMjUtcHJldmlld1wiOlxuICAgIGNhc2UgXCJ0ZXh0LWVtYmVkZGluZy1hZGEtMDAyXCI6IHtcbiAgICAgIHJldHVybiBcImNsMTAwa19iYXNlXCI7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG1vZGVsXCIpO1xuICB9XG59XG5cbmV4cG9ydCB7IFRpa3Rva2VuLCBnZXRFbmNvZGluZ05hbWVGb3JNb2RlbCwgbmV2ZXIgfTtcbiIsICJpbXBvcnQgeyBUaWt0b2tlbiwgZ2V0RW5jb2RpbmdOYW1lRm9yTW9kZWwsIH0gZnJvbSBcImpzLXRpa3Rva2VuL2xpdGVcIjtcbmltcG9ydCB7IEFzeW5jQ2FsbGVyIH0gZnJvbSBcIi4vYXN5bmNfY2FsbGVyLmpzXCI7XG5jb25zdCBjYWNoZSA9IHt9O1xuY29uc3QgY2FsbGVyID0gLyogI19fUFVSRV9fICovIG5ldyBBc3luY0NhbGxlcih7fSk7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgICBpZiAoIShlbmNvZGluZyBpbiBjYWNoZSkpIHtcbiAgICAgICAgY2FjaGVbZW5jb2RpbmddID0gY2FsbGVyXG4gICAgICAgICAgICAuZmV0Y2goYGh0dHBzOi8vdGlrdG9rZW4ucGFnZXMuZGV2L2pzLyR7ZW5jb2Rpbmd9Lmpzb25gKVxuICAgICAgICAgICAgLnRoZW4oKHJlcykgPT4gcmVzLmpzb24oKSlcbiAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiBuZXcgVGlrdG9rZW4oZGF0YSkpXG4gICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVtlbmNvZGluZ107XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IGNhY2hlW2VuY29kaW5nXTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbmNvZGluZ0Zvck1vZGVsKG1vZGVsKSB7XG4gICAgcmV0dXJuIGdldEVuY29kaW5nKGdldEVuY29kaW5nTmFtZUZvck1vZGVsKG1vZGVsKSk7XG59XG4iLCAiaW1wb3J0IHBSZXRyeSBmcm9tIFwicC1yZXRyeVwiO1xuaW1wb3J0IHsgQ2FsbGJhY2tNYW5hZ2VyLCB9IGZyb20gXCIuLi9jYWxsYmFja3MvbWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgTG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyLCBSdW5Mb2csIFJ1bkxvZ1BhdGNoLCB9IGZyb20gXCIuLi90cmFjZXJzL2xvZ19zdHJlYW0uanNcIjtcbmltcG9ydCB7IFNlcmlhbGl6YWJsZSB9IGZyb20gXCIuLi9sb2FkL3NlcmlhbGl6YWJsZS5qc1wiO1xuaW1wb3J0IHsgSXRlcmFibGVSZWFkYWJsZVN0cmVhbSwgY29uY2F0LCBhdGVlLCBwaXBlR2VuZXJhdG9yV2l0aFNldHVwLCBBc3luY0dlbmVyYXRvcldpdGhTZXR1cCwgfSBmcm9tIFwiLi4vdXRpbHMvc3RyZWFtLmpzXCI7XG5pbXBvcnQgeyBERUZBVUxUX1JFQ1VSU0lPTl9MSU1JVCwgZW5zdXJlQ29uZmlnLCBnZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcsIG1lcmdlQ29uZmlncywgcGF0Y2hDb25maWcsIH0gZnJvbSBcIi4vY29uZmlnLmpzXCI7XG5pbXBvcnQgeyBBc3luY0NhbGxlciB9IGZyb20gXCIuLi91dGlscy9hc3luY19jYWxsZXIuanNcIjtcbmltcG9ydCB7IFJvb3RMaXN0ZW5lcnNUcmFjZXIgfSBmcm9tIFwiLi4vdHJhY2Vycy9yb290X2xpc3RlbmVyLmpzXCI7XG5pbXBvcnQgeyBfUm9vdEV2ZW50RmlsdGVyIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24gfSBmcm9tIFwiLi4vc2luZ2xldG9ucy9pbmRleC5qc1wiO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmV4cG9ydCBmdW5jdGlvbiBfY29lcmNlVG9EaWN0KHZhbHVlLCBkZWZhdWx0S2V5KSB7XG4gICAgcmV0dXJuIHZhbHVlICYmXG4gICAgICAgICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCJcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IHsgW2RlZmF1bHRLZXldOiB2YWx1ZSB9O1xufVxuLyoqXG4gKiBBIFJ1bm5hYmxlIGlzIGEgZ2VuZXJpYyB1bml0IG9mIHdvcmsgdGhhdCBjYW4gYmUgaW52b2tlZCwgYmF0Y2hlZCwgc3RyZWFtZWQsIGFuZC9vclxuICogdHJhbnNmb3JtZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW5uYWJsZSBleHRlbmRzIFNlcmlhbGl6YWJsZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3J1bm5hYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldE5hbWUoc3VmZml4KSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgdGhpcy5uYW1lID8/IHRoaXMuY29uc3RydWN0b3IubGNfbmFtZSgpID8/IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgcmV0dXJuIHN1ZmZpeCA/IGAke25hbWV9JHtzdWZmaXh9YCA6IG5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmQgYXJndW1lbnRzIHRvIGEgUnVubmFibGUsIHJldHVybmluZyBhIG5ldyBSdW5uYWJsZS5cbiAgICAgKiBAcGFyYW0ga3dhcmdzXG4gICAgICogQHJldHVybnMgQSBuZXcgUnVubmFibGVCaW5kaW5nIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBhcHBseSB0aGUgYm91bmQgYXJncy5cbiAgICAgKi9cbiAgICBiaW5kKGt3YXJncykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVCaW5kaW5nKHsgYm91bmQ6IHRoaXMsIGt3YXJncywgY29uZmlnOiB7fSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbmV3IFJ1bm5hYmxlIHRoYXQgbWFwcyBhIGxpc3Qgb2YgaW5wdXRzIHRvIGEgbGlzdCBvZiBvdXRwdXRzLFxuICAgICAqIGJ5IGNhbGxpbmcgaW52b2tlKCkgd2l0aCBlYWNoIGlucHV0LlxuICAgICAqL1xuICAgIG1hcCgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlRWFjaCh7IGJvdW5kOiB0aGlzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgcmV0cnkgbG9naWMgdG8gYW4gZXhpc3RpbmcgcnVubmFibGUuXG4gICAgICogQHBhcmFtIGt3YXJnc1xuICAgICAqIEByZXR1cm5zIEEgbmV3IFJ1bm5hYmxlUmV0cnkgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIHJldHJ5IGFjY29yZGluZyB0byB0aGUgcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICB3aXRoUmV0cnkoZmllbGRzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZVJldHJ5KHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLFxuICAgICAgICAgICAga3dhcmdzOiB7fSxcbiAgICAgICAgICAgIGNvbmZpZzoge30sXG4gICAgICAgICAgICBtYXhBdHRlbXB0TnVtYmVyOiBmaWVsZHM/LnN0b3BBZnRlckF0dGVtcHQsXG4gICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kIGNvbmZpZyB0byBhIFJ1bm5hYmxlLCByZXR1cm5pbmcgYSBuZXcgUnVubmFibGUuXG4gICAgICogQHBhcmFtIGNvbmZpZyBOZXcgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzIHRvIGF0dGFjaCB0byB0aGUgbmV3IHJ1bm5hYmxlLlxuICAgICAqIEByZXR1cm5zIEEgbmV3IFJ1bm5hYmxlQmluZGluZyB3aXRoIGEgY29uZmlnIG1hdGNoaW5nIHdoYXQncyBwYXNzZWQuXG4gICAgICovXG4gICAgd2l0aENvbmZpZyhjb25maWcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlQmluZGluZyh7XG4gICAgICAgICAgICBib3VuZDogdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGt3YXJnczoge30sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgcnVubmFibGUgZnJvbSB0aGUgY3VycmVudCBvbmUgdGhhdCB3aWxsIHRyeSBpbnZva2luZ1xuICAgICAqIG90aGVyIHBhc3NlZCBmYWxsYmFjayBydW5uYWJsZXMgaWYgdGhlIGluaXRpYWwgaW52b2NhdGlvbiBmYWlscy5cbiAgICAgKiBAcGFyYW0gZmllbGRzLmZhbGxiYWNrcyBPdGhlciBydW5uYWJsZXMgdG8gY2FsbCBpZiB0aGUgcnVubmFibGUgZXJyb3JzLlxuICAgICAqIEByZXR1cm5zIEEgbmV3IFJ1bm5hYmxlV2l0aEZhbGxiYWNrcy5cbiAgICAgKi9cbiAgICB3aXRoRmFsbGJhY2tzKGZpZWxkcykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVXaXRoRmFsbGJhY2tzKHtcbiAgICAgICAgICAgIHJ1bm5hYmxlOiB0aGlzLFxuICAgICAgICAgICAgZmFsbGJhY2tzOiBmaWVsZHMuZmFsbGJhY2tzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldE9wdGlvbnNMaXN0KG9wdGlvbnMsIGxlbmd0aCA9IDApIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXNzZWQgXCJvcHRpb25zXCIgbXVzdCBiZSBhbiBhcnJheSB3aXRoIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGUgaW5wdXRzLCBidXQgZ290ICR7b3B0aW9ucy5sZW5ndGh9IG9wdGlvbnMgZm9yICR7bGVuZ3RofSBpbnB1dHNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLm1hcChlbnN1cmVDb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoIH0sICgpID0+IGVuc3VyZUNvbmZpZyhvcHRpb25zKSk7XG4gICAgfVxuICAgIGFzeW5jIGJhdGNoKGlucHV0cywgb3B0aW9ucywgYmF0Y2hPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZ0xpc3QgPSB0aGlzLl9nZXRPcHRpb25zTGlzdChvcHRpb25zID8/IHt9LCBpbnB1dHMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbWF4Q29uY3VycmVuY3kgPSBjb25maWdMaXN0WzBdPy5tYXhDb25jdXJyZW5jeSA/PyBiYXRjaE9wdGlvbnM/Lm1heENvbmN1cnJlbmN5O1xuICAgICAgICBjb25zdCBjYWxsZXIgPSBuZXcgQXN5bmNDYWxsZXIoe1xuICAgICAgICAgICAgbWF4Q29uY3VycmVuY3ksXG4gICAgICAgICAgICBvbkZhaWxlZEF0dGVtcHQ6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBiYXRjaENhbGxzID0gaW5wdXRzLm1hcCgoaW5wdXQsIGkpID0+IGNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5pbnZva2UoaW5wdXQsIGNvbmZpZ0xpc3RbaV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChiYXRjaE9wdGlvbnM/LnJldHVybkV4Y2VwdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGJhdGNoQ2FsbHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHN0cmVhbWluZyBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB0aGV5IHN1cHBvcnQgc3RyZWFtaW5nIG91dHB1dC5cbiAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIGFzeW5jICpfc3RyZWFtSXRlcmF0b3IoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgeWllbGQgdGhpcy5pbnZva2UoaW5wdXQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJlYW0gb3V0cHV0IGluIGNodW5rcy5cbiAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIEEgcmVhZGFibGUgc3RyZWFtIHRoYXQgaXMgYWxzbyBhbiBpdGVyYWJsZS5cbiAgICAgKi9cbiAgICBhc3luYyBzdHJlYW0oaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gQnVmZmVyIHRoZSBmaXJzdCBzdHJlYW1lZCBjaHVuayB0byBhbGxvdyBmb3IgaW5pdGlhbCBlcnJvcnNcbiAgICAgICAgLy8gdG8gc3VyZmFjZSBpbW1lZGlhdGVseS5cbiAgICAgICAgY29uc3Qgd3JhcHBlZEdlbmVyYXRvciA9IG5ldyBBc3luY0dlbmVyYXRvcldpdGhTZXR1cCh0aGlzLl9zdHJlYW1JdGVyYXRvcihpbnB1dCwgZW5zdXJlQ29uZmlnKG9wdGlvbnMpKSk7XG4gICAgICAgIGF3YWl0IHdyYXBwZWRHZW5lcmF0b3Iuc2V0dXA7XG4gICAgICAgIHJldHVybiBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21Bc3luY0dlbmVyYXRvcih3cmFwcGVkR2VuZXJhdG9yKTtcbiAgICB9XG4gICAgX3NlcGFyYXRlUnVubmFibGVDb25maWdGcm9tQ2FsbE9wdGlvbnMob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHJ1bm5hYmxlQ29uZmlnID0gZW5zdXJlQ29uZmlnKHtcbiAgICAgICAgICAgIGNhbGxiYWNrczogb3B0aW9ucy5jYWxsYmFja3MsXG4gICAgICAgICAgICB0YWdzOiBvcHRpb25zLnRhZ3MsXG4gICAgICAgICAgICBtZXRhZGF0YTogb3B0aW9ucy5tZXRhZGF0YSxcbiAgICAgICAgICAgIHJ1bk5hbWU6IG9wdGlvbnMucnVuTmFtZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogb3B0aW9ucy5jb25maWd1cmFibGUsXG4gICAgICAgICAgICByZWN1cnNpb25MaW1pdDogb3B0aW9ucy5yZWN1cnNpb25MaW1pdCxcbiAgICAgICAgICAgIG1heENvbmN1cnJlbmN5OiBvcHRpb25zLm1heENvbmN1cnJlbmN5LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2FsbE9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICAgICAgZGVsZXRlIGNhbGxPcHRpb25zLmNhbGxiYWNrcztcbiAgICAgICAgZGVsZXRlIGNhbGxPcHRpb25zLnRhZ3M7XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy5tZXRhZGF0YTtcbiAgICAgICAgZGVsZXRlIGNhbGxPcHRpb25zLnJ1bk5hbWU7XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy5jb25maWd1cmFibGU7XG4gICAgICAgIGRlbGV0ZSBjYWxsT3B0aW9ucy5yZWN1cnNpb25MaW1pdDtcbiAgICAgICAgZGVsZXRlIGNhbGxPcHRpb25zLm1heENvbmN1cnJlbmN5O1xuICAgICAgICByZXR1cm4gW3J1bm5hYmxlQ29uZmlnLCBjYWxsT3B0aW9uc107XG4gICAgfVxuICAgIGFzeW5jIF9jYWxsV2l0aENvbmZpZyhmdW5jLCBpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb25maWcgPSBlbnN1cmVDb25maWcob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCBnZXRDYWxsYmFja01hbmFnZXJGb3JDb25maWcoY29uZmlnKTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlciA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgX2NvZXJjZVRvRGljdChpbnB1dCwgXCJpbnB1dFwiKSwgdW5kZWZpbmVkLCBjb25maWc/LnJ1blR5cGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb25maWc/LnJ1bk5hbWUgPz8gdGhpcy5nZXROYW1lKCkpO1xuICAgICAgICBsZXQgb3V0cHV0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgb3V0cHV0ID0gYXdhaXQgZnVuYy5jYWxsKHRoaXMsIGlucHV0LCBjb25maWcsIHJ1bk1hbmFnZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChfY29lcmNlVG9EaWN0KG91dHB1dCwgXCJvdXRwdXRcIikpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgdGhhdCBoYW5kbGVzIGJhdGNoaW5nIGFuZCBjb25maWd1cmF0aW9uIGZvciBhIHJ1bm5hYmxlXG4gICAgICogSXQgdGFrZXMgYSBmdW5jdGlvbiwgaW5wdXQgdmFsdWVzLCBhbmQgb3B0aW9uYWwgY29uZmlndXJhdGlvbiwgYW5kXG4gICAgICogcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgb3V0cHV0IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgZm9yIGVhY2ggaW5wdXQgdmFsdWUuXG4gICAgICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCB2YWx1ZXMgdG8gYmUgcHJvY2Vzc2VkLlxuICAgICAqIEBwYXJhbSBjb25maWcgT3B0aW9uYWwgY29uZmlndXJhdGlvbiBmb3IgdGhlIGZ1bmN0aW9uIGV4ZWN1dGlvbi5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgb3V0cHV0IHZhbHVlcy5cbiAgICAgKi9cbiAgICBhc3luYyBfYmF0Y2hXaXRoQ29uZmlnKGZ1bmMsIGlucHV0cywgb3B0aW9ucywgYmF0Y2hPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnNMaXN0ID0gdGhpcy5fZ2V0T3B0aW9uc0xpc3Qob3B0aW9ucyA/PyB7fSwgaW5wdXRzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcnMgPSBhd2FpdCBQcm9taXNlLmFsbChvcHRpb25zTGlzdC5tYXAoZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKSk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoY2FsbGJhY2tNYW5hZ2Vycy5tYXAoKGNhbGxiYWNrTWFuYWdlciwgaSkgPT4gY2FsbGJhY2tNYW5hZ2VyPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIF9jb2VyY2VUb0RpY3QoaW5wdXRzW2ldLCBcImlucHV0XCIpLCB1bmRlZmluZWQsIG9wdGlvbnNMaXN0W2ldLnJ1blR5cGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvcHRpb25zTGlzdFtpXS5ydW5OYW1lID8/IHRoaXMuZ2V0TmFtZSgpKSkpO1xuICAgICAgICBsZXQgb3V0cHV0cztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG91dHB1dHMgPSBhd2FpdCBmdW5jLmNhbGwodGhpcywgaW5wdXRzLCBvcHRpb25zTGlzdCwgcnVuTWFuYWdlcnMsIGJhdGNoT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJ1bk1hbmFnZXJzLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihlKSkpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChydW5NYW5hZ2Vycy5tYXAoKHJ1bk1hbmFnZXIpID0+IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKF9jb2VyY2VUb0RpY3Qob3V0cHV0cywgXCJvdXRwdXRcIikpKSk7XG4gICAgICAgIHJldHVybiBvdXRwdXRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIHRyYW5zZm9ybSBhbiBJdGVyYXRvciBvZiBJbnB1dCB2YWx1ZXMgaW50byBhbiBJdGVyYXRvciBvZlxuICAgICAqIE91dHB1dCB2YWx1ZXMsIHdpdGggY2FsbGJhY2tzLlxuICAgICAqIFVzZSB0aGlzIHRvIGltcGxlbWVudCBgc3RyZWFtKClgIG9yIGB0cmFuc2Zvcm0oKWAgaW4gUnVubmFibGUgc3ViY2xhc3Nlcy5cbiAgICAgKi9cbiAgICBhc3luYyAqX3RyYW5zZm9ybVN0cmVhbVdpdGhDb25maWcoaW5wdXRHZW5lcmF0b3IsIHRyYW5zZm9ybWVyLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBmaW5hbElucHV0O1xuICAgICAgICBsZXQgZmluYWxJbnB1dFN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIGxldCBmaW5hbE91dHB1dDtcbiAgICAgICAgbGV0IGZpbmFsT3V0cHV0U3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gZW5zdXJlQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKGNvbmZpZyk7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uKiB3cmFwSW5wdXRGb3JUcmFjaW5nKCkge1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBpbnB1dEdlbmVyYXRvcikge1xuICAgICAgICAgICAgICAgIGlmIChmaW5hbElucHV0U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbElucHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsSW5wdXQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbElucHV0ID0gY29uY2F0KGZpbmFsSW5wdXQsIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbElucHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsSW5wdXRTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5aWVsZCBjaHVuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcnVuTWFuYWdlcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBpcGUgPSBhd2FpdCBwaXBlR2VuZXJhdG9yV2l0aFNldHVwKHRyYW5zZm9ybWVyLmJpbmQodGhpcyksIHdyYXBJbnB1dEZvclRyYWNpbmcoKSwgYXN5bmMgKCkgPT4gY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCB7IGlucHV0OiBcIlwiIH0sIHVuZGVmaW5lZCwgY29uZmlnPy5ydW5UeXBlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29uZmlnPy5ydW5OYW1lID8/IHRoaXMuZ2V0TmFtZSgpKSwgY29uZmlnKTtcbiAgICAgICAgICAgIHJ1bk1hbmFnZXIgPSBwaXBlLnNldHVwO1xuICAgICAgICAgICAgY29uc3QgaXNMb2dTdHJlYW1IYW5kbGVyID0gKGhhbmRsZXIpID0+IGhhbmRsZXIubmFtZSA9PT0gXCJsb2dfc3RyZWFtX3RyYWNlclwiO1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtTG9nSGFuZGxlciA9IHJ1bk1hbmFnZXI/LmhhbmRsZXJzLmZpbmQoaXNMb2dTdHJlYW1IYW5kbGVyKTtcbiAgICAgICAgICAgIGxldCBpdGVyYXRvciA9IHBpcGUub3V0cHV0O1xuICAgICAgICAgICAgaWYgKHN0cmVhbUxvZ0hhbmRsZXIgIT09IHVuZGVmaW5lZCAmJiBydW5NYW5hZ2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvciA9IGF3YWl0IHN0cmVhbUxvZ0hhbmRsZXIudGFwT3V0cHV0SXRlcmFibGUocnVuTWFuYWdlci5ydW5JZCwgcGlwZS5vdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBpdGVyYXRvcikge1xuICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgICAgIGlmIChmaW5hbE91dHB1dFN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmluYWxPdXRwdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE91dHB1dCA9IGNvbmNhdChmaW5hbE91dHB1dCwgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgIGlucHV0czogX2NvZXJjZVRvRGljdChmaW5hbElucHV0LCBcImlucHV0XCIpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKGZpbmFsT3V0cHV0ID8/IHt9LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7IGlucHV0czogX2NvZXJjZVRvRGljdChmaW5hbElucHV0LCBcImlucHV0XCIpIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgcnVubmFibGUgc2VxdWVuY2UgdGhhdCBydW5zIGVhY2ggaW5kaXZpZHVhbCBydW5uYWJsZSBpbiBzZXJpZXMsXG4gICAgICogcGlwaW5nIHRoZSBvdXRwdXQgb2Ygb25lIHJ1bm5hYmxlIGludG8gYW5vdGhlciBydW5uYWJsZSBvciBydW5uYWJsZS1saWtlLlxuICAgICAqIEBwYXJhbSBjb2VyY2VhYmxlIEEgcnVubmFibGUsIGZ1bmN0aW9uLCBvciBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBmdW5jdGlvbnMgb3IgcnVubmFibGVzLlxuICAgICAqIEByZXR1cm5zIEEgbmV3IHJ1bm5hYmxlIHNlcXVlbmNlLlxuICAgICAqL1xuICAgIHBpcGUoY29lcmNlYWJsZSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVTZXF1ZW5jZSh7XG4gICAgICAgICAgICBmaXJzdDogdGhpcyxcbiAgICAgICAgICAgIGxhc3Q6IF9jb2VyY2VUb1J1bm5hYmxlKGNvZXJjZWFibGUpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGljayBrZXlzIGZyb20gdGhlIGRpY3Qgb3V0cHV0IG9mIHRoaXMgcnVubmFibGUuIFJldHVybnMgYSBuZXcgcnVubmFibGUuXG4gICAgICovXG4gICAgcGljayhrZXlzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIHRoaXMucGlwZShuZXcgUnVubmFibGVQaWNrKGtleXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzaWducyBuZXcgZmllbGRzIHRvIHRoZSBkaWN0IG91dHB1dCBvZiB0aGlzIHJ1bm5hYmxlLiBSZXR1cm5zIGEgbmV3IHJ1bm5hYmxlLlxuICAgICAqL1xuICAgIGFzc2lnbihtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpcGUoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgbmV3IFJ1bm5hYmxlQXNzaWduKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIG5ldyBSdW5uYWJsZU1hcCh7IHN0ZXBzOiBtYXBwaW5nIH0pKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdHJhbnNmb3JtLCB3aGljaCBidWZmZXJzIGlucHV0IGFuZCB0aGVuIGNhbGxzIHN0cmVhbS5cbiAgICAgKiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB0aGV5IGNhbiBzdGFydCBwcm9kdWNpbmcgb3V0cHV0IHdoaWxlXG4gICAgICogaW5wdXQgaXMgc3RpbGwgYmVpbmcgZ2VuZXJhdGVkLlxuICAgICAqIEBwYXJhbSBnZW5lcmF0b3JcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIGFzeW5jICp0cmFuc2Zvcm0oZ2VuZXJhdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBmaW5hbENodW5rO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGdlbmVyYXRvcikge1xuICAgICAgICAgICAgaWYgKGZpbmFsQ2h1bmsgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZpbmFsQ2h1bmsgPSBjaHVuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE1ha2UgYSBiZXN0IGVmZm9ydCB0byBnYXRoZXIsIGZvciBhbnkgdHlwZSB0aGF0IHN1cHBvcnRzIGNvbmNhdC5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIG1ldGhvZCBzaG91bGQgdGhyb3cgYW4gZXJyb3IgaWYgZ2F0aGVyaW5nIGZhaWxzLlxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgZmluYWxDaHVuayA9IGNvbmNhdChmaW5hbENodW5rLCBjaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQqIHRoaXMuX3N0cmVhbUl0ZXJhdG9yKGZpbmFsQ2h1bmssIGVuc3VyZUNvbmZpZyhvcHRpb25zKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0cmVhbSBhbGwgb3V0cHV0IGZyb20gYSBydW5uYWJsZSwgYXMgcmVwb3J0ZWQgdG8gdGhlIGNhbGxiYWNrIHN5c3RlbS5cbiAgICAgKiBUaGlzIGluY2x1ZGVzIGFsbCBpbm5lciBydW5zIG9mIExMTXMsIFJldHJpZXZlcnMsIFRvb2xzLCBldGMuXG4gICAgICogT3V0cHV0IGlzIHN0cmVhbWVkIGFzIExvZyBvYmplY3RzLCB3aGljaCBpbmNsdWRlIGEgbGlzdCBvZlxuICAgICAqIGpzb25wYXRjaCBvcHMgdGhhdCBkZXNjcmliZSBob3cgdGhlIHN0YXRlIG9mIHRoZSBydW4gaGFzIGNoYW5nZWQgaW4gZWFjaFxuICAgICAqIHN0ZXAsIGFuZCB0aGUgZmluYWwgc3RhdGUgb2YgdGhlIHJ1bi5cbiAgICAgKiBUaGUganNvbnBhdGNoIG9wcyBjYW4gYmUgYXBwbGllZCBpbiBvcmRlciB0byBjb25zdHJ1Y3Qgc3RhdGUuXG4gICAgICogQHBhcmFtIGlucHV0XG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gc3RyZWFtT3B0aW9uc1xuICAgICAqL1xuICAgIGFzeW5jICpzdHJlYW1Mb2coaW5wdXQsIG9wdGlvbnMsIHN0cmVhbU9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyID0gbmV3IExvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlcih7XG4gICAgICAgICAgICAuLi5zdHJlYW1PcHRpb25zLFxuICAgICAgICAgICAgYXV0b0Nsb3NlOiBmYWxzZSxcbiAgICAgICAgICAgIF9zY2hlbWFGb3JtYXQ6IFwib3JpZ2luYWxcIixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IGVuc3VyZUNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgeWllbGQqIHRoaXMuX3N0cmVhbUxvZyhpbnB1dCwgbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyLCBjb25maWcpO1xuICAgIH1cbiAgICBhc3luYyAqX3N0cmVhbUxvZyhpbnB1dCwgbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyLCBjb25maWcpIHtcbiAgICAgICAgY29uc3QgeyBjYWxsYmFja3MgfSA9IGNvbmZpZztcbiAgICAgICAgaWYgKGNhbGxiYWNrcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIGNvbmZpZy5jYWxsYmFja3MgPSBbbG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNhbGxiYWNrcykpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgY29uZmlnLmNhbGxiYWNrcyA9IGNhbGxiYWNrcy5jb25jYXQoW2xvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlcl0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY29waWVkQ2FsbGJhY2tzID0gY2FsbGJhY2tzLmNvcHkoKTtcbiAgICAgICAgICAgIGNvcGllZENhbGxiYWNrcy5pbmhlcml0YWJsZUhhbmRsZXJzLnB1c2gobG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgY29uZmlnLmNhbGxiYWNrcyA9IGNvcGllZENhbGxiYWNrcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW5uYWJsZVN0cmVhbVByb21pc2UgPSB0aGlzLnN0cmVhbShpbnB1dCwgY29uZmlnKTtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gY29uc3VtZVJ1bm5hYmxlU3RyZWFtKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBydW5uYWJsZVN0cmVhbSA9IGF3YWl0IHJ1bm5hYmxlU3RyZWFtUHJvbWlzZTtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHJ1bm5hYmxlU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGNoID0gbmV3IFJ1bkxvZ1BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IFwiL3N0cmVhbWVkX291dHB1dC8tXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGxvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlci53cml0ZXIud3JpdGUocGF0Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGxvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlci53cml0ZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW5uYWJsZVN0cmVhbUNvbnN1bWVQcm9taXNlID0gY29uc3VtZVJ1bm5hYmxlU3RyZWFtKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGxvZyBvZiBsb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBsb2c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBhd2FpdCBydW5uYWJsZVN0cmVhbUNvbnN1bWVQcm9taXNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgc3RyZWFtIG9mIGV2ZW50cyBlbWl0dGVkIGJ5IHRoZSBpbnRlcm5hbCBzdGVwcyBvZiB0aGUgcnVubmFibGUuXG4gICAgICpcbiAgICAgKiBVc2UgdG8gY3JlYXRlIGFuIGl0ZXJhdG9yIG92ZXIgU3RyZWFtRXZlbnRzIHRoYXQgcHJvdmlkZSByZWFsLXRpbWUgaW5mb3JtYXRpb25cbiAgICAgKiBhYm91dCB0aGUgcHJvZ3Jlc3Mgb2YgdGhlIHJ1bm5hYmxlLCBpbmNsdWRpbmcgU3RyZWFtRXZlbnRzIGZyb20gaW50ZXJtZWRpYXRlXG4gICAgICogcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEEgU3RyZWFtRXZlbnQgaXMgYSBkaWN0aW9uYXJ5IHdpdGggdGhlIGZvbGxvd2luZyBzY2hlbWE6XG4gICAgICpcbiAgICAgKiAtIGBldmVudGA6IHN0cmluZyAtIEV2ZW50IG5hbWVzIGFyZSBvZiB0aGUgZm9ybWF0OiBvbl9bcnVubmFibGVfdHlwZV1fKHN0YXJ0fHN0cmVhbXxlbmQpLlxuICAgICAqIC0gYG5hbWVgOiBzdHJpbmcgLSBUaGUgbmFtZSBvZiB0aGUgcnVubmFibGUgdGhhdCBnZW5lcmF0ZWQgdGhlIGV2ZW50LlxuICAgICAqIC0gYHJ1bl9pZGA6IHN0cmluZyAtIFJhbmRvbWx5IGdlbmVyYXRlZCBJRCBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGV4ZWN1dGlvbiBvZlxuICAgICAqICAgdGhlIHJ1bm5hYmxlIHRoYXQgZW1pdHRlZCB0aGUgZXZlbnQuIEEgY2hpbGQgcnVubmFibGUgdGhhdCBnZXRzIGludm9rZWQgYXMgcGFydCBvZiB0aGUgZXhlY3V0aW9uIG9mIGFcbiAgICAgKiAgIHBhcmVudCBydW5uYWJsZSBpcyBhc3NpZ25lZCBpdHMgb3duIHVuaXF1ZSBJRC5cbiAgICAgKiAtIGB0YWdzYDogc3RyaW5nW10gLSBUaGUgdGFncyBvZiB0aGUgcnVubmFibGUgdGhhdCBnZW5lcmF0ZWQgdGhlIGV2ZW50LlxuICAgICAqIC0gYG1ldGFkYXRhYDogUmVjb3JkPHN0cmluZywgYW55PiAtIFRoZSBtZXRhZGF0YSBvZiB0aGUgcnVubmFibGUgdGhhdCBnZW5lcmF0ZWQgdGhlIGV2ZW50LlxuICAgICAqIC0gYGRhdGFgOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICAgICpcbiAgICAgKiBCZWxvdyBpcyBhIHRhYmxlIHRoYXQgaWxsdXN0cmF0ZXMgc29tZSBldmVudHMgdGhhdCBtaWdodCBiZSBlbWl0dGVkIGJ5IHZhcmlvdXNcbiAgICAgKiBjaGFpbnMuIE1ldGFkYXRhIGZpZWxkcyBoYXZlIGJlZW4gb21pdHRlZCBmcm9tIHRoZSB0YWJsZSBmb3IgYnJldml0eS5cbiAgICAgKiBDaGFpbiBkZWZpbml0aW9ucyBoYXZlIGJlZW4gaW5jbHVkZWQgYWZ0ZXIgdGhlIHRhYmxlLlxuICAgICAqXG4gICAgICogfCBldmVudCAgICAgICAgICAgICAgICB8IG5hbWUgICAgICAgICAgICAgfCBjaHVuayAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgaW5wdXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgb3V0cHV0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAqIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAgKiB8IG9uX2xsbV9zdGFydCAgICAgICAgIHwgW21vZGVsIG5hbWVdICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB7J2lucHV0JzogJ2hlbGxvJ30gICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICogfCBvbl9sbG1fc3RyZWFtICAgICAgICB8IFttb2RlbCBuYW1lXSAgICAgfCAnSGVsbG8nIE9SIEFJTWVzc2FnZUNodW5rKFwiaGVsbG9cIikgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICogfCBvbl9sbG1fZW5kICAgICAgICAgICB8IFttb2RlbCBuYW1lXSAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgJ0hlbGxvIGh1bWFuIScgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgKiB8IG9uX2NoYWluX3N0YXJ0ICAgICAgIHwgZm9ybWF0X2RvY3MgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICogfCBvbl9jaGFpbl9zdHJlYW0gICAgICB8IGZvcm1hdF9kb2NzICAgICAgfCBcImhlbGxvIHdvcmxkISwgZ29vZGJ5ZSB3b3JsZCFcIiAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICogfCBvbl9jaGFpbl9lbmQgICAgICAgICB8IGZvcm1hdF9kb2NzICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgW0RvY3VtZW50KC4uLildICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgXCJoZWxsbyB3b3JsZCEsIGdvb2RieWUgd29ybGQhXCIgICAgICAgICAgICAgICAgICB8XG4gICAgICogfCBvbl90b29sX3N0YXJ0ICAgICAgICB8IHNvbWVfdG9vbCAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwge1wieFwiOiAxLCBcInlcIjogXCIyXCJ9ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAqIHwgb25fdG9vbF9zdHJlYW0gICAgICAgfCBzb21lX3Rvb2wgICAgICAgIHwgICB7XCJ4XCI6IDEsIFwieVwiOiBcIjJcIn0gICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgKiB8IG9uX3Rvb2xfZW5kICAgICAgICAgIHwgc29tZV90b29sICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB7XCJ4XCI6IDEsIFwieVwiOiBcIjJcIn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICogfCBvbl9yZXRyaWV2ZXJfc3RhcnQgICB8IFtyZXRyaWV2ZXIgbmFtZV0gfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwge1wicXVlcnlcIjogXCJoZWxsb1wifSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgKiB8IG9uX3JldHJpZXZlcl9jaHVuayAgIHwgW3JldHJpZXZlciBuYW1lXSB8ICB7ZG9jdW1lbnRzOiBbLi4uXX0gICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICogfCBvbl9yZXRyaWV2ZXJfZW5kICAgICB8IFtyZXRyaWV2ZXIgbmFtZV0gfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwge1wicXVlcnlcIjogXCJoZWxsb1wifSAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHtkb2N1bWVudHM6IFsuLi5dfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgKiB8IG9uX3Byb21wdF9zdGFydCAgICAgIHwgW3RlbXBsYXRlX25hbWVdICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB7XCJxdWVzdGlvblwiOiBcImhlbGxvXCJ9ICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAqIHwgb25fcHJvbXB0X2VuZCAgICAgICAgfCBbdGVtcGxhdGVfbmFtZV0gIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHtcInF1ZXN0aW9uXCI6IFwiaGVsbG9cIn0gICAgICAgICAgICAgICAgICAgICAgICAgfCBDaGF0UHJvbXB0VmFsdWUobWVzc2FnZXM6IFtTeXN0ZW1NZXNzYWdlLCAuLi5dKSB8XG4gICAgICovXG4gICAgYXN5bmMgKnN0cmVhbUV2ZW50cyhpbnB1dCwgb3B0aW9ucywgc3RyZWFtT3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy52ZXJzaW9uICE9PSBcInYxXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT25seSB2ZXJzaW9uIFwidjFcIiBvZiB0aGUgZXZlbnRzIHNjaGVtYSBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLmApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBydW5Mb2c7XG4gICAgICAgIGxldCBoYXNFbmNvdW50ZXJlZFN0YXJ0RXZlbnQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gZW5zdXJlQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCByb290VGFncyA9IGNvbmZpZy50YWdzID8/IFtdO1xuICAgICAgICBjb25zdCByb290TWV0YWRhdGEgPSBjb25maWcubWV0YWRhdGEgPz8ge307XG4gICAgICAgIGNvbnN0IHJvb3ROYW1lID0gY29uZmlnLnJ1bk5hbWUgPz8gdGhpcy5nZXROYW1lKCk7XG4gICAgICAgIGNvbnN0IGxvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlciA9IG5ldyBMb2dTdHJlYW1DYWxsYmFja0hhbmRsZXIoe1xuICAgICAgICAgICAgLi4uc3RyZWFtT3B0aW9ucyxcbiAgICAgICAgICAgIGF1dG9DbG9zZTogZmFsc2UsXG4gICAgICAgICAgICBfc2NoZW1hRm9ybWF0OiBcInN0cmVhbWluZ19ldmVudHNcIixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJvb3RFdmVudEZpbHRlciA9IG5ldyBfUm9vdEV2ZW50RmlsdGVyKHtcbiAgICAgICAgICAgIC4uLnN0cmVhbU9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBsb2dTdHJlYW0gPSB0aGlzLl9zdHJlYW1Mb2coaW5wdXQsIGxvZ1N0cmVhbUNhbGxiYWNrSGFuZGxlciwgY29uZmlnKTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBsb2cgb2YgbG9nU3RyZWFtKSB7XG4gICAgICAgICAgICBpZiAoIXJ1bkxvZykge1xuICAgICAgICAgICAgICAgIHJ1bkxvZyA9IFJ1bkxvZy5mcm9tUnVuTG9nUGF0Y2gobG9nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJ1bkxvZyA9IHJ1bkxvZy5jb25jYXQobG9nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChydW5Mb2cuc3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW50ZXJuYWwgZXJyb3I6IFwic3RyZWFtRXZlbnRzXCIgc3RhdGUgaXMgbWlzc2luZy4gUGxlYXNlIG9wZW4gYSBidWcgcmVwb3J0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gWWllbGQgdGhlIHN0YXJ0IGV2ZW50IGZvciB0aGUgcm9vdCBydW5uYWJsZSBpZiBpdCBoYXNuJ3QgYmVlbiBzZWVuLlxuICAgICAgICAgICAgLy8gVGhlIHJvb3QgcnVuIGlzIG5ldmVyIGZpbHRlcmVkIG91dFxuICAgICAgICAgICAgaWYgKCFoYXNFbmNvdW50ZXJlZFN0YXJ0RXZlbnQpIHtcbiAgICAgICAgICAgICAgICBoYXNFbmNvdW50ZXJlZFN0YXJ0RXZlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0geyAuLi5ydW5Mb2cuc3RhdGUgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuX2lkOiBzdGF0ZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGBvbl8ke3N0YXRlLnR5cGV9X3N0YXJ0YCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcm9vdE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHRhZ3M6IHJvb3RUYWdzLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogcm9vdE1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChyb290RXZlbnRGaWx0ZXIuaW5jbHVkZUV2ZW50KGV2ZW50LCBzdGF0ZS50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBldmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXRocyA9IGxvZy5vcHNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChvcCkgPT4gb3AucGF0aC5zdGFydHNXaXRoKFwiL2xvZ3MvXCIpKVxuICAgICAgICAgICAgICAgIC5tYXAoKG9wKSA9PiBvcC5wYXRoLnNwbGl0KFwiL1wiKVsyXSk7XG4gICAgICAgICAgICBjb25zdCBkZWR1cGVkUGF0aHMgPSBbLi4ubmV3IFNldChwYXRocyldO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXRoIG9mIGRlZHVwZWRQYXRocykge1xuICAgICAgICAgICAgICAgIGxldCBldmVudFR5cGU7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGEgPSB7fTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2dFbnRyeSA9IHJ1bkxvZy5zdGF0ZS5sb2dzW3BhdGhdO1xuICAgICAgICAgICAgICAgIGlmIChsb2dFbnRyeS5lbmRfdGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2dFbnRyeS5zdHJlYW1lZF9vdXRwdXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRUeXBlID0gXCJzdHJlYW1cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50VHlwZSA9IFwic3RhcnRcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRUeXBlID0gXCJlbmRcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gXCJzdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluY2x1ZGUgdGhlIGlucHV0cyB3aXRoIHRoZSBzdGFydCBldmVudCBpZiB0aGV5IGFyZSBhdmFpbGFibGUuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzdWFsbHkgdGhleSB3aWxsIE5PVCBiZSBhdmFpbGFibGUgZm9yIGNvbXBvbmVudHMgdGhhdCBvcGVyYXRlXG4gICAgICAgICAgICAgICAgICAgIC8vIG9uIHN0cmVhbXMsIHNpbmNlIHRob3NlIGNvbXBvbmVudHMgc3RyZWFtIHRoZSBpbnB1dCBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3Qga25vdyBpdHMgZmluYWwgdmFsdWUgdW50aWwgdGhlIGVuZCBvZiB0aGUgc3RyZWFtLlxuICAgICAgICAgICAgICAgICAgICBpZiAobG9nRW50cnkuaW5wdXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuaW5wdXQgPSBsb2dFbnRyeS5pbnB1dHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnRUeXBlID09PSBcImVuZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2dFbnRyeS5pbnB1dHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5pbnB1dCA9IGxvZ0VudHJ5LmlucHV0cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkYXRhLm91dHB1dCA9IGxvZ0VudHJ5LmZpbmFsX291dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnRUeXBlID09PSBcInN0cmVhbVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rQ291bnQgPSBsb2dFbnRyeS5zdHJlYW1lZF9vdXRwdXQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmtDb3VudCAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBleGFjdGx5IG9uZSBjaHVuayBvZiBzdHJlYW1lZCBvdXRwdXQsIGdvdCAke2NodW5rQ291bnR9IGluc3RlYWQuIEVuY291bnRlcmVkIGluOiBcIiR7bG9nRW50cnkubmFtZX1cImApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSB7IGNodW5rOiBsb2dFbnRyeS5zdHJlYW1lZF9vdXRwdXRbMF0gfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIHN0cmVhbSwgd2UgZG9uJ3QgbmVlZCBpdCBhbnltb3JlLlxuICAgICAgICAgICAgICAgICAgICAvLyBBbmQgdGhpcyBhdm9pZHMgZHVwbGljYXRlcyBhcyB3ZWxsIVxuICAgICAgICAgICAgICAgICAgICBsb2dFbnRyeS5zdHJlYW1lZF9vdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgICAgICAgICBldmVudDogYG9uXyR7bG9nRW50cnkudHlwZX1fJHtldmVudFR5cGV9YCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbG9nRW50cnkubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcnVuX2lkOiBsb2dFbnRyeS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdGFnczogbG9nRW50cnkudGFncyxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IGxvZ0VudHJ5Lm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaW5hbGx5LCB3ZSB0YWtlIGNhcmUgb2YgdGhlIHN0cmVhbWluZyBvdXRwdXQgZnJvbSB0aGUgcm9vdCBjaGFpblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW55LlxuICAgICAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gcnVuTG9nO1xuICAgICAgICAgICAgaWYgKHN0YXRlLnN0cmVhbWVkX291dHB1dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmtDb3VudCA9IHN0YXRlLnN0cmVhbWVkX291dHB1dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGNodW5rQ291bnQgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBleGFjdGx5IG9uZSBjaHVuayBvZiBzdHJlYW1lZCBvdXRwdXQsIGdvdCAke2NodW5rQ291bnR9IGluc3RlYWQuIEVuY291bnRlcmVkIGluOiBcIiR7c3RhdGUubmFtZX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geyBjaHVuazogc3RhdGUuc3RyZWFtZWRfb3V0cHV0WzBdIH07XG4gICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIHN0cmVhbSwgd2UgZG9uJ3QgbmVlZCBpdCBhbnltb3JlLlxuICAgICAgICAgICAgICAgIHN0YXRlLnN0cmVhbWVkX291dHB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBldmVudDogYG9uXyR7c3RhdGUudHlwZX1fc3RyZWFtYCxcbiAgICAgICAgICAgICAgICAgICAgcnVuX2lkOiBzdGF0ZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdGFnczogcm9vdFRhZ3MsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiByb290TWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHJvb3ROYW1lLFxuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHJvb3RFdmVudEZpbHRlci5pbmNsdWRlRXZlbnQoZXZlbnQsIHN0YXRlLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGV2ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0ZSA9IHJ1bkxvZz8uc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBGaW5hbGx5LCB5aWVsZCB0aGUgZW5kIGV2ZW50IGZvciB0aGUgcm9vdCBydW5uYWJsZS5cbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgICAgICAgIGV2ZW50OiBgb25fJHtzdGF0ZS50eXBlfV9lbmRgLFxuICAgICAgICAgICAgICAgIG5hbWU6IHJvb3ROYW1lLFxuICAgICAgICAgICAgICAgIHJ1bl9pZDogc3RhdGUuaWQsXG4gICAgICAgICAgICAgICAgdGFnczogcm9vdFRhZ3MsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHJvb3RNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dDogc3RhdGUuZmluYWxfb3V0cHV0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJvb3RFdmVudEZpbHRlci5pbmNsdWRlRXZlbnQoZXZlbnQsIHN0YXRlLnR5cGUpKVxuICAgICAgICAgICAgICAgIHlpZWxkIGV2ZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc3RhdGljIGlzUnVubmFibGUodGhpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaW5nID8gdGhpbmcubGNfcnVubmFibGUgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZCBsaWZlY3ljbGUgbGlzdGVuZXJzIHRvIGEgUnVubmFibGUsIHJldHVybmluZyBhIG5ldyBSdW5uYWJsZS5cbiAgICAgKiBUaGUgUnVuIG9iamVjdCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcnVuLCBpbmNsdWRpbmcgaXRzIGlkLFxuICAgICAqIHR5cGUsIGlucHV0LCBvdXRwdXQsIGVycm9yLCBzdGFydFRpbWUsIGVuZFRpbWUsIGFuZCBhbnkgdGFncyBvciBtZXRhZGF0YVxuICAgICAqIGFkZGVkIHRvIHRoZSBydW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIG9iamVjdCBjb250YWluaW5nIHRoZSBjYWxsYmFjayBmdW5jdGlvbnMuXG4gICAgICogQHBhcmFtIHsocnVuOiBSdW4pID0+IHZvaWR9IHBhcmFtcy5vblN0YXJ0IC0gQ2FsbGVkIGJlZm9yZSB0aGUgcnVubmFibGUgc3RhcnRzIHJ1bm5pbmcsIHdpdGggdGhlIFJ1biBvYmplY3QuXG4gICAgICogQHBhcmFtIHsocnVuOiBSdW4pID0+IHZvaWR9IHBhcmFtcy5vbkVuZCAtIENhbGxlZCBhZnRlciB0aGUgcnVubmFibGUgZmluaXNoZXMgcnVubmluZywgd2l0aCB0aGUgUnVuIG9iamVjdC5cbiAgICAgKiBAcGFyYW0geyhydW46IFJ1bikgPT4gdm9pZH0gcGFyYW1zLm9uRXJyb3IgLSBDYWxsZWQgaWYgdGhlIHJ1bm5hYmxlIHRocm93cyBhbiBlcnJvciwgd2l0aCB0aGUgUnVuIG9iamVjdC5cbiAgICAgKi9cbiAgICB3aXRoTGlzdGVuZXJzKHsgb25TdGFydCwgb25FbmQsIG9uRXJyb3IsIH0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlQmluZGluZyh7XG4gICAgICAgICAgICBib3VuZDogdGhpcyxcbiAgICAgICAgICAgIGNvbmZpZzoge30sXG4gICAgICAgICAgICBjb25maWdGYWN0b3JpZXM6IFtcbiAgICAgICAgICAgICAgICAoY29uZmlnKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBSb290TGlzdGVuZXJzVHJhY2VyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25TdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIEEgcnVubmFibGUgdGhhdCBkZWxlZ2F0ZXMgY2FsbHMgdG8gYW5vdGhlciBydW5uYWJsZSB3aXRoIGEgc2V0IG9mIGt3YXJncy5cbiAqL1xuZXhwb3J0IGNsYXNzIFJ1bm5hYmxlQmluZGluZyBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVCaW5kaW5nXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJvdW5kXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbmZpZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJrd2FyZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29uZmlnRmFjdG9yaWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm91bmQgPSBmaWVsZHMuYm91bmQ7XG4gICAgICAgIHRoaXMua3dhcmdzID0gZmllbGRzLmt3YXJncztcbiAgICAgICAgdGhpcy5jb25maWcgPSBmaWVsZHMuY29uZmlnO1xuICAgICAgICB0aGlzLmNvbmZpZ0ZhY3RvcmllcyA9IGZpZWxkcy5jb25maWdGYWN0b3JpZXM7XG4gICAgfVxuICAgIGdldE5hbWUoc3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kLmdldE5hbWUoc3VmZml4KTtcbiAgICB9XG4gICAgYXN5bmMgX21lcmdlQ29uZmlnKC4uLm9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gbWVyZ2VDb25maWdzKHRoaXMuY29uZmlnLCAuLi5vcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG1lcmdlQ29uZmlncyhjb25maWcsIC4uLih0aGlzLmNvbmZpZ0ZhY3Rvcmllc1xuICAgICAgICAgICAgPyBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmNvbmZpZ0ZhY3Rvcmllcy5tYXAoYXN5bmMgKGNvbmZpZ0ZhY3RvcnkpID0+IGF3YWl0IGNvbmZpZ0ZhY3RvcnkoY29uZmlnKSkpXG4gICAgICAgICAgICA6IFtdKSk7XG4gICAgfVxuICAgIGJpbmQoa3dhcmdzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih7XG4gICAgICAgICAgICBib3VuZDogdGhpcy5ib3VuZCxcbiAgICAgICAgICAgIGt3YXJnczogeyAuLi50aGlzLmt3YXJncywgLi4ua3dhcmdzIH0sXG4gICAgICAgICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgd2l0aENvbmZpZyhjb25maWcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLmJvdW5kLFxuICAgICAgICAgICAga3dhcmdzOiB0aGlzLmt3YXJncyxcbiAgICAgICAgICAgIGNvbmZpZzogeyAuLi50aGlzLmNvbmZpZywgLi4uY29uZmlnIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB3aXRoUmV0cnkoZmllbGRzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih7XG4gICAgICAgICAgICBib3VuZDogdGhpcy5ib3VuZC53aXRoUmV0cnkoZmllbGRzKSxcbiAgICAgICAgICAgIGt3YXJnczogdGhpcy5rd2FyZ3MsXG4gICAgICAgICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kLmludm9rZShpbnB1dCwgYXdhaXQgdGhpcy5fbWVyZ2VDb25maWcob3B0aW9ucywgdGhpcy5rd2FyZ3MpKTtcbiAgICB9XG4gICAgYXN5bmMgYmF0Y2goaW5wdXRzLCBvcHRpb25zLCBiYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IEFycmF5LmlzQXJyYXkob3B0aW9ucylcbiAgICAgICAgICAgID8gYXdhaXQgUHJvbWlzZS5hbGwob3B0aW9ucy5tYXAoYXN5bmMgKGluZGl2aWR1YWxPcHRpb24pID0+IHRoaXMuX21lcmdlQ29uZmlnKGluZGl2aWR1YWxPcHRpb24sIHRoaXMua3dhcmdzKSkpXG4gICAgICAgICAgICA6IGF3YWl0IHRoaXMuX21lcmdlQ29uZmlnKG9wdGlvbnMsIHRoaXMua3dhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmQuYmF0Y2goaW5wdXRzLCBtZXJnZWRPcHRpb25zLCBiYXRjaE9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyAqX3N0cmVhbUl0ZXJhdG9yKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHlpZWxkKiB0aGlzLmJvdW5kLl9zdHJlYW1JdGVyYXRvcihpbnB1dCwgYXdhaXQgdGhpcy5fbWVyZ2VDb25maWcob3B0aW9ucywgdGhpcy5rd2FyZ3MpKTtcbiAgICB9XG4gICAgYXN5bmMgc3RyZWFtKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kLnN0cmVhbShpbnB1dCwgYXdhaXQgdGhpcy5fbWVyZ2VDb25maWcob3B0aW9ucywgdGhpcy5rd2FyZ3MpKTtcbiAgICB9XG4gICAgYXN5bmMgKnRyYW5zZm9ybShcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGdlbmVyYXRvciwgb3B0aW9ucykge1xuICAgICAgICB5aWVsZCogdGhpcy5ib3VuZC50cmFuc2Zvcm0oZ2VuZXJhdG9yLCBhd2FpdCB0aGlzLl9tZXJnZUNvbmZpZyhvcHRpb25zLCB0aGlzLmt3YXJncykpO1xuICAgIH1cbiAgICBhc3luYyAqc3RyZWFtRXZlbnRzKGlucHV0LCBvcHRpb25zLCBzdHJlYW1PcHRpb25zKSB7XG4gICAgICAgIHlpZWxkKiB0aGlzLmJvdW5kLnN0cmVhbUV2ZW50cyhpbnB1dCwge1xuICAgICAgICAgICAgLi4uKGF3YWl0IHRoaXMuX21lcmdlQ29uZmlnKG9wdGlvbnMsIHRoaXMua3dhcmdzKSksXG4gICAgICAgICAgICB2ZXJzaW9uOiBvcHRpb25zLnZlcnNpb24sXG4gICAgICAgIH0sIHN0cmVhbU9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNSdW5uYWJsZUJpbmRpbmcoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICB0aGluZ1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgKSB7XG4gICAgICAgIHJldHVybiB0aGluZy5ib3VuZCAmJiBSdW5uYWJsZS5pc1J1bm5hYmxlKHRoaW5nLmJvdW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZCBsaWZlY3ljbGUgbGlzdGVuZXJzIHRvIGEgUnVubmFibGUsIHJldHVybmluZyBhIG5ldyBSdW5uYWJsZS5cbiAgICAgKiBUaGUgUnVuIG9iamVjdCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcnVuLCBpbmNsdWRpbmcgaXRzIGlkLFxuICAgICAqIHR5cGUsIGlucHV0LCBvdXRwdXQsIGVycm9yLCBzdGFydFRpbWUsIGVuZFRpbWUsIGFuZCBhbnkgdGFncyBvciBtZXRhZGF0YVxuICAgICAqIGFkZGVkIHRvIHRoZSBydW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIG9iamVjdCBjb250YWluaW5nIHRoZSBjYWxsYmFjayBmdW5jdGlvbnMuXG4gICAgICogQHBhcmFtIHsocnVuOiBSdW4pID0+IHZvaWR9IHBhcmFtcy5vblN0YXJ0IC0gQ2FsbGVkIGJlZm9yZSB0aGUgcnVubmFibGUgc3RhcnRzIHJ1bm5pbmcsIHdpdGggdGhlIFJ1biBvYmplY3QuXG4gICAgICogQHBhcmFtIHsocnVuOiBSdW4pID0+IHZvaWR9IHBhcmFtcy5vbkVuZCAtIENhbGxlZCBhZnRlciB0aGUgcnVubmFibGUgZmluaXNoZXMgcnVubmluZywgd2l0aCB0aGUgUnVuIG9iamVjdC5cbiAgICAgKiBAcGFyYW0geyhydW46IFJ1bikgPT4gdm9pZH0gcGFyYW1zLm9uRXJyb3IgLSBDYWxsZWQgaWYgdGhlIHJ1bm5hYmxlIHRocm93cyBhbiBlcnJvciwgd2l0aCB0aGUgUnVuIG9iamVjdC5cbiAgICAgKi9cbiAgICB3aXRoTGlzdGVuZXJzKHsgb25TdGFydCwgb25FbmQsIG9uRXJyb3IsIH0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZUJpbmRpbmcoe1xuICAgICAgICAgICAgYm91bmQ6IHRoaXMuYm91bmQsXG4gICAgICAgICAgICBrd2FyZ3M6IHRoaXMua3dhcmdzLFxuICAgICAgICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgICAgIGNvbmZpZ0ZhY3RvcmllczogW1xuICAgICAgICAgICAgICAgIChjb25maWcpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFJvb3RMaXN0ZW5lcnNUcmFjZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQSBydW5uYWJsZSB0aGF0IGRlbGVnYXRlcyBjYWxscyB0byBhbm90aGVyIHJ1bm5hYmxlXG4gKiB3aXRoIGVhY2ggZWxlbWVudCBvZiB0aGUgaW5wdXQgc2VxdWVuY2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW5uYWJsZUVhY2ggZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlRWFjaFwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJib3VuZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJvdW5kID0gZmllbGRzLmJvdW5kO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kcyB0aGUgcnVubmFibGUgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ga3dhcmdzIFRoZSBhcmd1bWVudHMgdG8gYmluZCB0aGUgcnVubmFibGUgd2l0aC5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFJ1bm5hYmxlRWFjaGAgY2xhc3MgdGhhdCBpcyBib3VuZCB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGJpbmQoa3dhcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVFYWNoKHtcbiAgICAgICAgICAgIGJvdW5kOiB0aGlzLmJvdW5kLmJpbmQoa3dhcmdzKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIHJ1bm5hYmxlIHdpdGggdGhlIHNwZWNpZmllZCBpbnB1dCBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRvIGludm9rZSB0aGUgcnVubmFibGUgd2l0aC5cbiAgICAgKiBAcGFyYW0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIHRvIGludm9rZSB0aGUgcnVubmFibGUgd2l0aC5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgb3V0cHV0IG9mIHRoZSBydW5uYWJsZS5cbiAgICAgKi9cbiAgICBhc3luYyBpbnZva2UoaW5wdXRzLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxXaXRoQ29uZmlnKHRoaXMuX2ludm9rZSwgaW5wdXRzLCBjb25maWcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGludm9rZSB0aGUgcnVubmFibGUgd2l0aCB0aGUgc3BlY2lmaWVkIGlucHV0IGFuZCBjb25maWd1cmF0aW9uLlxuICAgICAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgdG8gaW52b2tlIHRoZSBydW5uYWJsZSB3aXRoLlxuICAgICAqIEBwYXJhbSBjb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gdG8gaW52b2tlIHRoZSBydW5uYWJsZSB3aXRoLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBvdXRwdXQgb2YgdGhlIHJ1bm5hYmxlLlxuICAgICAqL1xuICAgIGFzeW5jIF9pbnZva2UoaW5wdXRzLCBjb25maWcsIHJ1bk1hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmQuYmF0Y2goaW5wdXRzLCBwYXRjaENvbmZpZyhjb25maWcsIHsgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZCgpIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZCBsaWZlY3ljbGUgbGlzdGVuZXJzIHRvIGEgUnVubmFibGUsIHJldHVybmluZyBhIG5ldyBSdW5uYWJsZS5cbiAgICAgKiBUaGUgUnVuIG9iamVjdCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcnVuLCBpbmNsdWRpbmcgaXRzIGlkLFxuICAgICAqIHR5cGUsIGlucHV0LCBvdXRwdXQsIGVycm9yLCBzdGFydFRpbWUsIGVuZFRpbWUsIGFuZCBhbnkgdGFncyBvciBtZXRhZGF0YVxuICAgICAqIGFkZGVkIHRvIHRoZSBydW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIG9iamVjdCBjb250YWluaW5nIHRoZSBjYWxsYmFjayBmdW5jdGlvbnMuXG4gICAgICogQHBhcmFtIHsocnVuOiBSdW4pID0+IHZvaWR9IHBhcmFtcy5vblN0YXJ0IC0gQ2FsbGVkIGJlZm9yZSB0aGUgcnVubmFibGUgc3RhcnRzIHJ1bm5pbmcsIHdpdGggdGhlIFJ1biBvYmplY3QuXG4gICAgICogQHBhcmFtIHsocnVuOiBSdW4pID0+IHZvaWR9IHBhcmFtcy5vbkVuZCAtIENhbGxlZCBhZnRlciB0aGUgcnVubmFibGUgZmluaXNoZXMgcnVubmluZywgd2l0aCB0aGUgUnVuIG9iamVjdC5cbiAgICAgKiBAcGFyYW0geyhydW46IFJ1bikgPT4gdm9pZH0gcGFyYW1zLm9uRXJyb3IgLSBDYWxsZWQgaWYgdGhlIHJ1bm5hYmxlIHRocm93cyBhbiBlcnJvciwgd2l0aCB0aGUgUnVuIG9iamVjdC5cbiAgICAgKi9cbiAgICB3aXRoTGlzdGVuZXJzKHsgb25TdGFydCwgb25FbmQsIG9uRXJyb3IsIH0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZUVhY2goe1xuICAgICAgICAgICAgYm91bmQ6IHRoaXMuYm91bmQud2l0aExpc3RlbmVycyh7IG9uU3RhcnQsIG9uRW5kLCBvbkVycm9yIH0pLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIHJ1bm5hYmxlcyB0aGF0IGNhbiBiZSByZXRyaWVkIGFcbiAqIHNwZWNpZmllZCBudW1iZXIgb2YgdGltZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW5uYWJsZVJldHJ5IGV4dGVuZHMgUnVubmFibGVCaW5kaW5nIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVSZXRyeVwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4QXR0ZW1wdE51bWJlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogM1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib25GYWlsZWRBdHRlbXB0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAoKSA9PiB7IH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWF4QXR0ZW1wdE51bWJlciA9IGZpZWxkcy5tYXhBdHRlbXB0TnVtYmVyID8/IHRoaXMubWF4QXR0ZW1wdE51bWJlcjtcbiAgICAgICAgdGhpcy5vbkZhaWxlZEF0dGVtcHQgPSBmaWVsZHMub25GYWlsZWRBdHRlbXB0ID8/IHRoaXMub25GYWlsZWRBdHRlbXB0O1xuICAgIH1cbiAgICBfcGF0Y2hDb25maWdGb3JSZXRyeShhdHRlbXB0LCBjb25maWcsIHJ1bk1hbmFnZXIpIHtcbiAgICAgICAgY29uc3QgdGFnID0gYXR0ZW1wdCA+IDEgPyBgcmV0cnk6YXR0ZW1wdDoke2F0dGVtcHR9YCA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHBhdGNoQ29uZmlnKGNvbmZpZywgeyBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKHRhZykgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9pbnZva2UoaW5wdXQsIGNvbmZpZywgcnVuTWFuYWdlcikge1xuICAgICAgICByZXR1cm4gcFJldHJ5KChhdHRlbXB0TnVtYmVyKSA9PiBzdXBlci5pbnZva2UoaW5wdXQsIHRoaXMuX3BhdGNoQ29uZmlnRm9yUmV0cnkoYXR0ZW1wdE51bWJlciwgY29uZmlnLCBydW5NYW5hZ2VyKSksIHtcbiAgICAgICAgICAgIG9uRmFpbGVkQXR0ZW1wdDogdGhpcy5vbkZhaWxlZEF0dGVtcHQsXG4gICAgICAgICAgICByZXRyaWVzOiBNYXRoLm1heCh0aGlzLm1heEF0dGVtcHROdW1iZXIgLSAxLCAwKSxcbiAgICAgICAgICAgIHJhbmRvbWl6ZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGludm9rZXMgdGhlIHJ1bm5hYmxlIHdpdGggdGhlIHNwZWNpZmllZCBpbnB1dCwgcnVuIG1hbmFnZXIsXG4gICAgICogYW5kIGNvbmZpZy4gSXQgaGFuZGxlcyB0aGUgcmV0cnkgbG9naWMgYnkgY2F0Y2hpbmcgYW55IGVycm9ycyBhbmRcbiAgICAgKiByZWN1cnNpdmVseSBpbnZva2luZyBpdHNlbGYgd2l0aCB0aGUgdXBkYXRlZCBjb25maWcgZm9yIHRoZSBuZXh0IHJldHJ5XG4gICAgICogYXR0ZW1wdC5cbiAgICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IGZvciB0aGUgcnVubmFibGUuXG4gICAgICogQHBhcmFtIHJ1bk1hbmFnZXIgVGhlIHJ1biBtYW5hZ2VyIGZvciB0aGUgcnVubmFibGUuXG4gICAgICogQHBhcmFtIGNvbmZpZyBUaGUgY29uZmlnIGZvciB0aGUgcnVubmFibGUuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG91dHB1dCBvZiB0aGUgcnVubmFibGUuXG4gICAgICovXG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxXaXRoQ29uZmlnKHRoaXMuX2ludm9rZSwgaW5wdXQsIGNvbmZpZyk7XG4gICAgfVxuICAgIGFzeW5jIF9iYXRjaChpbnB1dHMsIGNvbmZpZ3MsIHJ1bk1hbmFnZXJzLCBiYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0c01hcCA9IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgcFJldHJ5KGFzeW5jIChhdHRlbXB0TnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nSW5kZXhlcyA9IGlucHV0c1xuICAgICAgICAgICAgICAgICAgICAubWFwKChfLCBpKSA9PiBpKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChpKSA9PiByZXN1bHRzTWFwW2kudG9TdHJpbmcoKV0gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNNYXBbaS50b1N0cmluZygpXSBpbnN0YW5jZW9mIEVycm9yKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZW1haW5pbmdJbnB1dHMgPSByZW1haW5pbmdJbmRleGVzLm1hcCgoaSkgPT4gaW5wdXRzW2ldKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRjaGVkQ29uZmlncyA9IHJlbWFpbmluZ0luZGV4ZXMubWFwKChpKSA9PiB0aGlzLl9wYXRjaENvbmZpZ0ZvclJldHJ5KGF0dGVtcHROdW1iZXIsIGNvbmZpZ3M/LltpXSwgcnVuTWFuYWdlcnM/LltpXSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBzdXBlci5iYXRjaChyZW1haW5pbmdJbnB1dHMsIHBhdGNoZWRDb25maWdzLCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmJhdGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuRXhjZXB0aW9uczogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgZmlyc3RFeGNlcHRpb247XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3VsdHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdE1hcEluZGV4ID0gcmVtYWluaW5nSW5kZXhlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdEV4Y2VwdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RFeGNlcHRpb24gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c01hcFtyZXN1bHRNYXBJbmRleC50b1N0cmluZygpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0RXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGZpcnN0RXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBvbkZhaWxlZEF0dGVtcHQ6IHRoaXMub25GYWlsZWRBdHRlbXB0LFxuICAgICAgICAgICAgICAgIHJldHJpZXM6IE1hdGgubWF4KHRoaXMubWF4QXR0ZW1wdE51bWJlciAtIDEsIDApLFxuICAgICAgICAgICAgICAgIHJhbmRvbWl6ZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoYmF0Y2hPcHRpb25zPy5yZXR1cm5FeGNlcHRpb25zICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocmVzdWx0c01hcClcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBwYXJzZUludChhLCAxMCkgLSBwYXJzZUludChiLCAxMCkpXG4gICAgICAgICAgICAubWFwKChrZXkpID0+IHJlc3VsdHNNYXBbcGFyc2VJbnQoa2V5LCAxMCldKTtcbiAgICB9XG4gICAgYXN5bmMgYmF0Y2goaW5wdXRzLCBvcHRpb25zLCBiYXRjaE9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JhdGNoV2l0aENvbmZpZyh0aGlzLl9iYXRjaC5iaW5kKHRoaXMpLCBpbnB1dHMsIG9wdGlvbnMsIGJhdGNoT3B0aW9ucyk7XG4gICAgfVxufVxuLyoqXG4gKiBBIHNlcXVlbmNlIG9mIHJ1bm5hYmxlcywgd2hlcmUgdGhlIG91dHB1dCBvZiBlYWNoIGlzIHRoZSBpbnB1dCBvZiB0aGUgbmV4dC5cbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBwcm9tcHRUZW1wbGF0ZSA9IFByb21wdFRlbXBsYXRlLmZyb21UZW1wbGF0ZShcbiAqICAgXCJUZWxsIG1lIGEgam9rZSBhYm91dCB7dG9waWN9XCIsXG4gKiApO1xuICogY29uc3QgY2hhaW4gPSBSdW5uYWJsZVNlcXVlbmNlLmZyb20oW3Byb21wdFRlbXBsYXRlLCBuZXcgQ2hhdE9wZW5BSSh7fSldKTtcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNoYWluLmludm9rZSh7IHRvcGljOiBcImJlYXJzXCIgfSk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFJ1bm5hYmxlU2VxdWVuY2UgZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlU2VxdWVuY2VcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZpcnN0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1pZGRsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxhc3RcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZpcnN0ID0gZmllbGRzLmZpcnN0O1xuICAgICAgICB0aGlzLm1pZGRsZSA9IGZpZWxkcy5taWRkbGUgPz8gdGhpcy5taWRkbGU7XG4gICAgICAgIHRoaXMubGFzdCA9IGZpZWxkcy5sYXN0O1xuICAgICAgICB0aGlzLm5hbWUgPSBmaWVsZHMubmFtZTtcbiAgICB9XG4gICAgZ2V0IHN0ZXBzKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuZmlyc3QsIC4uLnRoaXMubWlkZGxlLCB0aGlzLmxhc3RdO1xuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gZW5zdXJlQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHJ1bk1hbmFnZXIgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVDaGFpblN0YXJ0KHRoaXMudG9KU09OKCksIF9jb2VyY2VUb0RpY3QoaW5wdXQsIFwiaW5wdXRcIiksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29uZmlnPy5ydW5OYW1lKTtcbiAgICAgICAgbGV0IG5leHRTdGVwSW5wdXQgPSBpbnB1dDtcbiAgICAgICAgbGV0IGZpbmFsT3V0cHV0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbFN0ZXBzID0gW3RoaXMuZmlyc3QsIC4uLnRoaXMubWlkZGxlXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5pdGlhbFN0ZXBzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcCA9IGluaXRpYWxTdGVwc1tpXTtcbiAgICAgICAgICAgICAgICBuZXh0U3RlcElucHV0ID0gYXdhaXQgc3RlcC5pbnZva2UobmV4dFN0ZXBJbnB1dCwgcGF0Y2hDb25maWcoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoYHNlcTpzdGVwOiR7aSArIDF9YCksXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVHlwZVNjcmlwdCBjYW4ndCBkZXRlY3QgdGhhdCB0aGUgbGFzdCBvdXRwdXQgb2YgdGhlIHNlcXVlbmNlIHJldHVybnMgUnVuT3V0cHV0LCBzbyBjYWxsIGl0IG91dCBvZiB0aGUgbG9vcCBoZXJlXG4gICAgICAgICAgICBmaW5hbE91dHB1dCA9IGF3YWl0IHRoaXMubGFzdC5pbnZva2UobmV4dFN0ZXBJbnB1dCwgcGF0Y2hDb25maWcoY29uZmlnLCB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZChgc2VxOnN0ZXA6JHt0aGlzLnN0ZXBzLmxlbmd0aH1gKSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQoX2NvZXJjZVRvRGljdChmaW5hbE91dHB1dCwgXCJvdXRwdXRcIikpO1xuICAgICAgICByZXR1cm4gZmluYWxPdXRwdXQ7XG4gICAgfVxuICAgIGFzeW5jIGJhdGNoKGlucHV0cywgb3B0aW9ucywgYmF0Y2hPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZ0xpc3QgPSB0aGlzLl9nZXRPcHRpb25zTGlzdChvcHRpb25zID8/IHt9LCBpbnB1dHMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VycyA9IGF3YWl0IFByb21pc2UuYWxsKGNvbmZpZ0xpc3QubWFwKGdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZykpO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VycyA9IGF3YWl0IFByb21pc2UuYWxsKGNhbGxiYWNrTWFuYWdlcnMubWFwKChjYWxsYmFja01hbmFnZXIsIGkpID0+IGNhbGxiYWNrTWFuYWdlcj8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCBfY29lcmNlVG9EaWN0KGlucHV0c1tpXSwgXCJpbnB1dFwiKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb25maWdMaXN0W2ldLnJ1bk5hbWUpKSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGxldCBuZXh0U3RlcElucHV0cyA9IGlucHV0cztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGVwcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLnN0ZXBzW2ldO1xuICAgICAgICAgICAgICAgIG5leHRTdGVwSW5wdXRzID0gYXdhaXQgc3RlcC5iYXRjaChuZXh0U3RlcElucHV0cywgcnVuTWFuYWdlcnMubWFwKChydW5NYW5hZ2VyLCBqKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkUnVuTWFuYWdlciA9IHJ1bk1hbmFnZXI/LmdldENoaWxkKGBzZXE6c3RlcDoke2kgKyAxfWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0Y2hDb25maWcoY29uZmlnTGlzdFtqXSwgeyBjYWxsYmFja3M6IGNoaWxkUnVuTWFuYWdlciB9KTtcbiAgICAgICAgICAgICAgICB9KSwgYmF0Y2hPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocnVuTWFuYWdlcnMubWFwKChydW5NYW5hZ2VyKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGUpKSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJ1bk1hbmFnZXJzLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQoX2NvZXJjZVRvRGljdChuZXh0U3RlcElucHV0cywgXCJvdXRwdXRcIikpKSk7XG4gICAgICAgIHJldHVybiBuZXh0U3RlcElucHV0cztcbiAgICB9XG4gICAgYXN5bmMgKl9zdHJlYW1JdGVyYXRvcihpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VyID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCBfY29lcmNlVG9EaWN0KGlucHV0LCBcImlucHV0XCIpLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9wdGlvbnM/LnJ1bk5hbWUpO1xuICAgICAgICBjb25zdCBzdGVwcyA9IFt0aGlzLmZpcnN0LCAuLi50aGlzLm1pZGRsZSwgdGhpcy5sYXN0XTtcbiAgICAgICAgbGV0IGNvbmNhdFN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIGxldCBmaW5hbE91dHB1dDtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24qIGlucHV0R2VuZXJhdG9yKCkge1xuICAgICAgICAgICAgeWllbGQgaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBmaW5hbEdlbmVyYXRvciA9IHN0ZXBzWzBdLnRyYW5zZm9ybShpbnB1dEdlbmVyYXRvcigpLCBwYXRjaENvbmZpZyhvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZChgc2VxOnN0ZXA6MWApLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdGVwcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXAgPSBzdGVwc1tpXTtcbiAgICAgICAgICAgICAgICBmaW5hbEdlbmVyYXRvciA9IGF3YWl0IHN0ZXAudHJhbnNmb3JtKGZpbmFsR2VuZXJhdG9yLCBwYXRjaENvbmZpZyhvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoYHNlcTpzdGVwOiR7aSArIDF9YCksXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBmaW5hbEdlbmVyYXRvcikge1xuICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgICAgIGlmIChjb25jYXRTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsT3V0cHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsT3V0cHV0ID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSBjb25jYXQoZmluYWxPdXRwdXQsIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPdXRwdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uY2F0U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRW5kKF9jb2VyY2VUb0RpY3QoZmluYWxPdXRwdXQsIFwib3V0cHV0XCIpKTtcbiAgICB9XG4gICAgcGlwZShjb2VyY2VhYmxlKSB7XG4gICAgICAgIGlmIChSdW5uYWJsZVNlcXVlbmNlLmlzUnVubmFibGVTZXF1ZW5jZShjb2VyY2VhYmxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSdW5uYWJsZVNlcXVlbmNlKHtcbiAgICAgICAgICAgICAgICBmaXJzdDogdGhpcy5maXJzdCxcbiAgICAgICAgICAgICAgICBtaWRkbGU6IHRoaXMubWlkZGxlLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdCxcbiAgICAgICAgICAgICAgICAgICAgY29lcmNlYWJsZS5maXJzdCxcbiAgICAgICAgICAgICAgICAgICAgLi4uY29lcmNlYWJsZS5taWRkbGUsXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgbGFzdDogY29lcmNlYWJsZS5sYXN0LFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSA/PyBjb2VyY2VhYmxlLm5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUnVubmFibGVTZXF1ZW5jZSh7XG4gICAgICAgICAgICAgICAgZmlyc3Q6IHRoaXMuZmlyc3QsXG4gICAgICAgICAgICAgICAgbWlkZGxlOiBbLi4udGhpcy5taWRkbGUsIHRoaXMubGFzdF0sXG4gICAgICAgICAgICAgICAgbGFzdDogX2NvZXJjZVRvUnVubmFibGUoY29lcmNlYWJsZSksXG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzdGF0aWMgaXNSdW5uYWJsZVNlcXVlbmNlKHRoaW5nKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRoaW5nLm1pZGRsZSkgJiYgUnVubmFibGUuaXNSdW5uYWJsZSh0aGluZyk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc3RhdGljIGZyb20oW2ZpcnN0LCAuLi5ydW5uYWJsZXNdLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVTZXF1ZW5jZSh7XG4gICAgICAgICAgICBmaXJzdDogX2NvZXJjZVRvUnVubmFibGUoZmlyc3QpLFxuICAgICAgICAgICAgbWlkZGxlOiBydW5uYWJsZXMuc2xpY2UoMCwgLTEpLm1hcChfY29lcmNlVG9SdW5uYWJsZSksXG4gICAgICAgICAgICBsYXN0OiBfY29lcmNlVG9SdW5uYWJsZShydW5uYWJsZXNbcnVubmFibGVzLmxlbmd0aCAtIDFdKSxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQSBydW5uYWJsZSB0aGF0IHJ1bnMgYSBtYXBwaW5nIG9mIHJ1bm5hYmxlcyBpbiBwYXJhbGxlbCxcbiAqIGFuZCByZXR1cm5zIGEgbWFwcGluZyBvZiB0aGVpciBvdXRwdXRzLlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IG1hcENoYWluID0gUnVubmFibGVNYXAuZnJvbSh7XG4gKiAgIGpva2U6IFByb21wdFRlbXBsYXRlLmZyb21UZW1wbGF0ZShcIlRlbGwgbWUgYSBqb2tlIGFib3V0IHt0b3BpY31cIikucGlwZShcbiAqICAgICBuZXcgQ2hhdEFudGhyb3BpYyh7fSksXG4gKiAgICksXG4gKiAgIHBvZW06IFByb21wdFRlbXBsYXRlLmZyb21UZW1wbGF0ZShcIndyaXRlIGEgMi1saW5lIHBvZW0gYWJvdXQge3RvcGljfVwiKS5waXBlKFxuICogICAgIG5ldyBDaGF0QW50aHJvcGljKHt9KSxcbiAqICAgKSxcbiAqIH0pO1xuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgbWFwQ2hhaW4uaW52b2tlKHsgdG9waWM6IFwiYmVhclwiIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW5uYWJsZU1hcCBleHRlbmRzIFJ1bm5hYmxlIHtcbiAgICBzdGF0aWMgbGNfbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiUnVubmFibGVNYXBcIjtcbiAgICB9XG4gICAgZ2V0U3RlcHNLZXlzKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zdGVwcyk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19zZXJpYWxpemFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0ZXBzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RlcHMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZmllbGRzLnN0ZXBzKSkge1xuICAgICAgICAgICAgdGhpcy5zdGVwc1trZXldID0gX2NvZXJjZVRvUnVubmFibGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHN0ZXBzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVNYXAoeyBzdGVwcyB9KTtcbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IGVuc3VyZUNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyXyA9IGF3YWl0IGdldENhbGxiYWNrTWFuYWdlckZvckNvbmZpZyhjb25maWcpO1xuICAgICAgICBjb25zdCBydW5NYW5hZ2VyID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlQ2hhaW5TdGFydCh0aGlzLnRvSlNPTigpLCB7XG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgfSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb25maWc/LnJ1bk5hbWUpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBvdXRwdXQgPSB7fTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC5lbnRyaWVzKHRoaXMuc3RlcHMpLm1hcChhc3luYyAoW2tleSwgcnVubmFibGVdKSA9PiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBhd2FpdCBydW5uYWJsZS5pbnZva2UoaW5wdXQsIHBhdGNoQ29uZmlnKGNvbmZpZywge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKGBtYXA6a2V5OiR7a2V5fWApLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FcnJvcihlKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQob3V0cHV0KTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgYXN5bmMgKl90cmFuc2Zvcm0oZ2VuZXJhdG9yLCBydW5NYW5hZ2VyLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIHNoYWxsb3cgY29weSBzdGVwcyB0byBpZ25vcmUgY2hhbmdlcyB3aGlsZSBpdGVyYXRpbmdcbiAgICAgICAgY29uc3Qgc3RlcHMgPSB7IC4uLnRoaXMuc3RlcHMgfTtcbiAgICAgICAgLy8gZWFjaCBzdGVwIGdldHMgYSBjb3B5IG9mIHRoZSBpbnB1dCBpdGVyYXRvclxuICAgICAgICBjb25zdCBpbnB1dENvcGllcyA9IGF0ZWUoZ2VuZXJhdG9yLCBPYmplY3Qua2V5cyhzdGVwcykubGVuZ3RoKTtcbiAgICAgICAgLy8gc3RhcnQgdGhlIGZpcnN0IGl0ZXJhdGlvbiBvZiBlYWNoIG91dHB1dCBpdGVyYXRvclxuICAgICAgICBjb25zdCB0YXNrcyA9IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoc3RlcHMpLm1hcCgoW2tleSwgcnVubmFibGVdLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBnZW4gPSBydW5uYWJsZS50cmFuc2Zvcm0oaW5wdXRDb3BpZXNbaV0sIHBhdGNoQ29uZmlnKG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKGBtYXA6a2V5OiR7a2V5fWApLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIFtrZXksIGdlbi5uZXh0KCkudGhlbigocmVzdWx0KSA9PiAoeyBrZXksIGdlbiwgcmVzdWx0IH0pKV07XG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8geWllbGQgY2h1bmtzIGFzIHRoZXkgYmVjb21lIGF2YWlsYWJsZSxcbiAgICAgICAgLy8gc3RhcnRpbmcgbmV3IGl0ZXJhdGlvbnMgYXMgbmVlZGVkLFxuICAgICAgICAvLyB1bnRpbCBhbGwgaXRlcmF0b3JzIGFyZSBkb25lXG4gICAgICAgIHdoaWxlICh0YXNrcy5zaXplKSB7XG4gICAgICAgICAgICBjb25zdCB7IGtleSwgcmVzdWx0LCBnZW4gfSA9IGF3YWl0IFByb21pc2UucmFjZSh0YXNrcy52YWx1ZXMoKSk7XG4gICAgICAgICAgICB0YXNrcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB7IFtrZXldOiByZXN1bHQudmFsdWUgfTtcbiAgICAgICAgICAgICAgICB0YXNrcy5zZXQoa2V5LCBnZW4ubmV4dCgpLnRoZW4oKHJlc3VsdCkgPT4gKHsga2V5LCBnZW4sIHJlc3VsdCB9KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRyYW5zZm9ybShnZW5lcmF0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybVN0cmVhbVdpdGhDb25maWcoZ2VuZXJhdG9yLCB0aGlzLl90cmFuc2Zvcm0uYmluZCh0aGlzKSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHN0cmVhbShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBhc3luYyBmdW5jdGlvbiogZ2VuZXJhdG9yKCkge1xuICAgICAgICAgICAgeWllbGQgaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd3JhcHBlZEdlbmVyYXRvciA9IG5ldyBBc3luY0dlbmVyYXRvcldpdGhTZXR1cCh0aGlzLnRyYW5zZm9ybShnZW5lcmF0b3IoKSwgb3B0aW9ucykpO1xuICAgICAgICBhd2FpdCB3cmFwcGVkR2VuZXJhdG9yLnNldHVwO1xuICAgICAgICByZXR1cm4gSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tQXN5bmNHZW5lcmF0b3Iod3JhcHBlZEdlbmVyYXRvcik7XG4gICAgfVxufVxuLyoqXG4gKiBBIHJ1bm5hYmxlIHRoYXQgcnVucyBhIGNhbGxhYmxlLlxuICovXG5leHBvcnQgY2xhc3MgUnVubmFibGVMYW1iZGEgZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlTGFtYmRhXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsY19uYW1lc3BhY2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtcImxhbmdjaGFpbl9jb3JlXCIsIFwicnVubmFibGVzXCJdXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmdW5jXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZnVuYyA9IGZpZWxkcy5mdW5jO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShmdW5jKSB7XG4gICAgICAgIHJldHVybiBuZXcgUnVubmFibGVMYW1iZGEoe1xuICAgICAgICAgICAgZnVuYyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9pbnZva2UoaW5wdXQsIGNvbmZpZywgcnVuTWFuYWdlcikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRDb25maWcgPSBwYXRjaENvbmZpZyhjb25maWcsIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKCksXG4gICAgICAgICAgICAgICAgcmVjdXJzaW9uTGltaXQ6IChjb25maWc/LnJlY3Vyc2lvbkxpbWl0ID8/IERFRkFVTFRfUkVDVVJTSU9OX0xJTUlUKSAtIDEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZvaWQgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5nZXRJbnN0YW5jZSgpLnJ1bihjaGlsZENvbmZpZywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvdXRwdXQgPSBhd2FpdCB0aGlzLmZ1bmMoaW5wdXQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNoaWxkQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjaGlsZENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQgJiYgUnVubmFibGUuaXNSdW5uYWJsZShvdXRwdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnPy5yZWN1cnNpb25MaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlY3Vyc2lvbiBsaW1pdCByZWFjaGVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IGF3YWl0IG91dHB1dC5pbnZva2UoaW5wdXQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jaGlsZENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN1cnNpb25MaW1pdDogKGNoaWxkQ29uZmlnLnJlY3Vyc2lvbkxpbWl0ID8/IERFRkFVTFRfUkVDVVJTSU9OX0xJTUlUKSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGludm9rZShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFdpdGhDb25maWcodGhpcy5faW52b2tlLCBpbnB1dCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jICpfdHJhbnNmb3JtKGdlbmVyYXRvciwgcnVuTWFuYWdlciwgY29uZmlnKSB7XG4gICAgICAgIGxldCBmaW5hbENodW5rO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGdlbmVyYXRvcikge1xuICAgICAgICAgICAgaWYgKGZpbmFsQ2h1bmsgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZpbmFsQ2h1bmsgPSBjaHVuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE1ha2UgYSBiZXN0IGVmZm9ydCB0byBnYXRoZXIsIGZvciBhbnkgdHlwZSB0aGF0IHN1cHBvcnRzIGNvbmNhdC5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICBmaW5hbENodW5rID0gY29uY2F0KGZpbmFsQ2h1bmssIGNodW5rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxDaHVuayA9IGNodW5rO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB2b2lkIEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24uZ2V0SW5zdGFuY2UoKS5ydW4oY29uZmlnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5mdW5jKGZpbmFsQ2h1bmssIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG91dHB1dCAmJiBSdW5uYWJsZS5pc1J1bm5hYmxlKG91dHB1dCkpIHtcbiAgICAgICAgICAgIGlmIChjb25maWc/LnJlY3Vyc2lvbkxpbWl0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVjdXJzaW9uIGxpbWl0IHJlYWNoZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgb3V0cHV0LnN0cmVhbShmaW5hbENodW5rLCBwYXRjaENvbmZpZyhjb25maWcsIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKCksXG4gICAgICAgICAgICAgICAgcmVjdXJzaW9uTGltaXQ6IChjb25maWc/LnJlY3Vyc2lvbkxpbWl0ID8/IERFRkFVTFRfUkVDVVJTSU9OX0xJTUlUKSAtIDEsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeWllbGQgb3V0cHV0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyYW5zZm9ybShnZW5lcmF0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybVN0cmVhbVdpdGhDb25maWcoZ2VuZXJhdG9yLCB0aGlzLl90cmFuc2Zvcm0uYmluZCh0aGlzKSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHN0cmVhbShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBhc3luYyBmdW5jdGlvbiogZ2VuZXJhdG9yKCkge1xuICAgICAgICAgICAgeWllbGQgaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd3JhcHBlZEdlbmVyYXRvciA9IG5ldyBBc3luY0dlbmVyYXRvcldpdGhTZXR1cCh0aGlzLnRyYW5zZm9ybShnZW5lcmF0b3IoKSwgb3B0aW9ucykpO1xuICAgICAgICBhd2FpdCB3cmFwcGVkR2VuZXJhdG9yLnNldHVwO1xuICAgICAgICByZXR1cm4gSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tQXN5bmNHZW5lcmF0b3Iod3JhcHBlZEdlbmVyYXRvcik7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFJ1bm5hYmxlUGFyYWxsZWwgZXh0ZW5kcyBSdW5uYWJsZU1hcCB7XG59XG4vKipcbiAqIEEgUnVubmFibGUgdGhhdCBjYW4gZmFsbGJhY2sgdG8gb3RoZXIgUnVubmFibGVzIGlmIGl0IGZhaWxzLlxuICovXG5leHBvcnQgY2xhc3MgUnVubmFibGVXaXRoRmFsbGJhY2tzIGV4dGVuZHMgUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZVdpdGhGYWxsYmFja3NcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJydW5uYWJsZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicnVubmFibGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmFsbGJhY2tzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucnVubmFibGUgPSBmaWVsZHMucnVubmFibGU7XG4gICAgICAgIHRoaXMuZmFsbGJhY2tzID0gZmllbGRzLmZhbGxiYWNrcztcbiAgICB9XG4gICAgKnJ1bm5hYmxlcygpIHtcbiAgICAgICAgeWllbGQgdGhpcy5ydW5uYWJsZTtcbiAgICAgICAgZm9yIChjb25zdCBmYWxsYmFjayBvZiB0aGlzLmZhbGxiYWNrcykge1xuICAgICAgICAgICAgeWllbGQgZmFsbGJhY2s7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaW52b2tlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrTWFuYWdlcl8gPSBhd2FpdCBDYWxsYmFja01hbmFnZXIuY29uZmlndXJlKG9wdGlvbnM/LmNhbGxiYWNrcywgdW5kZWZpbmVkLCBvcHRpb25zPy50YWdzLCB1bmRlZmluZWQsIG9wdGlvbnM/Lm1ldGFkYXRhKTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlciA9IGF3YWl0IGNhbGxiYWNrTWFuYWdlcl8/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgX2NvZXJjZVRvRGljdChpbnB1dCwgXCJpbnB1dFwiKSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvcHRpb25zPy5ydW5OYW1lKTtcbiAgICAgICAgbGV0IGZpcnN0RXJyb3I7XG4gICAgICAgIGZvciAoY29uc3QgcnVubmFibGUgb2YgdGhpcy5ydW5uYWJsZXMoKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCBydW5uYWJsZS5pbnZva2UoaW5wdXQsIHBhdGNoQ29uZmlnKG9wdGlvbnMsIHsgY2FsbGJhY2tzOiBydW5NYW5hZ2VyPy5nZXRDaGlsZCgpIH0pKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVuZChfY29lcmNlVG9EaWN0KG91dHB1dCwgXCJvdXRwdXRcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdEVycm9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RFcnJvciA9IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdEVycm9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGVycm9yIHN0b3JlZCBhdCBlbmQgb2YgZmFsbGJhY2suXCIpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUNoYWluRXJyb3IoZmlyc3RFcnJvcik7XG4gICAgICAgIHRocm93IGZpcnN0RXJyb3I7XG4gICAgfVxuICAgIGFzeW5jIGJhdGNoKGlucHV0cywgb3B0aW9ucywgYmF0Y2hPcHRpb25zKSB7XG4gICAgICAgIGlmIChiYXRjaE9wdGlvbnM/LnJldHVybkV4Y2VwdGlvbnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlnTGlzdCA9IHRoaXMuX2dldE9wdGlvbnNMaXN0KG9wdGlvbnMgPz8ge30sIGlucHV0cy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoY29uZmlnTGlzdC5tYXAoKGNvbmZpZykgPT4gQ2FsbGJhY2tNYW5hZ2VyLmNvbmZpZ3VyZShjb25maWc/LmNhbGxiYWNrcywgdW5kZWZpbmVkLCBjb25maWc/LnRhZ3MsIHVuZGVmaW5lZCwgY29uZmlnPy5tZXRhZGF0YSkpKTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlcnMgPSBhd2FpdCBQcm9taXNlLmFsbChjYWxsYmFja01hbmFnZXJzLm1hcCgoY2FsbGJhY2tNYW5hZ2VyLCBpKSA9PiBjYWxsYmFja01hbmFnZXI/LmhhbmRsZUNoYWluU3RhcnQodGhpcy50b0pTT04oKSwgX2NvZXJjZVRvRGljdChpbnB1dHNbaV0sIFwiaW5wdXRcIiksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29uZmlnTGlzdFtpXS5ydW5OYW1lKSkpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBsZXQgZmlyc3RFcnJvcjtcbiAgICAgICAgZm9yIChjb25zdCBydW5uYWJsZSBvZiB0aGlzLnJ1bm5hYmxlcygpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dHMgPSBhd2FpdCBydW5uYWJsZS5iYXRjaChpbnB1dHMsIHJ1bk1hbmFnZXJzLm1hcCgocnVuTWFuYWdlciwgaikgPT4gcGF0Y2hDb25maWcoY29uZmlnTGlzdFtqXSwge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHJ1bk1hbmFnZXI/LmdldENoaWxkKCksXG4gICAgICAgICAgICAgICAgfSkpLCBiYXRjaE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJ1bk1hbmFnZXJzLm1hcCgocnVuTWFuYWdlciwgaSkgPT4gcnVuTWFuYWdlcj8uaGFuZGxlQ2hhaW5FbmQoX2NvZXJjZVRvRGljdChvdXRwdXRzW2ldLCBcIm91dHB1dFwiKSkpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0RXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdEVycm9yID0gZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmaXJzdEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBlcnJvciBzdG9yZWQgYXQgZW5kIG9mIGZhbGxiYWNrcy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocnVuTWFuYWdlcnMubWFwKChydW5NYW5hZ2VyKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVDaGFpbkVycm9yKGZpcnN0RXJyb3IpKSk7XG4gICAgICAgIHRocm93IGZpcnN0RXJyb3I7XG4gICAgfVxufVxuLy8gVE9ETzogRmlndXJlIG91dCB3aHkgdGhlIGNvbXBpbGVyIG5lZWRzIGhlbHAgZWxpbWluYXRpbmcgRXJyb3IgYXMgYSBSdW5PdXRwdXQgdHlwZVxuZXhwb3J0IGZ1bmN0aW9uIF9jb2VyY2VUb1J1bm5hYmxlKGNvZXJjZWFibGUpIHtcbiAgICBpZiAodHlwZW9mIGNvZXJjZWFibGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlTGFtYmRhKHsgZnVuYzogY29lcmNlYWJsZSB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoUnVubmFibGUuaXNSdW5uYWJsZShjb2VyY2VhYmxlKSkge1xuICAgICAgICByZXR1cm4gY29lcmNlYWJsZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoY29lcmNlYWJsZSkgJiYgdHlwZW9mIGNvZXJjZWFibGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3QgcnVubmFibGVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGNvZXJjZWFibGUpKSB7XG4gICAgICAgICAgICBydW5uYWJsZXNba2V5XSA9IF9jb2VyY2VUb1J1bm5hYmxlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJ1bm5hYmxlTWFwKHtcbiAgICAgICAgICAgIHN0ZXBzOiBydW5uYWJsZXMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIFJ1bm5hYmxlLCBmdW5jdGlvbiBvciBvYmplY3QuXFxuSW5zdGVhZCBnb3QgYW4gdW5zdXBwb3J0ZWQgdHlwZS5gKTtcbiAgICB9XG59XG4vKipcbiAqIEEgcnVubmFibGUgdGhhdCBhc3NpZ25zIGtleS12YWx1ZSBwYWlycyB0byBpbnB1dHMgb2YgdHlwZSBgUmVjb3JkPHN0cmluZywgdW5rbm93bj5gLlxuICovXG5leHBvcnQgY2xhc3MgUnVubmFibGVBc3NpZ24gZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgc3RhdGljIGxjX25hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIlJ1bm5hYmxlQXNzaWduXCI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgIGlmIChmaWVsZHMgaW5zdGFuY2VvZiBSdW5uYWJsZU1hcCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBmaWVsZHMgPSB7IG1hcHBlcjogZmllbGRzIH07XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZmllbGRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5fY29yZVwiLCBcInJ1bm5hYmxlc1wiXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfc2VyaWFsaXphYmxlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXBwZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXBwZXIgPSBmaWVsZHMubWFwcGVyO1xuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWFwcGVyUmVzdWx0ID0gYXdhaXQgdGhpcy5tYXBwZXIuaW52b2tlKGlucHV0LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmlucHV0LFxuICAgICAgICAgICAgLi4ubWFwcGVyUmVzdWx0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyAqX3RyYW5zZm9ybShnZW5lcmF0b3IsIHJ1bk1hbmFnZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gY29sbGVjdCBtYXBwZXIga2V5c1xuICAgICAgICBjb25zdCBtYXBwZXJLZXlzID0gdGhpcy5tYXBwZXIuZ2V0U3RlcHNLZXlzKCk7XG4gICAgICAgIC8vIGNyZWF0ZSB0d28gaW5wdXQgZ2Vucywgb25lIGZvciB0aGUgbWFwcGVyLCBvbmUgZm9yIHRoZSBpbnB1dFxuICAgICAgICBjb25zdCBbZm9yUGFzc3Rocm91Z2gsIGZvck1hcHBlcl0gPSBhdGVlKGdlbmVyYXRvcik7XG4gICAgICAgIC8vIGNyZWF0ZSBtYXBwZXIgb3V0cHV0IGdlblxuICAgICAgICBjb25zdCBtYXBwZXJPdXRwdXQgPSB0aGlzLm1hcHBlci50cmFuc2Zvcm0oZm9yTWFwcGVyLCBwYXRjaENvbmZpZyhvcHRpb25zLCB7IGNhbGxiYWNrczogcnVuTWFuYWdlcj8uZ2V0Q2hpbGQoKSB9KSk7XG4gICAgICAgIC8vIHN0YXJ0IHRoZSBtYXBwZXJcbiAgICAgICAgY29uc3QgZmlyc3RNYXBwZXJDaHVua1Byb21pc2UgPSBtYXBwZXJPdXRwdXQubmV4dCgpO1xuICAgICAgICAvLyB5aWVsZCB0aGUgcGFzc3Rocm91Z2hcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBmb3JQYXNzdGhyb3VnaCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KGNodW5rKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUnVubmFibGVBc3NpZ24gY2FuIG9ubHkgYmUgdXNlZCB3aXRoIG9iamVjdHMgYXMgaW5wdXQsIGdvdCAke3R5cGVvZiBjaHVua31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGNodW5rKS5maWx0ZXIoKFtrZXldKSA9PiAhbWFwcGVyS2V5cy5pbmNsdWRlcyhrZXkpKSk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoZmlsdGVyZWQpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBmaWx0ZXJlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB5aWVsZCB0aGUgbWFwcGVyIG91dHB1dFxuICAgICAgICB5aWVsZCAoYXdhaXQgZmlyc3RNYXBwZXJDaHVua1Byb21pc2UpLnZhbHVlO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIG1hcHBlck91dHB1dCkge1xuICAgICAgICAgICAgeWllbGQgY2h1bms7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJhbnNmb3JtKGdlbmVyYXRvciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtU3RyZWFtV2l0aENvbmZpZyhnZW5lcmF0b3IsIHRoaXMuX3RyYW5zZm9ybS5iaW5kKHRoaXMpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc3RyZWFtKGlucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uKiBnZW5lcmF0b3IoKSB7XG4gICAgICAgICAgICB5aWVsZCBpbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3cmFwcGVkR2VuZXJhdG9yID0gbmV3IEFzeW5jR2VuZXJhdG9yV2l0aFNldHVwKHRoaXMudHJhbnNmb3JtKGdlbmVyYXRvcigpLCBvcHRpb25zKSk7XG4gICAgICAgIGF3YWl0IHdyYXBwZWRHZW5lcmF0b3Iuc2V0dXA7XG4gICAgICAgIHJldHVybiBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21Bc3luY0dlbmVyYXRvcih3cmFwcGVkR2VuZXJhdG9yKTtcbiAgICB9XG59XG4vKipcbiAqIEEgcnVubmFibGUgdGhhdCBhc3NpZ25zIGtleS12YWx1ZSBwYWlycyB0byBpbnB1dHMgb2YgdHlwZSBgUmVjb3JkPHN0cmluZywgdW5rbm93bj5gLlxuICovXG5leHBvcnQgY2xhc3MgUnVubmFibGVQaWNrIGV4dGVuZHMgUnVubmFibGUge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJSdW5uYWJsZVBpY2tcIjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRzID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoZmllbGRzKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBmaWVsZHMgPSB7IGtleXM6IGZpZWxkcyB9O1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX25hbWVzcGFjZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW1wibGFuZ2NoYWluX2NvcmVcIiwgXCJydW5uYWJsZXNcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxjX3NlcmlhbGl6YWJsZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwia2V5c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmtleXMgPSBmaWVsZHMua2V5cztcbiAgICB9XG4gICAgYXN5bmMgX3BpY2soaW5wdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmtleXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dFt0aGlzLmtleXNdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGlja2VkID0gdGhpcy5rZXlzXG4gICAgICAgICAgICAgICAgLm1hcCgoa2V5KSA9PiBba2V5LCBpbnB1dFtrZXldXSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKCh2KSA9PiB2WzFdICE9PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgcmV0dXJuIHBpY2tlZC5sZW5ndGggPT09IDAgPyB1bmRlZmluZWQgOiBPYmplY3QuZnJvbUVudHJpZXMocGlja2VkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxXaXRoQ29uZmlnKHRoaXMuX3BpY2suYmluZCh0aGlzKSwgaW5wdXQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyAqX3RyYW5zZm9ybShnZW5lcmF0b3IpIHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBnZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHBpY2tlZCA9IGF3YWl0IHRoaXMuX3BpY2soY2h1bmspO1xuICAgICAgICAgICAgaWYgKHBpY2tlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgcGlja2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRyYW5zZm9ybShnZW5lcmF0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybVN0cmVhbVdpdGhDb25maWcoZ2VuZXJhdG9yLCB0aGlzLl90cmFuc2Zvcm0uYmluZCh0aGlzKSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHN0cmVhbShpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBhc3luYyBmdW5jdGlvbiogZ2VuZXJhdG9yKCkge1xuICAgICAgICAgICAgeWllbGQgaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd3JhcHBlZEdlbmVyYXRvciA9IG5ldyBBc3luY0dlbmVyYXRvcldpdGhTZXR1cCh0aGlzLnRyYW5zZm9ybShnZW5lcmF0b3IoKSwgb3B0aW9ucykpO1xuICAgICAgICBhd2FpdCB3cmFwcGVkR2VuZXJhdG9yLnNldHVwO1xuICAgICAgICByZXR1cm4gSXRlcmFibGVSZWFkYWJsZVN0cmVhbS5mcm9tQXN5bmNHZW5lcmF0b3Iod3JhcHBlZEdlbmVyYXRvcik7XG4gICAgfVxufVxuIiwgIi8vIEB0cy1ub2NoZWNrXG5pbXBvcnQgeyBQYXRjaEVycm9yLCBfZGVlcENsb25lLCBpc0ludGVnZXIsIHVuZXNjYXBlUGF0aENvbXBvbmVudCwgaGFzVW5kZWZpbmVkLCB9IGZyb20gXCIuL2hlbHBlcnMuanNcIjtcbmV4cG9ydCBjb25zdCBKc29uUGF0Y2hFcnJvciA9IFBhdGNoRXJyb3I7XG5leHBvcnQgY29uc3QgZGVlcENsb25lID0gX2RlZXBDbG9uZTtcbi8qIFdlIHVzZSBhIEphdmFzY3JpcHQgaGFzaCB0byBzdG9yZSBlYWNoXG4gZnVuY3Rpb24uIEVhY2ggaGFzaCBlbnRyeSAocHJvcGVydHkpIHVzZXNcbiB0aGUgb3BlcmF0aW9uIGlkZW50aWZpZXJzIHNwZWNpZmllZCBpbiByZmM2OTAyLlxuIEluIHRoaXMgd2F5LCB3ZSBjYW4gbWFwIGVhY2ggcGF0Y2ggb3BlcmF0aW9uXG4gdG8gaXRzIGRlZGljYXRlZCBmdW5jdGlvbiBpbiBlZmZpY2llbnQgd2F5LlxuICovXG4vKiBUaGUgb3BlcmF0aW9ucyBhcHBsaWNhYmxlIHRvIGFuIG9iamVjdCAqL1xuY29uc3Qgb2JqT3BzID0ge1xuICAgIGFkZDogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICBvYmpba2V5XSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCB9O1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIHZhciByZW1vdmVkID0gb2JqW2tleV07XG4gICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCByZW1vdmVkIH07XG4gICAgfSxcbiAgICByZXBsYWNlOiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIHZhciByZW1vdmVkID0gb2JqW2tleV07XG4gICAgICAgIG9ialtrZXldID0gdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCByZW1vdmVkIH07XG4gICAgfSxcbiAgICBtb3ZlOiBmdW5jdGlvbiAob2JqLCBrZXksIGRvY3VtZW50KSB7XG4gICAgICAgIC8qIGluIGNhc2UgbW92ZSB0YXJnZXQgb3ZlcndyaXRlcyBhbiBleGlzdGluZyB2YWx1ZSxcbiAgICAgICAgcmV0dXJuIHRoZSByZW1vdmVkIHZhbHVlLCB0aGlzIGNhbiBiZSB0YXhpbmcgcGVyZm9ybWFuY2Utd2lzZSxcbiAgICAgICAgYW5kIGlzIHBvdGVudGlhbGx5IHVubmVlZGVkICovXG4gICAgICAgIGxldCByZW1vdmVkID0gZ2V0VmFsdWVCeVBvaW50ZXIoZG9jdW1lbnQsIHRoaXMucGF0aCk7XG4gICAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgICAgICByZW1vdmVkID0gX2RlZXBDbG9uZShyZW1vdmVkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcmlnaW5hbFZhbHVlID0gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHtcbiAgICAgICAgICAgIG9wOiBcInJlbW92ZVwiLFxuICAgICAgICAgICAgcGF0aDogdGhpcy5mcm9tLFxuICAgICAgICB9KS5yZW1vdmVkO1xuICAgICAgICBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwge1xuICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgICAgICAgICB2YWx1ZTogb3JpZ2luYWxWYWx1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZCB9O1xuICAgIH0sXG4gICAgY29weTogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICBjb25zdCB2YWx1ZVRvQ29weSA9IGdldFZhbHVlQnlQb2ludGVyKGRvY3VtZW50LCB0aGlzLmZyb20pO1xuICAgICAgICAvLyBlbmZvcmNlIGNvcHkgYnkgdmFsdWUgc28gZnVydGhlciBvcGVyYXRpb25zIGRvbid0IGFmZmVjdCBzb3VyY2UgKHNlZSBpc3N1ZSAjMTc3KVxuICAgICAgICBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwge1xuICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgICAgICAgICB2YWx1ZTogX2RlZXBDbG9uZSh2YWx1ZVRvQ29weSksXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBuZXdEb2N1bWVudDogZG9jdW1lbnQgfTtcbiAgICB9LFxuICAgIHRlc3Q6IGZ1bmN0aW9uIChvYmosIGtleSwgZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCB0ZXN0OiBfYXJlRXF1YWxzKG9ialtrZXldLCB0aGlzLnZhbHVlKSB9O1xuICAgIH0sXG4gICAgX2dldDogZnVuY3Rpb24gKG9iaiwga2V5LCBkb2N1bWVudCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gb2JqW2tleV07XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCB9O1xuICAgIH0sXG59O1xuLyogVGhlIG9wZXJhdGlvbnMgYXBwbGljYWJsZSB0byBhbiBhcnJheS4gTWFueSBhcmUgdGhlIHNhbWUgYXMgZm9yIHRoZSBvYmplY3QgKi9cbnZhciBhcnJPcHMgPSB7XG4gICAgYWRkOiBmdW5jdGlvbiAoYXJyLCBpLCBkb2N1bWVudCkge1xuICAgICAgICBpZiAoaXNJbnRlZ2VyKGkpKSB7XG4gICAgICAgICAgICBhcnIuc3BsaWNlKGksIDAsIHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYXJyYXkgcHJvcHNcbiAgICAgICAgICAgIGFycltpXSA9IHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyBtYXkgYmUgbmVlZGVkIHdoZW4gdXNpbmcgJy0nIGluIGFuIGFycmF5XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgaW5kZXg6IGkgfTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGFyciwgaSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHJlbW92ZWRMaXN0ID0gYXJyLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuIHsgbmV3RG9jdW1lbnQ6IGRvY3VtZW50LCByZW1vdmVkOiByZW1vdmVkTGlzdFswXSB9O1xuICAgIH0sXG4gICAgcmVwbGFjZTogZnVuY3Rpb24gKGFyciwgaSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBhcnJbaV07XG4gICAgICAgIGFycltpXSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB7IG5ld0RvY3VtZW50OiBkb2N1bWVudCwgcmVtb3ZlZCB9O1xuICAgIH0sXG4gICAgbW92ZTogb2JqT3BzLm1vdmUsXG4gICAgY29weTogb2JqT3BzLmNvcHksXG4gICAgdGVzdDogb2JqT3BzLnRlc3QsXG4gICAgX2dldDogb2JqT3BzLl9nZXQsXG59O1xuLyoqXG4gKiBSZXRyaWV2ZXMgYSB2YWx1ZSBmcm9tIGEgSlNPTiBkb2N1bWVudCBieSBhIEpTT04gcG9pbnRlci5cbiAqIFJldHVybnMgdGhlIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gZ2V0IHRoZSB2YWx1ZSBmcm9tXG4gKiBAcGFyYW0gcG9pbnRlciBhbiBlc2NhcGVkIEpTT04gcG9pbnRlclxuICogQHJldHVybiBUaGUgcmV0cmlldmVkIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZUJ5UG9pbnRlcihkb2N1bWVudCwgcG9pbnRlcikge1xuICAgIGlmIChwb2ludGVyID09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH1cbiAgICB2YXIgZ2V0T3JpZ2luYWxEZXN0aW5hdGlvbiA9IHsgb3A6IFwiX2dldFwiLCBwYXRoOiBwb2ludGVyIH07XG4gICAgYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIGdldE9yaWdpbmFsRGVzdGluYXRpb24pO1xuICAgIHJldHVybiBnZXRPcmlnaW5hbERlc3RpbmF0aW9uLnZhbHVlO1xufVxuLyoqXG4gKiBBcHBseSBhIHNpbmdsZSBKU09OIFBhdGNoIE9wZXJhdGlvbiBvbiBhIEpTT04gZG9jdW1lbnQuXG4gKiBSZXR1cm5zIHRoZSB7bmV3RG9jdW1lbnQsIHJlc3VsdH0gb2YgdGhlIG9wZXJhdGlvbi5cbiAqIEl0IG1vZGlmaWVzIHRoZSBgZG9jdW1lbnRgIGFuZCBgb3BlcmF0aW9uYCBvYmplY3RzIC0gaXQgZ2V0cyB0aGUgdmFsdWVzIGJ5IHJlZmVyZW5jZS5cbiAqIElmIHlvdSB3b3VsZCBsaWtlIHRvIGF2b2lkIHRvdWNoaW5nIHlvdXIgdmFsdWVzLCBjbG9uZSB0aGVtOlxuICogYGpzb25wYXRjaC5hcHBseU9wZXJhdGlvbihkb2N1bWVudCwganNvbnBhdGNoLl9kZWVwQ2xvbmUob3BlcmF0aW9uKSlgLlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gcGF0Y2hcbiAqIEBwYXJhbSBvcGVyYXRpb24gVGhlIG9wZXJhdGlvbiB0byBhcHBseVxuICogQHBhcmFtIHZhbGlkYXRlT3BlcmF0aW9uIGBmYWxzZWAgaXMgd2l0aG91dCB2YWxpZGF0aW9uLCBgdHJ1ZWAgdG8gdXNlIGRlZmF1bHQganNvbnBhdGNoJ3MgdmFsaWRhdGlvbiwgb3IgeW91IGNhbiBwYXNzIGEgYHZhbGlkYXRlT3BlcmF0aW9uYCBjYWxsYmFjayB0byBiZSB1c2VkIGZvciB2YWxpZGF0aW9uLlxuICogQHBhcmFtIG11dGF0ZURvY3VtZW50IFdoZXRoZXIgdG8gbXV0YXRlIHRoZSBvcmlnaW5hbCBkb2N1bWVudCBvciBjbG9uZSBpdCBiZWZvcmUgYXBwbHlpbmdcbiAqIEBwYXJhbSBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zIFdoZXRoZXIgdG8gYmFuIG1vZGlmaWNhdGlvbnMgdG8gYF9fcHJvdG9fX2AsIGRlZmF1bHRzIHRvIGB0cnVlYC5cbiAqIEByZXR1cm4gYHtuZXdEb2N1bWVudCwgcmVzdWx0fWAgYWZ0ZXIgdGhlIG9wZXJhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIG9wZXJhdGlvbiwgdmFsaWRhdGVPcGVyYXRpb24gPSBmYWxzZSwgbXV0YXRlRG9jdW1lbnQgPSB0cnVlLCBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zID0gdHJ1ZSwgaW5kZXggPSAwKSB7XG4gICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRhdGVPcGVyYXRpb24gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZU9wZXJhdGlvbihvcGVyYXRpb24sIDAsIGRvY3VtZW50LCBvcGVyYXRpb24ucGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWxpZGF0b3Iob3BlcmF0aW9uLCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBST09UIE9QRVJBVElPTlMgKi9cbiAgICBpZiAob3BlcmF0aW9uLnBhdGggPT09IFwiXCIpIHtcbiAgICAgICAgbGV0IHJldHVyblZhbHVlID0geyBuZXdEb2N1bWVudDogZG9jdW1lbnQgfTtcbiAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PT0gXCJhZGRcIikge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBvcGVyYXRpb24udmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcInJlcGxhY2VcIikge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUubmV3RG9jdW1lbnQgPSBvcGVyYXRpb24udmFsdWU7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5yZW1vdmVkID0gZG9jdW1lbnQ7IC8vZG9jdW1lbnQgd2UgcmVtb3ZlZFxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gXCJtb3ZlXCIgfHwgb3BlcmF0aW9uLm9wID09PSBcImNvcHlcIikge1xuICAgICAgICAgICAgLy8gaXQncyBhIG1vdmUgb3IgY29weSB0byByb290XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IGdldFZhbHVlQnlQb2ludGVyKGRvY3VtZW50LCBvcGVyYXRpb24uZnJvbSk7IC8vIGdldCB0aGUgdmFsdWUgYnkganNvbi1wb2ludGVyIGluIGBmcm9tYCBmaWVsZFxuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PT0gXCJtb3ZlXCIpIHtcbiAgICAgICAgICAgICAgICAvLyByZXBvcnQgcmVtb3ZlZCBpdGVtXG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUucmVtb3ZlZCA9IGRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gXCJ0ZXN0XCIpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlLnRlc3QgPSBfYXJlRXF1YWxzKGRvY3VtZW50LCBvcGVyYXRpb24udmFsdWUpO1xuICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlLnRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiVGVzdCBvcGVyYXRpb24gZmFpbGVkXCIsIFwiVEVTVF9PUEVSQVRJT05fRkFJTEVEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVyblZhbHVlLm5ld0RvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcInJlbW92ZVwiKSB7XG4gICAgICAgICAgICAvLyBhIHJlbW92ZSBvbiByb290XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5yZW1vdmVkID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZS5uZXdEb2N1bWVudCA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcIl9nZXRcIikge1xuICAgICAgICAgICAgb3BlcmF0aW9uLnZhbHVlID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiBiYWQgb3BlcmF0aW9uICovXG4gICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJPcGVyYXRpb24gYG9wYCBwcm9wZXJ0eSBpcyBub3Qgb25lIG9mIG9wZXJhdGlvbnMgZGVmaW5lZCBpbiBSRkMtNjkwMlwiLCBcIk9QRVJBVElPTl9PUF9JTlZBTElEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gLyogRU5EIFJPT1QgT1BFUkFUSU9OUyAqL1xuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIW11dGF0ZURvY3VtZW50KSB7XG4gICAgICAgICAgICBkb2N1bWVudCA9IF9kZWVwQ2xvbmUoZG9jdW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGggPSBvcGVyYXRpb24ucGF0aCB8fCBcIlwiO1xuICAgICAgICBjb25zdCBrZXlzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gICAgICAgIGxldCBvYmogPSBkb2N1bWVudDtcbiAgICAgICAgbGV0IHQgPSAxOyAvL3NraXAgZW1wdHkgZWxlbWVudCAtIGh0dHA6Ly9qc3BlcmYuY29tL3RvLXNoaWZ0LW9yLW5vdC10by1zaGlmdFxuICAgICAgICBsZXQgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGxldCBleGlzdGluZ1BhdGhGcmFnbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGtleTtcbiAgICAgICAgbGV0IHZhbGlkYXRlRnVuY3Rpb247XG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRhdGVPcGVyYXRpb24gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uID0gdmFsaWRhdGVPcGVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uID0gdmFsaWRhdG9yO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXlzW3RdO1xuICAgICAgICAgICAgaWYgKGtleSAmJiBrZXkuaW5kZXhPZihcIn5cIikgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSB1bmVzY2FwZVBhdGhDb21wb25lbnQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zICYmXG4gICAgICAgICAgICAgICAgKGtleSA9PSBcIl9fcHJvdG9fX1wiIHx8XG4gICAgICAgICAgICAgICAgICAgIChrZXkgPT0gXCJwcm90b3R5cGVcIiAmJiB0ID4gMCAmJiBrZXlzW3QgLSAxXSA9PSBcImNvbnN0cnVjdG9yXCIpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJKU09OLVBhdGNoOiBtb2RpZnlpbmcgYF9fcHJvdG9fX2Agb3IgYGNvbnN0cnVjdG9yL3Byb3RvdHlwZWAgcHJvcCBpcyBiYW5uZWQgZm9yIHNlY3VyaXR5IHJlYXNvbnMsIGlmIHRoaXMgd2FzIG9uIHB1cnBvc2UsIHBsZWFzZSBzZXQgYGJhblByb3RvdHlwZU1vZGlmaWNhdGlvbnNgIGZsYWcgZmFsc2UgYW5kIHBhc3MgaXQgdG8gdGhpcyBmdW5jdGlvbi4gTW9yZSBpbmZvIGluIGZhc3QtanNvbi1wYXRjaCBSRUFETUVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdQYXRoRnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdQYXRoRnJhZ21lbnQgPSBrZXlzLnNsaWNlKDAsIHQpLmpvaW4oXCIvXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHQgPT0gbGVuIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdQYXRoRnJhZ21lbnQgPSBvcGVyYXRpb24ucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdQYXRoRnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbihvcGVyYXRpb24sIDAsIGRvY3VtZW50LCBleGlzdGluZ1BhdGhGcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0Kys7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gb2JqLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbiAmJiAhaXNJbnRlZ2VyKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIkV4cGVjdGVkIGFuIHVuc2lnbmVkIGJhc2UtMTAgaW50ZWdlciB2YWx1ZSwgbWFraW5nIHRoZSBuZXcgcmVmZXJlbmNlZCB2YWx1ZSB0aGUgYXJyYXkgZWxlbWVudCB3aXRoIHRoZSB6ZXJvLWJhc2VkIGluZGV4XCIsIFwiT1BFUkFUSU9OX1BBVEhfSUxMRUdBTF9BUlJBWV9JTkRFWFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0gLy8gb25seSBwYXJzZSBrZXkgd2hlbiBpdCdzIGFuIGludGVnZXIgZm9yIGBhcnIucHJvcGAgdG8gd29ya1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0ludGVnZXIoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gfn5rZXk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQgPj0gbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbiAmJiBvcGVyYXRpb24ub3AgPT09IFwiYWRkXCIgJiYga2V5ID4gb2JqLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiVGhlIHNwZWNpZmllZCBpbmRleCBNVVNUIE5PVCBiZSBncmVhdGVyIHRoYW4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXlcIiwgXCJPUEVSQVRJT05fVkFMVUVfT1VUX09GX0JPVU5EU1wiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSBhcnJPcHNbb3BlcmF0aW9uLm9wXS5jYWxsKG9wZXJhdGlvbiwgb2JqLCBrZXksIGRvY3VtZW50KTsgLy8gQXBwbHkgcGF0Y2hcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlLnRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJUZXN0IG9wZXJhdGlvbiBmYWlsZWRcIiwgXCJURVNUX09QRVJBVElPTl9GQUlMRURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodCA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSBvYmpPcHNbb3BlcmF0aW9uLm9wXS5jYWxsKG9wZXJhdGlvbiwgb2JqLCBrZXksIGRvY3VtZW50KTsgLy8gQXBwbHkgcGF0Y2hcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlLnRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJUZXN0IG9wZXJhdGlvbiBmYWlsZWRcIiwgXCJURVNUX09QRVJBVElPTl9GQUlMRURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmogPSBvYmpba2V5XTtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgbW9yZSBrZXlzIGluIHRoZSBwYXRoLCBidXQgdGhlIG5leHQgdmFsdWUgaXNuJ3QgYSBub24tbnVsbCBvYmplY3QsXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBPUEVSQVRJT05fUEFUSF9VTlJFU09MVkFCTEUgZXJyb3IgaW5zdGVhZCBvZiBpdGVyYXRpbmcgYWdhaW4uXG4gICAgICAgICAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24gJiYgdCA8IGxlbiAmJiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIkNhbm5vdCBwZXJmb3JtIG9wZXJhdGlvbiBhdCB0aGUgZGVzaXJlZCBwYXRoXCIsIFwiT1BFUkFUSU9OX1BBVEhfVU5SRVNPTFZBQkxFXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQXBwbHkgYSBmdWxsIEpTT04gUGF0Y2ggYXJyYXkgb24gYSBKU09OIGRvY3VtZW50LlxuICogUmV0dXJucyB0aGUge25ld0RvY3VtZW50LCByZXN1bHR9IG9mIHRoZSBwYXRjaC5cbiAqIEl0IG1vZGlmaWVzIHRoZSBgZG9jdW1lbnRgIG9iamVjdCBhbmQgYHBhdGNoYCAtIGl0IGdldHMgdGhlIHZhbHVlcyBieSByZWZlcmVuY2UuXG4gKiBJZiB5b3Ugd291bGQgbGlrZSB0byBhdm9pZCB0b3VjaGluZyB5b3VyIHZhbHVlcywgY2xvbmUgdGhlbTpcbiAqIGBqc29ucGF0Y2guYXBwbHlQYXRjaChkb2N1bWVudCwganNvbnBhdGNoLl9kZWVwQ2xvbmUocGF0Y2gpKWAuXG4gKlxuICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBwYXRjaFxuICogQHBhcmFtIHBhdGNoIFRoZSBwYXRjaCB0byBhcHBseVxuICogQHBhcmFtIHZhbGlkYXRlT3BlcmF0aW9uIGBmYWxzZWAgaXMgd2l0aG91dCB2YWxpZGF0aW9uLCBgdHJ1ZWAgdG8gdXNlIGRlZmF1bHQganNvbnBhdGNoJ3MgdmFsaWRhdGlvbiwgb3IgeW91IGNhbiBwYXNzIGEgYHZhbGlkYXRlT3BlcmF0aW9uYCBjYWxsYmFjayB0byBiZSB1c2VkIGZvciB2YWxpZGF0aW9uLlxuICogQHBhcmFtIG11dGF0ZURvY3VtZW50IFdoZXRoZXIgdG8gbXV0YXRlIHRoZSBvcmlnaW5hbCBkb2N1bWVudCBvciBjbG9uZSBpdCBiZWZvcmUgYXBwbHlpbmdcbiAqIEBwYXJhbSBiYW5Qcm90b3R5cGVNb2RpZmljYXRpb25zIFdoZXRoZXIgdG8gYmFuIG1vZGlmaWNhdGlvbnMgdG8gYF9fcHJvdG9fX2AsIGRlZmF1bHRzIHRvIGB0cnVlYC5cbiAqIEByZXR1cm4gQW4gYXJyYXkgb2YgYHtuZXdEb2N1bWVudCwgcmVzdWx0fWAgYWZ0ZXIgdGhlIHBhdGNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVBhdGNoKGRvY3VtZW50LCBwYXRjaCwgdmFsaWRhdGVPcGVyYXRpb24sIG11dGF0ZURvY3VtZW50ID0gdHJ1ZSwgYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucyA9IHRydWUpIHtcbiAgICBpZiAodmFsaWRhdGVPcGVyYXRpb24pIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGNoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiUGF0Y2ggc2VxdWVuY2UgbXVzdCBiZSBhbiBhcnJheVwiLCBcIlNFUVVFTkNFX05PVF9BTl9BUlJBWVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW11dGF0ZURvY3VtZW50KSB7XG4gICAgICAgIGRvY3VtZW50ID0gX2RlZXBDbG9uZShkb2N1bWVudCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkocGF0Y2gubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gcGF0Y2gubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0byBwYXNzIG11dGF0ZURvY3VtZW50IGFyZ3VtZW50IGJlY2F1c2UgaWYgaXQgd2FzIHRydWUsIHdlIGFscmVhZHkgZGVlcCBjbG9uZWQgdGhlIG9iamVjdCwgd2UnbGwganVzdCBwYXNzIGB0cnVlYFxuICAgICAgICByZXN1bHRzW2ldID0gYXBwbHlPcGVyYXRpb24oZG9jdW1lbnQsIHBhdGNoW2ldLCB2YWxpZGF0ZU9wZXJhdGlvbiwgdHJ1ZSwgYmFuUHJvdG90eXBlTW9kaWZpY2F0aW9ucywgaSk7XG4gICAgICAgIGRvY3VtZW50ID0gcmVzdWx0c1tpXS5uZXdEb2N1bWVudDsgLy8gaW4gY2FzZSByb290IHdhcyByZXBsYWNlZFxuICAgIH1cbiAgICByZXN1bHRzLm5ld0RvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG4vKipcbiAqIEFwcGx5IGEgc2luZ2xlIEpTT04gUGF0Y2ggT3BlcmF0aW9uIG9uIGEgSlNPTiBkb2N1bWVudC5cbiAqIFJldHVybnMgdGhlIHVwZGF0ZWQgZG9jdW1lbnQuXG4gKiBTdWl0YWJsZSBhcyBhIHJlZHVjZXIuXG4gKlxuICogQHBhcmFtIGRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBwYXRjaFxuICogQHBhcmFtIG9wZXJhdGlvbiBUaGUgb3BlcmF0aW9uIHRvIGFwcGx5XG4gKiBAcmV0dXJuIFRoZSB1cGRhdGVkIGRvY3VtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVJlZHVjZXIoZG9jdW1lbnQsIG9wZXJhdGlvbiwgaW5kZXgpIHtcbiAgICBjb25zdCBvcGVyYXRpb25SZXN1bHQgPSBhcHBseU9wZXJhdGlvbihkb2N1bWVudCwgb3BlcmF0aW9uKTtcbiAgICBpZiAob3BlcmF0aW9uUmVzdWx0LnRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIGZhaWxlZCB0ZXN0XG4gICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIlRlc3Qgb3BlcmF0aW9uIGZhaWxlZFwiLCBcIlRFU1RfT1BFUkFUSU9OX0ZBSUxFRFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIHJldHVybiBvcGVyYXRpb25SZXN1bHQubmV3RG9jdW1lbnQ7XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIHNpbmdsZSBvcGVyYXRpb24uIENhbGxlZCBmcm9tIGBqc29ucGF0Y2gudmFsaWRhdGVgLiBUaHJvd3MgYEpzb25QYXRjaEVycm9yYCBpbiBjYXNlIG9mIGFuIGVycm9yLlxuICogQHBhcmFtIHtvYmplY3R9IG9wZXJhdGlvbiAtIG9wZXJhdGlvbiBvYmplY3QgKHBhdGNoKVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXggb2Ygb3BlcmF0aW9uIGluIHRoZSBzZXF1ZW5jZVxuICogQHBhcmFtIHtvYmplY3R9IFtkb2N1bWVudF0gLSBvYmplY3Qgd2hlcmUgdGhlIG9wZXJhdGlvbiBpcyBzdXBwb3NlZCB0byBiZSBhcHBsaWVkXG4gKiBAcGFyYW0ge3N0cmluZ30gW2V4aXN0aW5nUGF0aEZyYWdtZW50XSAtIGNvbWVzIGFsb25nIHdpdGggYGRvY3VtZW50YFxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdG9yKG9wZXJhdGlvbiwgaW5kZXgsIGRvY3VtZW50LCBleGlzdGluZ1BhdGhGcmFnbWVudCkge1xuICAgIGlmICh0eXBlb2Ygb3BlcmF0aW9uICE9PSBcIm9iamVjdFwiIHx8XG4gICAgICAgIG9wZXJhdGlvbiA9PT0gbnVsbCB8fFxuICAgICAgICBBcnJheS5pc0FycmF5KG9wZXJhdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiT3BlcmF0aW9uIGlzIG5vdCBhbiBvYmplY3RcIiwgXCJPUEVSQVRJT05fTk9UX0FOX09CSkVDVFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFvYmpPcHNbb3BlcmF0aW9uLm9wXSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJPcGVyYXRpb24gYG9wYCBwcm9wZXJ0eSBpcyBub3Qgb25lIG9mIG9wZXJhdGlvbnMgZGVmaW5lZCBpbiBSRkMtNjkwMlwiLCBcIk9QRVJBVElPTl9PUF9JTlZBTElEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9wZXJhdGlvbi5wYXRoICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIk9wZXJhdGlvbiBgcGF0aGAgcHJvcGVydHkgaXMgbm90IGEgc3RyaW5nXCIsIFwiT1BFUkFUSU9OX1BBVEhfSU5WQUxJRFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wZXJhdGlvbi5wYXRoLmluZGV4T2YoXCIvXCIpICE9PSAwICYmIG9wZXJhdGlvbi5wYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gcGF0aHMgdGhhdCBhcmVuJ3QgZW1wdHkgc3RyaW5nIHNob3VsZCBzdGFydCB3aXRoIFwiL1wiXG4gICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcignT3BlcmF0aW9uIGBwYXRoYCBwcm9wZXJ0eSBtdXN0IHN0YXJ0IHdpdGggXCIvXCInLCBcIk9QRVJBVElPTl9QQVRIX0lOVkFMSURcIiwgaW5kZXgsIG9wZXJhdGlvbiwgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICgob3BlcmF0aW9uLm9wID09PSBcIm1vdmVcIiB8fCBvcGVyYXRpb24ub3AgPT09IFwiY29weVwiKSAmJlxuICAgICAgICB0eXBlb2Ygb3BlcmF0aW9uLmZyb20gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiT3BlcmF0aW9uIGBmcm9tYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgbW92ZWAgYW5kIGBjb3B5YCBvcGVyYXRpb25zKVwiLCBcIk9QRVJBVElPTl9GUk9NX1JFUVVJUkVEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKG9wZXJhdGlvbi5vcCA9PT0gXCJhZGRcIiB8fFxuICAgICAgICBvcGVyYXRpb24ub3AgPT09IFwicmVwbGFjZVwiIHx8XG4gICAgICAgIG9wZXJhdGlvbi5vcCA9PT0gXCJ0ZXN0XCIpICYmXG4gICAgICAgIG9wZXJhdGlvbi52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIk9wZXJhdGlvbiBgdmFsdWVgIHByb3BlcnR5IGlzIG5vdCBwcmVzZW50IChhcHBsaWNhYmxlIGluIGBhZGRgLCBgcmVwbGFjZWAgYW5kIGB0ZXN0YCBvcGVyYXRpb25zKVwiLCBcIk9QRVJBVElPTl9WQUxVRV9SRVFVSVJFRFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChvcGVyYXRpb24ub3AgPT09IFwiYWRkXCIgfHxcbiAgICAgICAgb3BlcmF0aW9uLm9wID09PSBcInJlcGxhY2VcIiB8fFxuICAgICAgICBvcGVyYXRpb24ub3AgPT09IFwidGVzdFwiKSAmJlxuICAgICAgICBoYXNVbmRlZmluZWQob3BlcmF0aW9uLnZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJPcGVyYXRpb24gYHZhbHVlYCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCAoYXBwbGljYWJsZSBpbiBgYWRkYCwgYHJlcGxhY2VgIGFuZCBgdGVzdGAgb3BlcmF0aW9ucylcIiwgXCJPUEVSQVRJT05fVkFMVUVfQ0FOTk9UX0NPTlRBSU5fVU5ERUZJTkVEXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCA9PSBcImFkZFwiKSB7XG4gICAgICAgICAgICB2YXIgcGF0aExlbiA9IG9wZXJhdGlvbi5wYXRoLnNwbGl0KFwiL1wiKS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdQYXRoTGVuID0gZXhpc3RpbmdQYXRoRnJhZ21lbnQuc3BsaXQoXCIvXCIpLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwYXRoTGVuICE9PSBleGlzdGluZ1BhdGhMZW4gKyAxICYmIHBhdGhMZW4gIT09IGV4aXN0aW5nUGF0aExlbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUGF0Y2hFcnJvcihcIkNhbm5vdCBwZXJmb3JtIGFuIGBhZGRgIG9wZXJhdGlvbiBhdCB0aGUgZGVzaXJlZCBwYXRoXCIsIFwiT1BFUkFUSU9OX1BBVEhfQ0FOTk9UX0FERFwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcInJlcGxhY2VcIiB8fFxuICAgICAgICAgICAgb3BlcmF0aW9uLm9wID09PSBcInJlbW92ZVwiIHx8XG4gICAgICAgICAgICBvcGVyYXRpb24ub3AgPT09IFwiX2dldFwiKSB7XG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLnBhdGggIT09IGV4aXN0aW5nUGF0aEZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiQ2Fubm90IHBlcmZvcm0gdGhlIG9wZXJhdGlvbiBhdCBhIHBhdGggdGhhdCBkb2VzIG5vdCBleGlzdFwiLCBcIk9QRVJBVElPTl9QQVRIX1VOUkVTT0xWQUJMRVwiLCBpbmRleCwgb3BlcmF0aW9uLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcIm1vdmVcIiB8fCBvcGVyYXRpb24ub3AgPT09IFwiY29weVwiKSB7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IHtcbiAgICAgICAgICAgICAgICBvcDogXCJfZ2V0XCIsXG4gICAgICAgICAgICAgICAgcGF0aDogb3BlcmF0aW9uLmZyb20sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSB2YWxpZGF0ZShbZXhpc3RpbmdWYWx1ZV0sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5uYW1lID09PSBcIk9QRVJBVElPTl9QQVRIX1VOUkVTT0xWQUJMRVwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25QYXRjaEVycm9yKFwiQ2Fubm90IHBlcmZvcm0gdGhlIG9wZXJhdGlvbiBmcm9tIGEgcGF0aCB0aGF0IGRvZXMgbm90IGV4aXN0XCIsIFwiT1BFUkFUSU9OX0ZST01fVU5SRVNPTFZBQkxFXCIsIGluZGV4LCBvcGVyYXRpb24sIGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogVmFsaWRhdGVzIGEgc2VxdWVuY2Ugb2Ygb3BlcmF0aW9ucy4gSWYgYGRvY3VtZW50YCBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIHRoZSBzZXF1ZW5jZSBpcyBhZGRpdGlvbmFsbHkgdmFsaWRhdGVkIGFnYWluc3QgdGhlIG9iamVjdCBkb2N1bWVudC5cbiAqIElmIGVycm9yIGlzIGVuY291bnRlcmVkLCByZXR1cm5zIGEgSnNvblBhdGNoRXJyb3Igb2JqZWN0XG4gKiBAcGFyYW0gc2VxdWVuY2VcbiAqIEBwYXJhbSBkb2N1bWVudFxuICogQHJldHVybnMge0pzb25QYXRjaEVycm9yfHVuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKHNlcXVlbmNlLCBkb2N1bWVudCwgZXh0ZXJuYWxWYWxpZGF0b3IpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2VxdWVuY2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSnNvblBhdGNoRXJyb3IoXCJQYXRjaCBzZXF1ZW5jZSBtdXN0IGJlIGFuIGFycmF5XCIsIFwiU0VRVUVOQ0VfTk9UX0FOX0FSUkFZXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb2N1bWVudCkge1xuICAgICAgICAgICAgLy9jbG9uZSBkb2N1bWVudCBhbmQgc2VxdWVuY2Ugc28gdGhhdCB3ZSBjYW4gc2FmZWx5IHRyeSBhcHBseWluZyBvcGVyYXRpb25zXG4gICAgICAgICAgICBhcHBseVBhdGNoKF9kZWVwQ2xvbmUoZG9jdW1lbnQpLCBfZGVlcENsb25lKHNlcXVlbmNlKSwgZXh0ZXJuYWxWYWxpZGF0b3IgfHwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleHRlcm5hbFZhbGlkYXRvciA9IGV4dGVybmFsVmFsaWRhdG9yIHx8IHZhbGlkYXRvcjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VxdWVuY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBleHRlcm5hbFZhbGlkYXRvcihzZXF1ZW5jZVtpXSwgaSwgZG9jdW1lbnQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBKc29uUGF0Y2hFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Vwb2JlcmV6a2luL2Zhc3QtZGVlcC1lcXVhbFxuLy8gTUlUIExpY2Vuc2Vcbi8vIENvcHlyaWdodCAoYykgMjAxNyBFdmdlbnkgUG9iZXJlemtpblxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4vLyBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuLy8gU09GVFdBUkUuXG5leHBvcnQgZnVuY3Rpb24gX2FyZUVxdWFscyhhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgYiA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciBhcnJBID0gQXJyYXkuaXNBcnJheShhKSwgYXJyQiA9IEFycmF5LmlzQXJyYXkoYiksIGksIGxlbmd0aCwga2V5O1xuICAgICAgICBpZiAoYXJyQSAmJiBhcnJCKSB7XG4gICAgICAgICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICAgICAgICAgIGlmICghX2FyZUVxdWFscyhhW2ldLCBiW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyckEgIT0gYXJyQilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICAgICAgaWYgKCFiLmhhc093blByb3BlcnR5KGtleXNbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKCFfYXJlRXF1YWxzKGFba2V5XSwgYltrZXldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBhICE9PSBhICYmIGIgIT09IGI7XG59XG4iLCAiLy8gQHRzLW5vY2hlY2tcbi8vIElubGluZWQgYmVjYXVzZSBvZiBFU00gaW1wb3J0IGlzc3Vlc1xuLyohXG4gKiBodHRwczovL2dpdGh1Yi5jb20vU3RhcmNvdW50ZXItSmFjay9KU09OLVBhdGNoXG4gKiAoYykgMjAxNy0yMDIyIEpvYWNoaW0gV2VzdGVyXG4gKiBNSVQgbGljZW5zZWRcbiAqL1xuY29uc3QgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmV4cG9ydCBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIGtleSkge1xuICAgIHJldHVybiBfaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5leHBvcnQgZnVuY3Rpb24gX29iamVjdEtleXMob2JqKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICBjb25zdCBrZXlzID0gbmV3IEFycmF5KG9iai5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGtleXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGtleXNba10gPSBcIlwiICsgaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopO1xuICAgIH1cbiAgICBsZXQga2V5cyA9IFtdO1xuICAgIGZvciAobGV0IGkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShvYmosIGkpKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59XG4vKipcbiAqIERlZXBseSBjbG9uZSB0aGUgb2JqZWN0LlxuICogaHR0cHM6Ly9qc3BlcmYuY29tL2RlZXAtY29weS12cy1qc29uLXN0cmluZ2lmeS1qc29uLXBhcnNlLzI1IChyZWN1cnNpdmVEZWVwQ29weSlcbiAqIEBwYXJhbSAge2FueX0gb2JqIHZhbHVlIHRvIGNsb25lXG4gKiBAcmV0dXJuIHthbnl9IGNsb25lZCBvYmpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9kZWVwQ2xvbmUob2JqKSB7XG4gICAgc3dpdGNoICh0eXBlb2Ygb2JqKSB7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpOyAvL0Zhc3RlciB0aGFuIEVTNSBjbG9uZSAtIGh0dHA6Ly9qc3BlcmYuY29tL2RlZXAtY2xvbmluZy1vZi1vYmplY3RzLzVcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vdGhpcyBpcyBob3cgSlNPTi5zdHJpbmdpZnkgYmVoYXZlcyBmb3IgYXJyYXkgaXRlbXNcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBvYmo7IC8vbm8gbmVlZCB0byBjbG9uZSBwcmltaXRpdmVzXG4gICAgfVxufVxuLy8zeCBmYXN0ZXIgdGhhbiBjYWNoZWQgL15cXGQrJC8udGVzdChzdHIpXG5leHBvcnQgZnVuY3Rpb24gaXNJbnRlZ2VyKHN0cikge1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIGxldCBjaGFyQ29kZTtcbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEVzY2FwZXMgYSBqc29uIHBvaW50ZXIgcGF0aFxuICogQHBhcmFtIHBhdGggVGhlIHJhdyBwb2ludGVyXG4gKiBAcmV0dXJuIHRoZSBFc2NhcGVkIHBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZVBhdGhDb21wb25lbnQocGF0aCkge1xuICAgIGlmIChwYXRoLmluZGV4T2YoXCIvXCIpID09PSAtMSAmJiBwYXRoLmluZGV4T2YoXCJ+XCIpID09PSAtMSlcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcLy9nLCBcIn4xXCIpO1xufVxuLyoqXG4gKiBVbmVzY2FwZXMgYSBqc29uIHBvaW50ZXIgcGF0aFxuICogQHBhcmFtIHBhdGggVGhlIGVzY2FwZWQgcG9pbnRlclxuICogQHJldHVybiBUaGUgdW5lc2NhcGVkIHBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuZXNjYXBlUGF0aENvbXBvbmVudChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvfjEvZywgXCIvXCIpLnJlcGxhY2UoL34wL2csIFwiflwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0UGF0aFJlY3Vyc2l2ZShyb290LCBvYmopIHtcbiAgICBsZXQgZm91bmQ7XG4gICAgZm9yIChsZXQga2V5IGluIHJvb3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5KHJvb3QsIGtleSkpIHtcbiAgICAgICAgICAgIGlmIChyb290W2tleV0gPT09IG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlc2NhcGVQYXRoQ29tcG9uZW50KGtleSkgKyBcIi9cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiByb290W2tleV0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IF9nZXRQYXRoUmVjdXJzaXZlKHJvb3Rba2V5XSwgb2JqKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgIT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXNjYXBlUGF0aENvbXBvbmVudChrZXkpICsgXCIvXCIgKyBmb3VuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UGF0aChyb290LCBvYmopIHtcbiAgICBpZiAocm9vdCA9PT0gb2JqKSB7XG4gICAgICAgIHJldHVybiBcIi9cIjtcbiAgICB9XG4gICAgY29uc3QgcGF0aCA9IF9nZXRQYXRoUmVjdXJzaXZlKHJvb3QsIG9iaik7XG4gICAgaWYgKHBhdGggPT09IFwiXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0IG5vdCBmb3VuZCBpbiByb290XCIpO1xuICAgIH1cbiAgICByZXR1cm4gYC8ke3BhdGh9YDtcbn1cbi8qKlxuICogUmVjdXJzaXZlbHkgY2hlY2tzIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhbnkgdW5kZWZpbmVkIHZhbHVlcyBpbnNpZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNVbmRlZmluZWQob2JqKSB7XG4gICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAob2JqKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzVW5kZWZpbmVkKG9ialtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG9iaktleXMgPSBfb2JqZWN0S2V5cyhvYmopO1xuICAgICAgICAgICAgY29uc3Qgb2JqS2V5c0xlbmd0aCA9IG9iaktleXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmpLZXlzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzVW5kZWZpbmVkKG9ialtvYmpLZXlzW2ldXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHBhdGNoRXJyb3JNZXNzYWdlRm9ybWF0dGVyKG1lc3NhZ2UsIGFyZ3MpIHtcbiAgICBjb25zdCBtZXNzYWdlUGFydHMgPSBbbWVzc2FnZV07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXJncykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHR5cGVvZiBhcmdzW2tleV0gPT09IFwib2JqZWN0XCJcbiAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkoYXJnc1trZXldLCBudWxsLCAyKVxuICAgICAgICAgICAgOiBhcmdzW2tleV07IC8vIHByZXR0eSBwcmludFxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBtZXNzYWdlUGFydHMucHVzaChgJHtrZXl9OiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlUGFydHMuam9pbihcIlxcblwiKTtcbn1cbmV4cG9ydCBjbGFzcyBQYXRjaEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG5hbWUsIGluZGV4LCBvcGVyYXRpb24sIHRyZWUpIHtcbiAgICAgICAgc3VwZXIocGF0Y2hFcnJvck1lc3NhZ2VGb3JtYXR0ZXIobWVzc2FnZSwgeyBuYW1lLCBpbmRleCwgb3BlcmF0aW9uLCB0cmVlIH0pKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5kZXhcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGluZGV4XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvcGVyYXRpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG9wZXJhdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJlZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJlZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTsgLy8gcmVzdG9yZSBwcm90b3R5cGUgY2hhaW4sIHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDgzNDIzNTlcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gcGF0Y2hFcnJvck1lc3NhZ2VGb3JtYXR0ZXIobWVzc2FnZSwge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICAgICAgdHJlZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwgImV4cG9ydCAqIGZyb20gXCIuL3NyYy9jb3JlLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zcmMvZHVwbGV4LmpzXCI7XG5leHBvcnQgeyBQYXRjaEVycm9yIGFzIEpzb25QYXRjaEVycm9yLCBfZGVlcENsb25lIGFzIGRlZXBDbG9uZSwgZXNjYXBlUGF0aENvbXBvbmVudCwgdW5lc2NhcGVQYXRoQ29tcG9uZW50LCB9IGZyb20gXCIuL3NyYy9oZWxwZXJzLmpzXCI7XG4vKipcbiAqIERlZmF1bHQgZXhwb3J0IGZvciBiYWNrd2FyZHMgY29tcGF0XG4gKi9cbmltcG9ydCAqIGFzIGNvcmUgZnJvbSBcIi4vc3JjL2NvcmUuanNcIjtcbmltcG9ydCB7IFBhdGNoRXJyb3IgYXMgSnNvblBhdGNoRXJyb3IsIF9kZWVwQ2xvbmUgYXMgZGVlcENsb25lLCBlc2NhcGVQYXRoQ29tcG9uZW50LCB1bmVzY2FwZVBhdGhDb21wb25lbnQsIH0gZnJvbSBcIi4vc3JjL2hlbHBlcnMuanNcIjtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgICAuLi5jb3JlLFxuICAgIC8vIC4uLmR1cGxleCxcbiAgICBKc29uUGF0Y2hFcnJvcixcbiAgICBkZWVwQ2xvbmUsXG4gICAgZXNjYXBlUGF0aENvbXBvbmVudCxcbiAgICB1bmVzY2FwZVBhdGhDb21wb25lbnQsXG59O1xuIiwgIi8qXG4gKiBTdXBwb3J0IGFzeW5jIGl0ZXJhdG9yIHN5bnRheCBmb3IgUmVhZGFibGVTdHJlYW1zIGluIGFsbCBlbnZpcm9ubWVudHMuXG4gKiBTb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9NYXR0aWFzQnVlbGVucy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9wdWxsLzEyMiNpc3N1ZWNvbW1lbnQtMTYyNzM1NDQ5MFxuICovXG5leHBvcnQgY2xhc3MgSXRlcmFibGVSZWFkYWJsZVN0cmVhbSBleHRlbmRzIFJlYWRhYmxlU3RyZWFtIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVhZGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVuc3VyZVJlYWRlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlYWRlcikge1xuICAgICAgICAgICAgdGhpcy5yZWFkZXIgPSB0aGlzLmdldFJlYWRlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlUmVhZGVyKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRlci5yZWxlYXNlTG9jaygpOyAvLyByZWxlYXNlIGxvY2sgd2hlbiBzdHJlYW0gYmVjb21lcyBjbG9zZWRcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRlci5yZWxlYXNlTG9jaygpOyAvLyByZWxlYXNlIGxvY2sgd2hlbiBzdHJlYW0gYmVjb21lcyBlcnJvcmVkXG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJldHVybigpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVSZWFkZXIoKTtcbiAgICAgICAgLy8gSWYgd3JhcHBlZCBpbiBhIE5vZGUgc3RyZWFtLCBjYW5jZWwgaXMgYWxyZWFkeSBjYWxsZWQuXG4gICAgICAgIGlmICh0aGlzLmxvY2tlZCkge1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsUHJvbWlzZSA9IHRoaXMucmVhZGVyLmNhbmNlbCgpOyAvLyBjYW5jZWwgZmlyc3QsIGJ1dCBkb24ndCBhd2FpdCB5ZXRcbiAgICAgICAgICAgIHRoaXMucmVhZGVyLnJlbGVhc2VMb2NrKCk7IC8vIHJlbGVhc2UgbG9jayBmaXJzdFxuICAgICAgICAgICAgYXdhaXQgY2FuY2VsUHJvbWlzZTsgLy8gbm93IGF3YWl0IGl0XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGFzeW5jIHRocm93KGUpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVSZWFkZXIoKTtcbiAgICAgICAgaWYgKHRoaXMubG9ja2VkKSB7XG4gICAgICAgICAgICBjb25zdCBjYW5jZWxQcm9taXNlID0gdGhpcy5yZWFkZXIuY2FuY2VsKCk7IC8vIGNhbmNlbCBmaXJzdCwgYnV0IGRvbid0IGF3YWl0IHlldFxuICAgICAgICAgICAgdGhpcy5yZWFkZXIucmVsZWFzZUxvY2soKTsgLy8gcmVsZWFzZSBsb2NrIGZpcnN0XG4gICAgICAgICAgICBhd2FpdCBjYW5jZWxQcm9taXNlOyAvLyBub3cgYXdhaXQgaXRcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RhdGljIGZyb21SZWFkYWJsZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgLy8gRnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU3RyZWFtc19BUEkvVXNpbmdfcmVhZGFibGVfc3RyZWFtcyNyZWFkaW5nX3RoZV9zdHJlYW1cbiAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgICByZXR1cm4gbmV3IEl0ZXJhYmxlUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwdW1wKCk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcHVtcCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkKCkudGhlbigoeyBkb25lLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIG5vIG1vcmUgZGF0YSBuZWVkcyB0byBiZSBjb25zdW1lZCwgY2xvc2UgdGhlIHN0cmVhbVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5xdWV1ZSB0aGUgbmV4dCBkYXRhIGNodW5rIGludG8gb3VyIHRhcmdldCBzdHJlYW1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHVtcCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FuY2VsKCkge1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQXN5bmNHZW5lcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgSXRlcmFibGVSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCBnZW5lcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gbm8gbW9yZSBkYXRhIG5lZWRzIHRvIGJlIGNvbnN1bWVkLCBjbG9zZSB0aGUgc3RyZWFtXG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGaXg6IGBlbHNlIGlmICh2YWx1ZSlgIHdpbGwgaGFuZyB0aGUgc3RyZWFtaW5nIHdoZW4gbnVsbGlzaCB2YWx1ZSAoZS5nLiBlbXB0eSBzdHJpbmcpIGlzIHB1bGxlZFxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXN5bmMgY2FuY2VsKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IGdlbmVyYXRvci5yZXR1cm4ocmVhc29uKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBhdGVlKGl0ZXIsIGxlbmd0aCA9IDIpIHtcbiAgICBjb25zdCBidWZmZXJzID0gQXJyYXkuZnJvbSh7IGxlbmd0aCB9LCAoKSA9PiBbXSk7XG4gICAgcmV0dXJuIGJ1ZmZlcnMubWFwKGFzeW5jIGZ1bmN0aW9uKiBtYWtlSXRlcihidWZmZXIpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaXRlci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBidWZmZXIgb2YgYnVmZmVycykge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJ1ZmZlclswXS5kb25lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICB5aWVsZCBidWZmZXIuc2hpZnQoKS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdChmaXJzdCwgc2Vjb25kKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmlyc3QpICYmIEFycmF5LmlzQXJyYXkoc2Vjb25kKSkge1xuICAgICAgICByZXR1cm4gZmlyc3QuY29uY2F0KHNlY29uZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBmaXJzdCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygc2Vjb25kID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiAoZmlyc3QgKyBzZWNvbmQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZmlyc3QgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHNlY29uZCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gKGZpcnN0ICsgc2Vjb25kKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBcImNvbmNhdFwiIGluIGZpcnN0ICYmXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHR5cGVvZiBmaXJzdC5jb25jYXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICByZXR1cm4gZmlyc3QuY29uY2F0KHNlY29uZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBmaXJzdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygc2Vjb25kID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IGNodW5rID0geyAuLi5maXJzdCB9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzZWNvbmQpKSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluIGNodW5rICYmICFBcnJheS5pc0FycmF5KGNodW5rW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgY2h1bmtba2V5XSA9IGNvbmNhdChjaHVua1trZXldLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaHVua1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNodW5rO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY29uY2F0ICR7dHlwZW9mIGZpcnN0fSBhbmQgJHt0eXBlb2Ygc2Vjb25kfWApO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBc3luY0dlbmVyYXRvcldpdGhTZXR1cCB7XG4gICAgY29uc3RydWN0b3IoZ2VuZXJhdG9yLCBzdGFydFNldHVwKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdlbmVyYXRvclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXR1cFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmaXJzdFJlc3VsdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmaXJzdFJlc3VsdFVzZWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdlbmVyYXRvciA9IGdlbmVyYXRvcjtcbiAgICAgICAgLy8gc2V0dXAgaXMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25seSBhZnRlciB0aGUgZmlyc3QgaXRlcmF0b3IgdmFsdWVcbiAgICAgICAgLy8gaXMgYXZhaWxhYmxlLiB0aGlzIGlzIHVzZWZ1bCB3aGVuIHNldHVwIG9mIHNldmVyYWwgcGlwZWQgZ2VuZXJhdG9yc1xuICAgICAgICAvLyBuZWVkcyB0byBoYXBwZW4gaW4gbG9naWNhbCBvcmRlciwgaWUuIGluIHRoZSBvcmRlciBpbiB3aGljaCBpbnB1dCB0b1xuICAgICAgICAvLyB0byBlYWNoIGdlbmVyYXRvciBpcyBhdmFpbGFibGUuXG4gICAgICAgIHRoaXMuc2V0dXAgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0UmVzdWx0ID0gZ2VuZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChzdGFydFNldHVwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdFJlc3VsdC50aGVuKHN0YXJ0U2V0dXApLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RSZXN1bHQudGhlbigoX3Jlc3VsdCkgPT4gcmVzb2x2ZSh1bmRlZmluZWQpLCByZWplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgbmV4dCguLi5hcmdzKSB7XG4gICAgICAgIGlmICghdGhpcy5maXJzdFJlc3VsdFVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RSZXN1bHRVc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpcnN0UmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRvci5uZXh0KC4uLmFyZ3MpO1xuICAgIH1cbiAgICBhc3luYyByZXR1cm4odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdG9yLnJldHVybih2YWx1ZSk7XG4gICAgfVxuICAgIGFzeW5jIHRocm93KGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdG9yLnRocm93KGUpO1xuICAgIH1cbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGlwZUdlbmVyYXRvcldpdGhTZXR1cCh0bywgZ2VuZXJhdG9yLCBzdGFydFNldHVwLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgZ2VuID0gbmV3IEFzeW5jR2VuZXJhdG9yV2l0aFNldHVwKGdlbmVyYXRvciwgc3RhcnRTZXR1cCk7XG4gICAgY29uc3Qgc2V0dXAgPSBhd2FpdCBnZW4uc2V0dXA7XG4gICAgcmV0dXJuIHsgb3V0cHV0OiB0byhnZW4sIHNldHVwLCAuLi5hcmdzKSwgc2V0dXAgfTtcbn1cbiIsICJpbXBvcnQgeyBhcHBseVBhdGNoLCB9IGZyb20gXCIuLi91dGlscy9mYXN0LWpzb24tcGF0Y2gvaW5kZXguanNcIjtcbmltcG9ydCB7IEJhc2VUcmFjZXIgfSBmcm9tIFwiLi9iYXNlLmpzXCI7XG5pbXBvcnQgeyBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtIH0gZnJvbSBcIi4uL3V0aWxzL3N0cmVhbS5qc1wiO1xuaW1wb3J0IHsgQUlNZXNzYWdlQ2h1bmsgfSBmcm9tIFwiLi4vbWVzc2FnZXMvaW5kZXguanNcIjtcbi8qKlxuICogTGlzdCBvZiBqc29ucGF0Y2ggSlNPTlBhdGNoT3BlcmF0aW9ucywgd2hpY2ggZGVzY3JpYmUgaG93IHRvIGNyZWF0ZSB0aGUgcnVuIHN0YXRlXG4gKiBmcm9tIGFuIGVtcHR5IGRpY3QuIFRoaXMgaXMgdGhlIG1pbmltYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGxvZywgZGVzaWduZWQgdG9cbiAqIGJlIHNlcmlhbGl6ZWQgYXMgSlNPTiBhbmQgc2VudCBvdmVyIHRoZSB3aXJlIHRvIHJlY29uc3RydWN0IHRoZSBsb2cgb24gdGhlIG90aGVyXG4gKiBzaWRlLiBSZWNvbnN0cnVjdGlvbiBvZiB0aGUgc3RhdGUgY2FuIGJlIGRvbmUgd2l0aCBhbnkganNvbnBhdGNoLWNvbXBsaWFudCBsaWJyYXJ5LFxuICogc2VlIGh0dHBzOi8vanNvbnBhdGNoLmNvbSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFJ1bkxvZ1BhdGNoIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib3BzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub3BzID0gZmllbGRzLm9wcyA/PyBbXTtcbiAgICB9XG4gICAgY29uY2F0KG90aGVyKSB7XG4gICAgICAgIGNvbnN0IG9wcyA9IHRoaXMub3BzLmNvbmNhdChvdGhlci5vcHMpO1xuICAgICAgICBjb25zdCBzdGF0ZXMgPSBhcHBseVBhdGNoKHt9LCBvcHMpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgIHJldHVybiBuZXcgUnVuTG9nKHtcbiAgICAgICAgICAgIG9wcyxcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZXNbc3RhdGVzLmxlbmd0aCAtIDFdLm5ld0RvY3VtZW50LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUnVuTG9nIGV4dGVuZHMgUnVuTG9nUGF0Y2gge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgICAgICBzdXBlcihmaWVsZHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0YXRlID0gZmllbGRzLnN0YXRlO1xuICAgIH1cbiAgICBjb25jYXQob3RoZXIpIHtcbiAgICAgICAgY29uc3Qgb3BzID0gdGhpcy5vcHMuY29uY2F0KG90aGVyLm9wcyk7XG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IGFwcGx5UGF0Y2godGhpcy5zdGF0ZSwgb3RoZXIub3BzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5Mb2coeyBvcHMsIHN0YXRlOiBzdGF0ZXNbc3RhdGVzLmxlbmd0aCAtIDFdLm5ld0RvY3VtZW50IH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVJ1bkxvZ1BhdGNoKHBhdGNoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IGFwcGx5UGF0Y2goe30sIHBhdGNoLm9wcyk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIG5ldyBSdW5Mb2coe1xuICAgICAgICAgICAgb3BzOiBwYXRjaC5vcHMsXG4gICAgICAgICAgICBzdGF0ZTogc3RhdGVzW3N0YXRlcy5sZW5ndGggLSAxXS5uZXdEb2N1bWVudCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBFeHRyYWN0IHN0YW5kYXJkaXplZCBpbnB1dHMgZnJvbSBhIHJ1bi5cbiAqXG4gKiBTdGFuZGFyZGl6ZXMgdGhlIGlucHV0cyBiYXNlZCBvbiB0aGUgdHlwZSBvZiB0aGUgcnVubmFibGUgdXNlZC5cbiAqXG4gKiBAcGFyYW0gcnVuIC0gUnVuIG9iamVjdFxuICogQHBhcmFtIHNjaGVtYUZvcm1hdCAtIFRoZSBzY2hlbWEgZm9ybWF0IHRvIHVzZS5cbiAqXG4gKiBAcmV0dXJucyBWYWxpZCBpbnB1dHMgYXJlIG9ubHkgZGljdC4gQnkgY29udmVudGlvbnMsIGlucHV0cyBhbHdheXMgcmVwcmVzZW50ZWRcbiAqIGludm9jYXRpb24gdXNpbmcgbmFtZWQgYXJndW1lbnRzLlxuICogQSBudWxsIG1lYW5zIHRoYXQgdGhlIGlucHV0IGlzIG5vdCB5ZXQga25vd24hXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9nZXRTdGFuZGFyZGl6ZWRJbnB1dHMocnVuLCBzY2hlbWFGb3JtYXQpIHtcbiAgICBpZiAoc2NoZW1hRm9ybWF0ID09PSBcIm9yaWdpbmFsXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRG8gbm90IGFzc2lnbiBpbnB1dHMgd2l0aCBvcmlnaW5hbCBzY2hlbWEgZHJvcCB0aGUga2V5IGZvciBub3cuIFwiICtcbiAgICAgICAgICAgIFwiV2hlbiBpbnB1dHMgYXJlIGFkZGVkIHRvIHN0cmVhbUxvZyB0aGV5IHNob3VsZCBiZSBhZGRlZCB3aXRoIFwiICtcbiAgICAgICAgICAgIFwic3RhbmRhcmRpemVkIHNjaGVtYSBmb3Igc3RyZWFtaW5nIGV2ZW50cy5cIik7XG4gICAgfVxuICAgIGNvbnN0IHsgaW5wdXRzIH0gPSBydW47XG4gICAgaWYgKFtcInJldHJpZXZlclwiLCBcImxsbVwiLCBcInByb21wdFwiXS5pbmNsdWRlcyhydW4ucnVuX3R5cGUpKSB7XG4gICAgICAgIHJldHVybiBpbnB1dHM7XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhpbnB1dHMpLmxlbmd0aCA9PT0gMSAmJiBpbnB1dHM/LmlucHV0ID09PSBcIlwiKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIG5ldyBzdHlsZSBjaGFpbnNcbiAgICAvLyBUaGVzZSBuZXN0IGFuIGFkZGl0aW9uYWwgJ2lucHV0JyBrZXkgaW5zaWRlIHRoZSAnaW5wdXRzJyB0byBtYWtlIHN1cmVcbiAgICAvLyB0aGUgaW5wdXQgaXMgYWx3YXlzIGEgZGljdC4gV2UgbmVlZCB0byB1bnBhY2sgYW5kIHVzZXIgdGhlIGlubmVyIHZhbHVlLlxuICAgIC8vIFdlIHNob3VsZCB0cnkgdG8gZml4IHRoaXMgaW4gUnVubmFibGVzIGFuZCBjYWxsYmFja3MvdHJhY2Vyc1xuICAgIC8vIFJ1bm5hYmxlcyBzaG91bGQgYmUgdXNpbmcgYSBudWxsIHR5cGUgaGVyZSBub3QgYSBwbGFjZWhvbGRlclxuICAgIC8vIGRpY3QuXG4gICAgcmV0dXJuIGlucHV0cy5pbnB1dDtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9nZXRTdGFuZGFyZGl6ZWRPdXRwdXRzKHJ1biwgc2NoZW1hRm9ybWF0KSB7XG4gICAgY29uc3QgeyBvdXRwdXRzIH0gPSBydW47XG4gICAgaWYgKHNjaGVtYUZvcm1hdCA9PT0gXCJvcmlnaW5hbFwiKSB7XG4gICAgICAgIC8vIFJldHVybiB0aGUgb2xkIHNjaGVtYSwgd2l0aG91dCBzdGFuZGFyZGl6aW5nIGFueXRoaW5nXG4gICAgICAgIHJldHVybiBvdXRwdXRzO1xuICAgIH1cbiAgICBpZiAoW1wicmV0cmlldmVyXCIsIFwibGxtXCIsIFwicHJvbXB0XCJdLmluY2x1ZGVzKHJ1bi5ydW5fdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgfVxuICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIGhhY2t5IGNoZWNrXG4gICAgaWYgKG91dHB1dHMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBPYmplY3Qua2V5cyhvdXRwdXRzKS5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgb3V0cHV0cz8ub3V0cHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dHMub3V0cHV0O1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0cztcbn1cbmZ1bmN0aW9uIGlzQ2hhdEdlbmVyYXRpb25DaHVuayh4KSB7XG4gICAgcmV0dXJuIHggIT09IHVuZGVmaW5lZCAmJiB4Lm1lc3NhZ2UgIT09IHVuZGVmaW5lZDtcbn1cbi8qKlxuICogQ2xhc3MgdGhhdCBleHRlbmRzIHRoZSBgQmFzZVRyYWNlcmAgY2xhc3MgZnJvbSB0aGVcbiAqIGBsYW5nY2hhaW4uY2FsbGJhY2tzLnRyYWNlcnMuYmFzZWAgbW9kdWxlLiBJdCByZXByZXNlbnRzIGEgY2FsbGJhY2tcbiAqIGhhbmRsZXIgdGhhdCBsb2dzIHRoZSBleGVjdXRpb24gb2YgcnVucyBhbmQgZW1pdHMgYFJ1bkxvZ2AgaW5zdGFuY2VzIHRvIGFcbiAqIGBSdW5Mb2dTdHJlYW1gLlxuICovXG5leHBvcnQgY2xhc3MgTG9nU3RyZWFtQ2FsbGJhY2tIYW5kbGVyIGV4dGVuZHMgQmFzZVRyYWNlciB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIHN1cGVyKGZpZWxkcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9DbG9zZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5jbHVkZU5hbWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluY2x1ZGVUeXBlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmNsdWRlVGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGNsdWRlTmFtZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhjbHVkZVR5cGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4Y2x1ZGVUYWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zY2hlbWFGb3JtYXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwib3JpZ2luYWxcIlxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicm9vdElkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImtleU1hcEJ5UnVuSWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb3VudGVyTWFwQnlSdW5OYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhbnNmb3JtU3RyZWFtXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndyaXRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWNlaXZlU3RyZWFtXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFwibG9nX3N0cmVhbV90cmFjZXJcIlxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hdXRvQ2xvc2UgPSBmaWVsZHM/LmF1dG9DbG9zZSA/PyB0cnVlO1xuICAgICAgICB0aGlzLmluY2x1ZGVOYW1lcyA9IGZpZWxkcz8uaW5jbHVkZU5hbWVzO1xuICAgICAgICB0aGlzLmluY2x1ZGVUeXBlcyA9IGZpZWxkcz8uaW5jbHVkZVR5cGVzO1xuICAgICAgICB0aGlzLmluY2x1ZGVUYWdzID0gZmllbGRzPy5pbmNsdWRlVGFncztcbiAgICAgICAgdGhpcy5leGNsdWRlTmFtZXMgPSBmaWVsZHM/LmV4Y2x1ZGVOYW1lcztcbiAgICAgICAgdGhpcy5leGNsdWRlVHlwZXMgPSBmaWVsZHM/LmV4Y2x1ZGVUeXBlcztcbiAgICAgICAgdGhpcy5leGNsdWRlVGFncyA9IGZpZWxkcz8uZXhjbHVkZVRhZ3M7XG4gICAgICAgIHRoaXMuX3NjaGVtYUZvcm1hdCA9IGZpZWxkcz8uX3NjaGVtYUZvcm1hdCA/PyB0aGlzLl9zY2hlbWFGb3JtYXQ7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtU3RyZWFtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSgpO1xuICAgICAgICB0aGlzLndyaXRlciA9IHRoaXMudHJhbnNmb3JtU3RyZWFtLndyaXRhYmxlLmdldFdyaXRlcigpO1xuICAgICAgICB0aGlzLnJlY2VpdmVTdHJlYW0gPSBJdGVyYWJsZVJlYWRhYmxlU3RyZWFtLmZyb21SZWFkYWJsZVN0cmVhbSh0aGlzLnRyYW5zZm9ybVN0cmVhbS5yZWFkYWJsZSk7XG4gICAgfVxuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVTdHJlYW07XG4gICAgfVxuICAgIGFzeW5jIHBlcnNpc3RSdW4oX3J1bikge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbGVnYWN5IG1ldGhvZCBvbmx5IGNhbGxlZCBvbmNlIGZvciBhbiBlbnRpcmUgcnVuIHRyZWVcbiAgICAgICAgLy8gYW5kIGlzIHRoZXJlZm9yZSBub3QgdXNlZnVsIGhlcmVcbiAgICB9XG4gICAgX2luY2x1ZGVSdW4ocnVuKSB7XG4gICAgICAgIGlmIChydW4uaWQgPT09IHRoaXMucm9vdElkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVuVGFncyA9IHJ1bi50YWdzID8/IFtdO1xuICAgICAgICBsZXQgaW5jbHVkZSA9IHRoaXMuaW5jbHVkZU5hbWVzID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuaW5jbHVkZVRhZ3MgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdGhpcy5pbmNsdWRlVHlwZXMgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZU5hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlIHx8IHRoaXMuaW5jbHVkZU5hbWVzLmluY2x1ZGVzKHJ1bi5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmNsdWRlVHlwZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9IGluY2x1ZGUgfHwgdGhpcy5pbmNsdWRlVHlwZXMuaW5jbHVkZXMocnVuLnJ1bl90eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmNsdWRlVGFncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID1cbiAgICAgICAgICAgICAgICBpbmNsdWRlIHx8XG4gICAgICAgICAgICAgICAgICAgIHJ1blRhZ3MuZmluZCgodGFnKSA9PiB0aGlzLmluY2x1ZGVUYWdzPy5pbmNsdWRlcyh0YWcpKSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSAmJiAhdGhpcy5leGNsdWRlTmFtZXMuaW5jbHVkZXMocnVuLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4Y2x1ZGVUeXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSAmJiAhdGhpcy5leGNsdWRlVHlwZXMuaW5jbHVkZXMocnVuLnJ1bl90eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leGNsdWRlVGFncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID1cbiAgICAgICAgICAgICAgICBpbmNsdWRlICYmIHJ1blRhZ3MuZXZlcnkoKHRhZykgPT4gIXRoaXMuZXhjbHVkZVRhZ3M/LmluY2x1ZGVzKHRhZykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmNsdWRlO1xuICAgIH1cbiAgICBhc3luYyAqdGFwT3V0cHV0SXRlcmFibGUocnVuSWQsIG91dHB1dCkge1xuICAgICAgICAvLyBUYXAgYW4gb3V0cHV0IGFzeW5jIGl0ZXJhdG9yIHRvIHN0cmVhbSBpdHMgdmFsdWVzIHRvIHRoZSBsb2cuXG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygb3V0cHV0KSB7XG4gICAgICAgICAgICAvLyByb290IHJ1biBpcyBoYW5kbGVkIGluIC5zdHJlYW1Mb2coKVxuICAgICAgICAgICAgaWYgKHJ1bklkICE9PSB0aGlzLnJvb3RJZCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGNhbid0IGZpbmQgdGhlIHJ1biBzaWxlbnRseSBpZ25vcmVcbiAgICAgICAgICAgICAgICAvLyBlZy4gYmVjYXVzZSB0aGlzIHJ1biB3YXNuJ3QgaW5jbHVkZWQgaW4gdGhlIGxvZ1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMua2V5TWFwQnlSdW5JZFtydW5JZF07XG4gICAgICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRlci53cml0ZShuZXcgUnVuTG9nUGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogYC9sb2dzLyR7a2V5fS9zdHJlYW1lZF9vdXRwdXQvLWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIGNodW5rO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG9uUnVuQ3JlYXRlKHJ1bikge1xuICAgICAgICBpZiAodGhpcy5yb290SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5yb290SWQgPSBydW4uaWQ7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRlci53cml0ZShuZXcgUnVuTG9nUGF0Y2goe1xuICAgICAgICAgICAgICAgIG9wczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcDogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogcnVuLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHJ1bi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHJ1bi5ydW5fdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1lZF9vdXRwdXQ6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsX291dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ3M6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faW5jbHVkZVJ1bihydW4pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY291bnRlck1hcEJ5UnVuTmFtZVtydW4ubmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jb3VudGVyTWFwQnlSdW5OYW1lW3J1bi5uYW1lXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb3VudGVyTWFwQnlSdW5OYW1lW3J1bi5uYW1lXSArPSAxO1xuICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMuY291bnRlck1hcEJ5UnVuTmFtZVtydW4ubmFtZV07XG4gICAgICAgIHRoaXMua2V5TWFwQnlSdW5JZFtydW4uaWRdID1cbiAgICAgICAgICAgIGNvdW50ID09PSAxID8gcnVuLm5hbWUgOiBgJHtydW4ubmFtZX06JHtjb3VudH1gO1xuICAgICAgICBjb25zdCBsb2dFbnRyeSA9IHtcbiAgICAgICAgICAgIGlkOiBydW4uaWQsXG4gICAgICAgICAgICBuYW1lOiBydW4ubmFtZSxcbiAgICAgICAgICAgIHR5cGU6IHJ1bi5ydW5fdHlwZSxcbiAgICAgICAgICAgIHRhZ3M6IHJ1bi50YWdzID8/IFtdLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHJ1bi5leHRyYT8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgICAgICBzdGFydF90aW1lOiBuZXcgRGF0ZShydW4uc3RhcnRfdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIHN0cmVhbWVkX291dHB1dDogW10sXG4gICAgICAgICAgICBzdHJlYW1lZF9vdXRwdXRfc3RyOiBbXSxcbiAgICAgICAgICAgIGZpbmFsX291dHB1dDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZW5kX3RpbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX3NjaGVtYUZvcm1hdCA9PT0gXCJzdHJlYW1pbmdfZXZlbnRzXCIpIHtcbiAgICAgICAgICAgIGxvZ0VudHJ5LmlucHV0cyA9IGF3YWl0IF9nZXRTdGFuZGFyZGl6ZWRJbnB1dHMocnVuLCB0aGlzLl9zY2hlbWFGb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMud3JpdGVyLndyaXRlKG5ldyBSdW5Mb2dQYXRjaCh7XG4gICAgICAgICAgICBvcHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBgL2xvZ3MvJHt0aGlzLmtleU1hcEJ5UnVuSWRbcnVuLmlkXX1gLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbG9nRW50cnksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgb25SdW5VcGRhdGUocnVuKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBydW5OYW1lID0gdGhpcy5rZXlNYXBCeVJ1bklkW3J1bi5pZF07XG4gICAgICAgICAgICBpZiAocnVuTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3BzID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy5fc2NoZW1hRm9ybWF0ID09PSBcInN0cmVhbWluZ19ldmVudHNcIikge1xuICAgICAgICAgICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgb3A6IFwicmVwbGFjZVwiLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBgL2xvZ3MvJHtydW5OYW1lfS9pbnB1dHNgLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYXdhaXQgX2dldFN0YW5kYXJkaXplZElucHV0cyhydW4sIHRoaXMuX3NjaGVtYUZvcm1hdCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3A6IFwiYWRkXCIsXG4gICAgICAgICAgICAgICAgcGF0aDogYC9sb2dzLyR7cnVuTmFtZX0vZmluYWxfb3V0cHV0YCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogYXdhaXQgX2dldFN0YW5kYXJkaXplZE91dHB1dHMocnVuLCB0aGlzLl9zY2hlbWFGb3JtYXQpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocnVuLmVuZF90aW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBgL2xvZ3MvJHtydW5OYW1lfS9lbmRfdGltZWAsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgRGF0ZShydW4uZW5kX3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXRjaCA9IG5ldyBSdW5Mb2dQYXRjaCh7IG9wcyB9KTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMud3JpdGVyLndyaXRlKHBhdGNoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChydW4uaWQgPT09IHRoaXMucm9vdElkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0Y2ggPSBuZXcgUnVuTG9nUGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICBvcHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcDogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogXCIvZmluYWxfb3V0cHV0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGF3YWl0IF9nZXRTdGFuZGFyZGl6ZWRPdXRwdXRzKHJ1biwgdGhpcy5fc2NoZW1hRm9ybWF0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy53cml0ZXIud3JpdGUocGF0Y2gpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF1dG9DbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBvbkxMTU5ld1Rva2VuKHJ1biwgdG9rZW4sIGt3YXJncykge1xuICAgICAgICBjb25zdCBydW5OYW1lID0gdGhpcy5rZXlNYXBCeVJ1bklkW3J1bi5pZF07XG4gICAgICAgIGlmIChydW5OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgaGFja1xuICAgICAgICBjb25zdCBpc0NoYXRNb2RlbCA9IHJ1bi5pbnB1dHMubWVzc2FnZXMgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHN0cmVhbWVkT3V0cHV0VmFsdWU7XG4gICAgICAgIGlmIChpc0NoYXRNb2RlbCkge1xuICAgICAgICAgICAgaWYgKGlzQ2hhdEdlbmVyYXRpb25DaHVuayhrd2FyZ3M/LmNodW5rKSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbWVkT3V0cHV0VmFsdWUgPSBrd2FyZ3M/LmNodW5rO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtZWRPdXRwdXRWYWx1ZSA9IG5ldyBBSU1lc3NhZ2VDaHVuayh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJlYW1lZE91dHB1dFZhbHVlID0gdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF0Y2ggPSBuZXcgUnVuTG9nUGF0Y2goe1xuICAgICAgICAgICAgb3BzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogYC9sb2dzLyR7cnVuTmFtZX0vc3RyZWFtZWRfb3V0cHV0X3N0ci8tYCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRva2VuLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogYC9sb2dzLyR7cnVuTmFtZX0vc3RyZWFtZWRfb3V0cHV0Ly1gLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc3RyZWFtZWRPdXRwdXRWYWx1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMud3JpdGVyLndyaXRlKHBhdGNoKTtcbiAgICB9XG59XG4iLCAiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuZXhwb3J0IGNsYXNzIE1vY2tBc3luY0xvY2FsU3RvcmFnZSB7XG4gICAgZ2V0U3RvcmUoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJ1bihfc3RvcmUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxufVxuY2xhc3MgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFzeW5jTG9jYWxTdG9yYWdlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTW9ja0FzeW5jTG9jYWxTdG9yYWdlKClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhhc0JlZW5Jbml0aWFsaXplZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEluc3RhbmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3luY0xvY2FsU3RvcmFnZTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZUdsb2JhbEluc3RhbmNlKGluc3RhbmNlKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNCZWVuSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzQmVlbkluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuYXN5bmNMb2NhbFN0b3JhZ2UgPSBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24gPSBuZXcgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlcigpO1xuZXhwb3J0IHsgQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbiB9O1xuIiwgImltcG9ydCB7IENhbGxiYWNrTWFuYWdlciwgZW5zdXJlSGFuZGxlciwgfSBmcm9tIFwiLi4vY2FsbGJhY2tzL21hbmFnZXIuanNcIjtcbmltcG9ydCB7IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24gfSBmcm9tIFwiLi4vc2luZ2xldG9ucy9pbmRleC5qc1wiO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfUkVDVVJTSU9OX0xJTUlUID0gMjU7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FsbGJhY2tNYW5hZ2VyRm9yQ29uZmlnKGNvbmZpZykge1xuICAgIHJldHVybiBDYWxsYmFja01hbmFnZXIuY29uZmlndXJlKGNvbmZpZz8uY2FsbGJhY2tzLCB1bmRlZmluZWQsIGNvbmZpZz8udGFncywgdW5kZWZpbmVkLCBjb25maWc/Lm1ldGFkYXRhKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUNvbmZpZ3MoLi4uY29uZmlncykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY29uc3QgY29weSA9IGVuc3VyZUNvbmZpZygpO1xuICAgIGZvciAoY29uc3Qgb3B0aW9ucyBvZiBjb25maWdzLmZpbHRlcigoYykgPT4gISFjKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvcHRpb25zKSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJtZXRhZGF0YVwiKSB7XG4gICAgICAgICAgICAgICAgY29weVtrZXldID0geyAuLi5jb3B5W2tleV0sIC4uLm9wdGlvbnNba2V5XSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcInRhZ3NcIikge1xuICAgICAgICAgICAgICAgIGNvcHlba2V5XSA9IFsuLi5uZXcgU2V0KGNvcHlba2V5XS5jb25jYXQob3B0aW9uc1trZXldID8/IFtdKSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcImNvbmZpZ3VyYWJsZVwiKSB7XG4gICAgICAgICAgICAgICAgY29weVtrZXldID0geyAuLi5jb3B5W2tleV0sIC4uLm9wdGlvbnNba2V5XSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcImNhbGxiYWNrc1wiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZUNhbGxiYWNrcyA9IGNvcHkuY2FsbGJhY2tzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVkQ2FsbGJhY2tzID0gb3B0aW9ucy5jYWxsYmFja3M7XG4gICAgICAgICAgICAgICAgLy8gY2FsbGJhY2tzIGNhbiBiZSBlaXRoZXIgdW5kZWZpbmVkLCBBcnJheTxoYW5kbGVyPiBvciBtYW5hZ2VyXG4gICAgICAgICAgICAgICAgLy8gc28gbWVyZ2luZyB0d28gY2FsbGJhY2tzIHZhbHVlcyBoYXMgNiBjYXNlc1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3ZpZGVkQ2FsbGJhY2tzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJhc2VDYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkuY2FsbGJhY2tzID0gcHJvdmlkZWRDYWxsYmFja3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShiYXNlQ2FsbGJhY2tzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weS5jYWxsYmFja3MgPSBiYXNlQ2FsbGJhY2tzLmNvbmNhdChwcm92aWRlZENhbGxiYWNrcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiYXNlQ2FsbGJhY2tzIGlzIGEgbWFuYWdlclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFuYWdlciA9IGJhc2VDYWxsYmFja3MuY29weSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBwcm92aWRlZENhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hbmFnZXIuYWRkSGFuZGxlcihlbnN1cmVIYW5kbGVyKGNhbGxiYWNrKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5LmNhbGxiYWNrcyA9IG1hbmFnZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZWRDYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvdmlkZWRDYWxsYmFja3MgaXMgYSBtYW5hZ2VyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYmFzZUNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weS5jYWxsYmFja3MgPSBwcm92aWRlZENhbGxiYWNrcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJhc2VDYWxsYmFja3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYW5hZ2VyID0gcHJvdmlkZWRDYWxsYmFja3MuY29weSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBiYXNlQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFuYWdlci5hZGRIYW5kbGVyKGVuc3VyZUhhbmRsZXIoY2FsbGJhY2spLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkuY2FsbGJhY2tzID0gbWFuYWdlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhc2VDYWxsYmFja3MgaXMgYWxzbyBhIG1hbmFnZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkuY2FsbGJhY2tzID0gbmV3IENhbGxiYWNrTWFuYWdlcihwcm92aWRlZENhbGxiYWNrcy5fcGFyZW50UnVuSWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyczogYmFzZUNhbGxiYWNrcy5oYW5kbGVycy5jb25jYXQocHJvdmlkZWRDYWxsYmFja3MuaGFuZGxlcnMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaGVyaXRhYmxlSGFuZGxlcnM6IGJhc2VDYWxsYmFja3MuaW5oZXJpdGFibGVIYW5kbGVycy5jb25jYXQocHJvdmlkZWRDYWxsYmFja3MuaW5oZXJpdGFibGVIYW5kbGVycyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnczogQXJyYXkuZnJvbShuZXcgU2V0KGJhc2VDYWxsYmFja3MudGFncy5jb25jYXQocHJvdmlkZWRDYWxsYmFja3MudGFncykpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmhlcml0YWJsZVRhZ3M6IEFycmF5LmZyb20obmV3IFNldChiYXNlQ2FsbGJhY2tzLmluaGVyaXRhYmxlVGFncy5jb25jYXQocHJvdmlkZWRDYWxsYmFja3MuaW5oZXJpdGFibGVUYWdzKSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmJhc2VDYWxsYmFja3MubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnByb3ZpZGVkQ2FsbGJhY2tzLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkS2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgIGNvcHlbdHlwZWRLZXldID0gb3B0aW9uc1t0eXBlZEtleV0gPz8gY29weVt0eXBlZEtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59XG5jb25zdCBQUklNSVRJVkVTID0gbmV3IFNldChbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJib29sZWFuXCJdKTtcbi8qKlxuICogRW5zdXJlIHRoYXQgYSBwYXNzZWQgY29uZmlnIGlzIGFuIG9iamVjdCB3aXRoIGFsbCByZXF1aXJlZCBrZXlzIHByZXNlbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVDb25maWcoY29uZmlnKSB7XG4gICAgY29uc3QgbG9hZGVkQ29uZmlnID0gY29uZmlnID8/IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24uZ2V0SW5zdGFuY2UoKS5nZXRTdG9yZSgpO1xuICAgIGxldCBlbXB0eSA9IHtcbiAgICAgICAgdGFnczogW10sXG4gICAgICAgIG1ldGFkYXRhOiB7fSxcbiAgICAgICAgY2FsbGJhY2tzOiB1bmRlZmluZWQsXG4gICAgICAgIHJlY3Vyc2lvbkxpbWl0OiAyNSxcbiAgICB9O1xuICAgIGlmIChsb2FkZWRDb25maWcpIHtcbiAgICAgICAgZW1wdHkgPSB7IC4uLmVtcHR5LCAuLi5sb2FkZWRDb25maWcgfTtcbiAgICB9XG4gICAgaWYgKGxvYWRlZENvbmZpZz8uY29uZmlndXJhYmxlKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGxvYWRlZENvbmZpZy5jb25maWd1cmFibGUpKSB7XG4gICAgICAgICAgICBpZiAoUFJJTUlUSVZFUy5oYXModHlwZW9mIGxvYWRlZENvbmZpZy5jb25maWd1cmFibGVba2V5XSkgJiZcbiAgICAgICAgICAgICAgICAhZW1wdHkubWV0YWRhdGE/LltrZXldKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbXB0eS5tZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBlbXB0eS5tZXRhZGF0YSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbXB0eS5tZXRhZGF0YVtrZXldID0gbG9hZGVkQ29uZmlnLmNvbmZpZ3VyYWJsZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbXB0eTtcbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgcGF0Y2hlcyBydW5uYWJsZSBjb25maWdzIHdpdGggdXBkYXRlZCBwcm9wZXJ0aWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGF0Y2hDb25maWcoY29uZmlnID0ge30sIHsgY2FsbGJhY2tzLCBtYXhDb25jdXJyZW5jeSwgcmVjdXJzaW9uTGltaXQsIHJ1bk5hbWUsIGNvbmZpZ3VyYWJsZSwgfSA9IHt9KSB7XG4gICAgY29uc3QgbmV3Q29uZmlnID0gZW5zdXJlQ29uZmlnKGNvbmZpZyk7XG4gICAgaWYgKGNhbGxiYWNrcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB3ZSdyZSByZXBsYWNpbmcgY2FsbGJhY2tzIHdlIG5lZWQgdG8gdW5zZXQgcnVuTmFtZVxuICAgICAgICAgKiBzaW5jZSB0aGF0IHNob3VsZCBhcHBseSBvbmx5IHRvIHRoZSBzYW1lIHJ1biBhcyB0aGUgb3JpZ2luYWwgY2FsbGJhY2tzXG4gICAgICAgICAqL1xuICAgICAgICBkZWxldGUgbmV3Q29uZmlnLnJ1bk5hbWU7XG4gICAgICAgIG5ld0NvbmZpZy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgfVxuICAgIGlmIChyZWN1cnNpb25MaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld0NvbmZpZy5yZWN1cnNpb25MaW1pdCA9IHJlY3Vyc2lvbkxpbWl0O1xuICAgIH1cbiAgICBpZiAobWF4Q29uY3VycmVuY3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdDb25maWcubWF4Q29uY3VycmVuY3kgPSBtYXhDb25jdXJyZW5jeTtcbiAgICB9XG4gICAgaWYgKHJ1bk5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdDb25maWcucnVuTmFtZSA9IHJ1bk5hbWU7XG4gICAgfVxuICAgIGlmIChjb25maWd1cmFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdDb25maWcuY29uZmlndXJhYmxlID0geyAuLi5uZXdDb25maWcuY29uZmlndXJhYmxlLCAuLi5jb25maWd1cmFibGUgfTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0NvbmZpZztcbn1cbiIsICJpbXBvcnQgeyBCYXNlVHJhY2VyIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuZXhwb3J0IGNsYXNzIFJvb3RMaXN0ZW5lcnNUcmFjZXIgZXh0ZW5kcyBCYXNlVHJhY2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGNvbmZpZywgb25TdGFydCwgb25FbmQsIG9uRXJyb3IsIH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogXCJSb290TGlzdGVuZXJzVHJhY2VyXCJcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBUaGUgUnVuJ3MgSUQuIFR5cGUgVVVJRCAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyb290SWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29uZmlnXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFyZ09uU3RhcnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXJnT25FbmRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXJnT25FcnJvclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5hcmdPblN0YXJ0ID0gb25TdGFydDtcbiAgICAgICAgdGhpcy5hcmdPbkVuZCA9IG9uRW5kO1xuICAgICAgICB0aGlzLmFyZ09uRXJyb3IgPSBvbkVycm9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGEgbGVnYWN5IG1ldGhvZCBvbmx5IGNhbGxlZCBvbmNlIGZvciBhbiBlbnRpcmUgcnVuIHRyZWVcbiAgICAgKiB0aGVyZWZvcmUgbm90IHVzZWZ1bCBoZXJlXG4gICAgICogQHBhcmFtIHtSdW59IF8gTm90IHVzZWRcbiAgICAgKi9cbiAgICBwZXJzaXN0UnVuKF8pIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBhc3luYyBvblJ1bkNyZWF0ZShydW4pIHtcbiAgICAgICAgaWYgKHRoaXMucm9vdElkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb290SWQgPSBydW4uaWQ7XG4gICAgICAgIGlmICh0aGlzLmFyZ09uU3RhcnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFyZ09uU3RhcnQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hcmdPblN0YXJ0KHJ1bik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmFyZ09uU3RhcnQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hcmdPblN0YXJ0KHJ1biwgdGhpcy5jb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG9uUnVuVXBkYXRlKHJ1bikge1xuICAgICAgICBpZiAocnVuLmlkICE9PSB0aGlzLnJvb3RJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcnVuLmVycm9yKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcmdPbkVuZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFyZ09uRW5kLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFyZ09uRW5kKHJ1bik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYXJnT25FbmQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXJnT25FbmQocnVuLCB0aGlzLmNvbmZpZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYXJnT25FcnJvcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXJnT25FcnJvci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFyZ09uRXJyb3IocnVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYXJnT25FcnJvci5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFyZ09uRXJyb3IocnVuLCB0aGlzLmNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCAiLyoqXG4gKiBVdGlsaXR5IHRvIGZpbHRlciB0aGUgcm9vdCBldmVudCBpbiB0aGUgc3RyZWFtRXZlbnRzIGltcGxlbWVudGF0aW9uLlxuICogVGhpcyBpcyBzaW1wbHkgYmluZGluZyB0aGUgYXJndW1lbnRzIHRvIHRoZSBuYW1lc3BhY2UgdG8gbWFrZSBzYXZlIG9uXG4gKiBhIGJpdCBvZiB0eXBpbmcgaW4gdGhlIHN0cmVhbUV2ZW50cyBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBUT0RPOiBSZWZhY3RvciBhbmQgcmVtb3ZlLlxuICovXG5leHBvcnQgY2xhc3MgX1Jvb3RFdmVudEZpbHRlciB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluY2x1ZGVOYW1lc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmNsdWRlVHlwZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5jbHVkZVRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhjbHVkZU5hbWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4Y2x1ZGVUeXBlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleGNsdWRlVGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmluY2x1ZGVOYW1lcyA9IGZpZWxkcy5pbmNsdWRlTmFtZXM7XG4gICAgICAgIHRoaXMuaW5jbHVkZVR5cGVzID0gZmllbGRzLmluY2x1ZGVUeXBlcztcbiAgICAgICAgdGhpcy5pbmNsdWRlVGFncyA9IGZpZWxkcy5pbmNsdWRlVGFncztcbiAgICAgICAgdGhpcy5leGNsdWRlTmFtZXMgPSBmaWVsZHMuZXhjbHVkZU5hbWVzO1xuICAgICAgICB0aGlzLmV4Y2x1ZGVUeXBlcyA9IGZpZWxkcy5leGNsdWRlVHlwZXM7XG4gICAgICAgIHRoaXMuZXhjbHVkZVRhZ3MgPSBmaWVsZHMuZXhjbHVkZVRhZ3M7XG4gICAgfVxuICAgIGluY2x1ZGVFdmVudChldmVudCwgcm9vdFR5cGUpIHtcbiAgICAgICAgbGV0IGluY2x1ZGUgPSB0aGlzLmluY2x1ZGVOYW1lcyA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLmluY2x1ZGVUeXBlcyA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLmluY2x1ZGVUYWdzID09PSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGV2ZW50VGFncyA9IGV2ZW50LnRhZ3MgPz8gW107XG4gICAgICAgIGlmICh0aGlzLmluY2x1ZGVOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID0gaW5jbHVkZSB8fCB0aGlzLmluY2x1ZGVOYW1lcy5pbmNsdWRlcyhldmVudC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmNsdWRlVHlwZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9IGluY2x1ZGUgfHwgdGhpcy5pbmNsdWRlVHlwZXMuaW5jbHVkZXMocm9vdFR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluY2x1ZGVUYWdzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPVxuICAgICAgICAgICAgICAgIGluY2x1ZGUgfHwgZXZlbnRUYWdzLnNvbWUoKHRhZykgPT4gdGhpcy5pbmNsdWRlVGFncz8uaW5jbHVkZXModGFnKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhjbHVkZU5hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluY2x1ZGUgPSBpbmNsdWRlICYmICF0aGlzLmV4Y2x1ZGVOYW1lcy5pbmNsdWRlcyhldmVudC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leGNsdWRlVHlwZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5jbHVkZSA9IGluY2x1ZGUgJiYgIXRoaXMuZXhjbHVkZVR5cGVzLmluY2x1ZGVzKHJvb3RUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leGNsdWRlVGFncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmNsdWRlID1cbiAgICAgICAgICAgICAgICBpbmNsdWRlICYmIGV2ZW50VGFncy5ldmVyeSgodGFnKSA9PiAhdGhpcy5leGNsdWRlVGFncz8uaW5jbHVkZXModGFnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluY2x1ZGU7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IEluTWVtb3J5Q2FjaGUgfSBmcm9tIFwiLi4vY2FjaGVzLmpzXCI7XG5pbXBvcnQgeyBTdHJpbmdQcm9tcHRWYWx1ZSwgQ2hhdFByb21wdFZhbHVlLCB9IGZyb20gXCIuLi9wcm9tcHRfdmFsdWVzLmpzXCI7XG5pbXBvcnQgeyBjb2VyY2VNZXNzYWdlTGlrZVRvTWVzc2FnZSwgfSBmcm9tIFwiLi4vbWVzc2FnZXMvaW5kZXguanNcIjtcbmltcG9ydCB7IEFzeW5jQ2FsbGVyIH0gZnJvbSBcIi4uL3V0aWxzL2FzeW5jX2NhbGxlci5qc1wiO1xuaW1wb3J0IHsgZW5jb2RpbmdGb3JNb2RlbCB9IGZyb20gXCIuLi91dGlscy90aWt0b2tlbi5qc1wiO1xuaW1wb3J0IHsgUnVubmFibGUgfSBmcm9tIFwiLi4vcnVubmFibGVzL2Jhc2UuanNcIjtcbi8vIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2pzLXRpa3Rva2VuXG5leHBvcnQgY29uc3QgZ2V0TW9kZWxOYW1lRm9yVGlrdG9rZW4gPSAobW9kZWxOYW1lKSA9PiB7XG4gICAgaWYgKG1vZGVsTmFtZS5zdGFydHNXaXRoKFwiZ3B0LTMuNS10dXJiby0xNmtcIikpIHtcbiAgICAgICAgcmV0dXJuIFwiZ3B0LTMuNS10dXJiby0xNmtcIjtcbiAgICB9XG4gICAgaWYgKG1vZGVsTmFtZS5zdGFydHNXaXRoKFwiZ3B0LTMuNS10dXJiby1cIikpIHtcbiAgICAgICAgcmV0dXJuIFwiZ3B0LTMuNS10dXJib1wiO1xuICAgIH1cbiAgICBpZiAobW9kZWxOYW1lLnN0YXJ0c1dpdGgoXCJncHQtNC0zMmtcIikpIHtcbiAgICAgICAgcmV0dXJuIFwiZ3B0LTQtMzJrXCI7XG4gICAgfVxuICAgIGlmIChtb2RlbE5hbWUuc3RhcnRzV2l0aChcImdwdC00LVwiKSkge1xuICAgICAgICByZXR1cm4gXCJncHQtNFwiO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWxOYW1lO1xufTtcbmV4cG9ydCBjb25zdCBnZXRFbWJlZGRpbmdDb250ZXh0U2l6ZSA9IChtb2RlbE5hbWUpID0+IHtcbiAgICBzd2l0Y2ggKG1vZGVsTmFtZSkge1xuICAgICAgICBjYXNlIFwidGV4dC1lbWJlZGRpbmctYWRhLTAwMlwiOlxuICAgICAgICAgICAgcmV0dXJuIDgxOTE7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gMjA0NjtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGdldE1vZGVsQ29udGV4dFNpemUgPSAobW9kZWxOYW1lKSA9PiB7XG4gICAgc3dpdGNoIChnZXRNb2RlbE5hbWVGb3JUaWt0b2tlbihtb2RlbE5hbWUpKSB7XG4gICAgICAgIGNhc2UgXCJncHQtMy41LXR1cmJvLTE2a1wiOlxuICAgICAgICAgICAgcmV0dXJuIDE2Mzg0O1xuICAgICAgICBjYXNlIFwiZ3B0LTMuNS10dXJib1wiOlxuICAgICAgICAgICAgcmV0dXJuIDQwOTY7XG4gICAgICAgIGNhc2UgXCJncHQtNC0zMmtcIjpcbiAgICAgICAgICAgIHJldHVybiAzMjc2ODtcbiAgICAgICAgY2FzZSBcImdwdC00XCI6XG4gICAgICAgICAgICByZXR1cm4gODE5MjtcbiAgICAgICAgY2FzZSBcInRleHQtZGF2aW5jaS0wMDNcIjpcbiAgICAgICAgICAgIHJldHVybiA0MDk3O1xuICAgICAgICBjYXNlIFwidGV4dC1jdXJpZS0wMDFcIjpcbiAgICAgICAgICAgIHJldHVybiAyMDQ4O1xuICAgICAgICBjYXNlIFwidGV4dC1iYWJiYWdlLTAwMVwiOlxuICAgICAgICAgICAgcmV0dXJuIDIwNDg7XG4gICAgICAgIGNhc2UgXCJ0ZXh0LWFkYS0wMDFcIjpcbiAgICAgICAgICAgIHJldHVybiAyMDQ4O1xuICAgICAgICBjYXNlIFwiY29kZS1kYXZpbmNpLTAwMlwiOlxuICAgICAgICAgICAgcmV0dXJuIDgwMDA7XG4gICAgICAgIGNhc2UgXCJjb2RlLWN1c2htYW4tMDAxXCI6XG4gICAgICAgICAgICByZXR1cm4gMjA0ODtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiA0MDk3O1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgY2FsY3VsYXRlTWF4VG9rZW5zID0gYXN5bmMgKHsgcHJvbXB0LCBtb2RlbE5hbWUsIH0pID0+IHtcbiAgICBsZXQgbnVtVG9rZW5zO1xuICAgIHRyeSB7XG4gICAgICAgIG51bVRva2VucyA9IChhd2FpdCBlbmNvZGluZ0Zvck1vZGVsKGdldE1vZGVsTmFtZUZvclRpa3Rva2VuKG1vZGVsTmFtZSkpKS5lbmNvZGUocHJvbXB0KS5sZW5ndGg7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gY2FsY3VsYXRlIG51bWJlciBvZiB0b2tlbnMsIGZhbGxpbmcgYmFjayB0byBhcHByb3hpbWF0ZSBjb3VudFwiKTtcbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gYXBwcm94aW1hdGUgY2FsY3VsYXRpb24gaWYgdGlrdG9rZW4gaXMgbm90IGF2YWlsYWJsZVxuICAgICAgICAvLyBlYWNoIHRva2VuIGlzIH40IGNoYXJhY3RlcnM6IGh0dHBzOi8vaGVscC5vcGVuYWkuY29tL2VuL2FydGljbGVzLzQ5MzY4NTYtd2hhdC1hcmUtdG9rZW5zLWFuZC1ob3ctdG8tY291bnQtdGhlbSNcbiAgICAgICAgbnVtVG9rZW5zID0gTWF0aC5jZWlsKHByb21wdC5sZW5ndGggLyA0KTtcbiAgICB9XG4gICAgY29uc3QgbWF4VG9rZW5zID0gZ2V0TW9kZWxDb250ZXh0U2l6ZShtb2RlbE5hbWUpO1xuICAgIHJldHVybiBtYXhUb2tlbnMgLSBudW1Ub2tlbnM7XG59O1xuY29uc3QgZ2V0VmVyYm9zaXR5ID0gKCkgPT4gZmFsc2U7XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGxhbmd1YWdlIG1vZGVscywgY2hhaW5zLCB0b29scy5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VMYW5nQ2hhaW4gZXh0ZW5kcyBSdW5uYWJsZSB7XG4gICAgZ2V0IGxjX2F0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjYWxsYmFja3M6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHZlcmJvc2U6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIHN1cGVyKHBhcmFtcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRvIHByaW50IG91dCByZXNwb25zZSB0ZXh0LlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmVyYm9zZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYWxsYmFja3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZlcmJvc2UgPSBwYXJhbXMudmVyYm9zZSA/PyBnZXRWZXJib3NpdHkoKTtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBwYXJhbXMuY2FsbGJhY2tzO1xuICAgICAgICB0aGlzLnRhZ3MgPSBwYXJhbXMudGFncyA/PyBbXTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IHBhcmFtcy5tZXRhZGF0YSA/PyB7fTtcbiAgICB9XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGxhbmd1YWdlIG1vZGVscy5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VMYW5ndWFnZU1vZGVsIGV4dGVuZHMgQmFzZUxhbmdDaGFpbiB7XG4gICAgLyoqXG4gICAgICogS2V5cyB0aGF0IHRoZSBsYW5ndWFnZSBtb2RlbCBhY2NlcHRzIGFzIGNhbGwgb3B0aW9ucy5cbiAgICAgKi9cbiAgICBnZXQgY2FsbEtleXMoKSB7XG4gICAgICAgIHJldHVybiBbXCJzdG9wXCIsIFwidGltZW91dFwiLCBcInNpZ25hbFwiLCBcInRhZ3NcIiwgXCJtZXRhZGF0YVwiLCBcImNhbGxiYWNrc1wiXTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoeyBjYWxsYmFja3MsIGNhbGxiYWNrTWFuYWdlciwgLi4ucGFyYW1zIH0pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgY2FsbGJhY2tzOiBjYWxsYmFja3MgPz8gY2FsbGJhY2tNYW5hZ2VyLFxuICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhc3luYyBjYWxsZXIgc2hvdWxkIGJlIHVzZWQgYnkgc3ViY2xhc3NlcyB0byBtYWtlIGFueSBhc3luYyBjYWxscyxcbiAgICAgICAgICogd2hpY2ggd2lsbCB0aHVzIGJlbmVmaXQgZnJvbSB0aGUgY29uY3VycmVuY3kgYW5kIHJldHJ5IGxvZ2ljLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FsbGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhY2hlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9lbmNvZGluZ1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtcy5jYWNoZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdGhpcy5jYWNoZSA9IHBhcmFtcy5jYWNoZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJhbXMuY2FjaGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUgPSBJbk1lbW9yeUNhY2hlLmdsb2JhbCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jYWNoZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGxlciA9IG5ldyBBc3luY0NhbGxlcihwYXJhbXMgPz8ge30pO1xuICAgIH1cbiAgICBhc3luYyBnZXROdW1Ub2tlbnMoY29udGVudCkge1xuICAgICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IGNvcnJlY3QgdmFsdWUuXG4gICAgICAgIGlmICh0eXBlb2YgY29udGVudCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gYXBwcm94aW1hdGUgY2FsY3VsYXRpb24gaWYgdGlrdG9rZW4gaXMgbm90IGF2YWlsYWJsZVxuICAgICAgICBsZXQgbnVtVG9rZW5zID0gTWF0aC5jZWlsKGNvbnRlbnQubGVuZ3RoIC8gNCk7XG4gICAgICAgIGlmICghdGhpcy5fZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5jb2RpbmcgPSBhd2FpdCBlbmNvZGluZ0Zvck1vZGVsKFwibW9kZWxOYW1lXCIgaW4gdGhpc1xuICAgICAgICAgICAgICAgICAgICA/IGdldE1vZGVsTmFtZUZvclRpa3Rva2VuKHRoaXMubW9kZWxOYW1lKVxuICAgICAgICAgICAgICAgICAgICA6IFwiZ3B0MlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBjYWxjdWxhdGUgbnVtYmVyIG9mIHRva2VucywgZmFsbGluZyBiYWNrIHRvIGFwcHJveGltYXRlIGNvdW50XCIsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbnVtVG9rZW5zID0gdGhpcy5fZW5jb2RpbmcuZW5jb2RlKGNvbnRlbnQpLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBjYWxjdWxhdGUgbnVtYmVyIG9mIHRva2VucywgZmFsbGluZyBiYWNrIHRvIGFwcHJveGltYXRlIGNvdW50XCIsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVtVG9rZW5zO1xuICAgIH1cbiAgICBzdGF0aWMgX2NvbnZlcnRJbnB1dFRvUHJvbXB0VmFsdWUoaW5wdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdQcm9tcHRWYWx1ZShpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhdFByb21wdFZhbHVlKGlucHV0Lm1hcChjb2VyY2VNZXNzYWdlTGlrZVRvTWVzc2FnZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaWRlbnRpZnlpbmcgcGFyYW1ldGVycyBvZiB0aGUgTExNLlxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgX2lkZW50aWZ5aW5nUGFyYW1zKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHVuaXF1ZSBjYWNoZSBrZXkgZm9yIGEgc3BlY2lmaWMgY2FsbCB0byBhIHNwZWNpZmljIGxhbmd1YWdlIG1vZGVsLlxuICAgICAqIEBwYXJhbSBjYWxsT3B0aW9ucyBDYWxsIG9wdGlvbnMgZm9yIHRoZSBtb2RlbFxuICAgICAqIEByZXR1cm5zIEEgdW5pcXVlIGNhY2hlIGtleS5cbiAgICAgKi9cbiAgICBfZ2V0U2VyaWFsaXplZENhY2hlS2V5UGFyYW1ldGVyc0ZvckNhbGwoY2FsbE9wdGlvbnMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgLi4udGhpcy5faWRlbnRpZnlpbmdQYXJhbXMoKSxcbiAgICAgICAgICAgIC4uLmNhbGxPcHRpb25zLFxuICAgICAgICAgICAgX3R5cGU6IHRoaXMuX2xsbVR5cGUoKSxcbiAgICAgICAgICAgIF9tb2RlbDogdGhpcy5fbW9kZWxUeXBlKCksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHBhcmFtcykuZmlsdGVyKChbXywgdmFsdWVdKSA9PiB2YWx1ZSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZEVudHJpZXMgPSBmaWx0ZXJlZEVudHJpZXNcbiAgICAgICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCR7a2V5fToke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gKVxuICAgICAgICAgICAgLnNvcnQoKVxuICAgICAgICAgICAgLmpvaW4oXCIsXCIpO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplZEVudHJpZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogUmV0dXJuIGEganNvbi1saWtlIG9iamVjdCByZXByZXNlbnRpbmcgdGhpcyBMTE0uXG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udGhpcy5faWRlbnRpZnlpbmdQYXJhbXMoKSxcbiAgICAgICAgICAgIF90eXBlOiB0aGlzLl9sbG1UeXBlKCksXG4gICAgICAgICAgICBfbW9kZWw6IHRoaXMuX21vZGVsVHlwZSgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIExvYWQgYW4gTExNIGZyb20gYSBqc29uLWxpa2Ugb2JqZWN0IGRlc2NyaWJpbmcgaXQuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKF9kYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVzZSAudG9KU09OKCkgaW5zdGVhZFwiKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgZW5jb2RlUG9pbnRlciB9IGZyb20gXCIuL3BvaW50ZXIuanNcIjtcbmV4cG9ydCBjb25zdCBzY2hlbWFLZXl3b3JkID0ge1xuICAgIGFkZGl0aW9uYWxJdGVtczogdHJ1ZSxcbiAgICB1bmV2YWx1YXRlZEl0ZW1zOiB0cnVlLFxuICAgIGl0ZW1zOiB0cnVlLFxuICAgIGNvbnRhaW5zOiB0cnVlLFxuICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiB0cnVlLFxuICAgIHVuZXZhbHVhdGVkUHJvcGVydGllczogdHJ1ZSxcbiAgICBwcm9wZXJ0eU5hbWVzOiB0cnVlLFxuICAgIG5vdDogdHJ1ZSxcbiAgICBpZjogdHJ1ZSxcbiAgICB0aGVuOiB0cnVlLFxuICAgIGVsc2U6IHRydWUsXG59O1xuZXhwb3J0IGNvbnN0IHNjaGVtYUFycmF5S2V5d29yZCA9IHtcbiAgICBwcmVmaXhJdGVtczogdHJ1ZSxcbiAgICBpdGVtczogdHJ1ZSxcbiAgICBhbGxPZjogdHJ1ZSxcbiAgICBhbnlPZjogdHJ1ZSxcbiAgICBvbmVPZjogdHJ1ZSxcbn07XG5leHBvcnQgY29uc3Qgc2NoZW1hTWFwS2V5d29yZCA9IHtcbiAgICAkZGVmczogdHJ1ZSxcbiAgICBkZWZpbml0aW9uczogdHJ1ZSxcbiAgICBwcm9wZXJ0aWVzOiB0cnVlLFxuICAgIHBhdHRlcm5Qcm9wZXJ0aWVzOiB0cnVlLFxuICAgIGRlcGVuZGVudFNjaGVtYXM6IHRydWUsXG59O1xuZXhwb3J0IGNvbnN0IGlnbm9yZWRLZXl3b3JkID0ge1xuICAgIGlkOiB0cnVlLFxuICAgICRpZDogdHJ1ZSxcbiAgICAkcmVmOiB0cnVlLFxuICAgICRzY2hlbWE6IHRydWUsXG4gICAgJGFuY2hvcjogdHJ1ZSxcbiAgICAkdm9jYWJ1bGFyeTogdHJ1ZSxcbiAgICAkY29tbWVudDogdHJ1ZSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIGVudW06IHRydWUsXG4gICAgY29uc3Q6IHRydWUsXG4gICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgdHlwZTogdHJ1ZSxcbiAgICBtYXhpbXVtOiB0cnVlLFxuICAgIG1pbmltdW06IHRydWUsXG4gICAgZXhjbHVzaXZlTWF4aW11bTogdHJ1ZSxcbiAgICBleGNsdXNpdmVNaW5pbXVtOiB0cnVlLFxuICAgIG11bHRpcGxlT2Y6IHRydWUsXG4gICAgbWF4TGVuZ3RoOiB0cnVlLFxuICAgIG1pbkxlbmd0aDogdHJ1ZSxcbiAgICBwYXR0ZXJuOiB0cnVlLFxuICAgIGZvcm1hdDogdHJ1ZSxcbiAgICBtYXhJdGVtczogdHJ1ZSxcbiAgICBtaW5JdGVtczogdHJ1ZSxcbiAgICB1bmlxdWVJdGVtczogdHJ1ZSxcbiAgICBtYXhQcm9wZXJ0aWVzOiB0cnVlLFxuICAgIG1pblByb3BlcnRpZXM6IHRydWUsXG59O1xuLyoqXG4gKiBEZWZhdWx0IGJhc2UgVVJJIGZvciBzY2hlbWFzIHdpdGhvdXQgYW4gJGlkLlxuICogaHR0cHM6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQvMjAxOS0wOS9qc29uLXNjaGVtYS1jb3JlLmh0bWwjaW5pdGlhbC1iYXNlXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTUuMVxuICovXG5leHBvcnQgbGV0IGluaXRpYWxCYXNlVVJJID0gXG4vLyBAdHMtaWdub3JlXG50eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHNlbGYubG9jYXRpb24gJiZcbiAgICBzZWxmLmxvY2F0aW9uLm9yaWdpbiAhPT0gXCJudWxsXCJcbiAgICA/IC8vQHRzLWlnbm9yZVxuICAgICAgICAvKiAjX19QVVJFX18gKi8gbmV3IFVSTChzZWxmLmxvY2F0aW9uLm9yaWdpbiArIHNlbGYubG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2gpXG4gICAgOiAvKiAjX19QVVJFX18gKi8gbmV3IFVSTChcImh0dHBzOi8vZ2l0aHViLmNvbS9jZndvcmtlclwiKTtcbmV4cG9ydCBmdW5jdGlvbiBkZXJlZmVyZW5jZShzY2hlbWEsIGxvb2t1cCA9IE9iamVjdC5jcmVhdGUobnVsbCksIGJhc2VVUkkgPSBpbml0aWFsQmFzZVVSSSwgYmFzZVBvaW50ZXIgPSBcIlwiKSB7XG4gICAgaWYgKHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICAgICAgY29uc3QgaWQgPSBzY2hlbWEuJGlkIHx8IHNjaGVtYS5pZDtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGlkLCBiYXNlVVJJLmhyZWYpO1xuICAgICAgICAgICAgaWYgKHVybC5oYXNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBsb29rdXBbdXJsLmhyZWZdID0gc2NoZW1hO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXJsLmhhc2ggPSBcIlwiOyAvLyBub3JtYWxpemUgaGFzaCBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtaGFzaFxuICAgICAgICAgICAgICAgIGlmIChiYXNlUG9pbnRlciA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBiYXNlVVJJID0gdXJsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVyZWZlcmVuY2Uoc2NoZW1hLCBsb29rdXAsIGJhc2VVUkkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgIT09IHRydWUgJiYgc2NoZW1hICE9PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gbG9va3VwO1xuICAgIH1cbiAgICAvLyBjb21wdXRlIHRoZSBzY2hlbWEncyBVUkkgYW5kIGFkZCBpdCB0byB0aGUgbWFwcGluZy5cbiAgICBjb25zdCBzY2hlbWFVUkkgPSBiYXNlVVJJLmhyZWYgKyAoYmFzZVBvaW50ZXIgPyBcIiNcIiArIGJhc2VQb2ludGVyIDogXCJcIik7XG4gICAgaWYgKGxvb2t1cFtzY2hlbWFVUkldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgc2NoZW1hIFVSSSBcIiR7c2NoZW1hVVJJfVwiLmApO1xuICAgIH1cbiAgICBsb29rdXBbc2NoZW1hVVJJXSA9IHNjaGVtYTtcbiAgICAvLyBleGl0IGVhcmx5IGlmIHRoaXMgaXMgYSBib29sZWFuIHNjaGVtYS5cbiAgICBpZiAoc2NoZW1hID09PSB0cnVlIHx8IHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGxvb2t1cDtcbiAgICB9XG4gICAgLy8gc2V0IHRoZSBzY2hlbWEncyBhYnNvbHV0ZSBVUkkuXG4gICAgaWYgKHNjaGVtYS5fX2Fic29sdXRlX3VyaV9fID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNjaGVtYSwgXCJfX2Fic29sdXRlX3VyaV9fXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IHNjaGVtYVVSSSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGlmIGEgJHJlZiBpcyBmb3VuZCwgcmVzb2x2ZSBpdCdzIGFic29sdXRlIFVSSS5cbiAgICBpZiAoc2NoZW1hLiRyZWYgJiYgc2NoZW1hLl9fYWJzb2x1dGVfcmVmX18gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHNjaGVtYS4kcmVmLCBiYXNlVVJJLmhyZWYpO1xuICAgICAgICB1cmwuaGFzaCA9IHVybC5oYXNoOyAvLyBub3JtYWxpemUgaGFzaCBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtaGFzaFxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2NoZW1hLCBcIl9fYWJzb2x1dGVfcmVmX19cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogdXJsLmhyZWYsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBpZiBhICRyZWN1cnNpdmVSZWYgaXMgZm91bmQsIHJlc29sdmUgaXQncyBhYnNvbHV0ZSBVUkkuXG4gICAgaWYgKHNjaGVtYS4kcmVjdXJzaXZlUmVmICYmIHNjaGVtYS5fX2Fic29sdXRlX3JlY3Vyc2l2ZV9yZWZfXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoc2NoZW1hLiRyZWN1cnNpdmVSZWYsIGJhc2VVUkkuaHJlZik7XG4gICAgICAgIHVybC5oYXNoID0gdXJsLmhhc2g7IC8vIG5vcm1hbGl6ZSBoYXNoIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1oYXNoXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzY2hlbWEsIFwiX19hYnNvbHV0ZV9yZWN1cnNpdmVfcmVmX19cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogdXJsLmhyZWYsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBpZiBhbiAkYW5jaG9yIGlzIGZvdW5kLCBjb21wdXRlIGl0J3MgVVJJIGFuZCBhZGQgaXQgdG8gdGhlIG1hcHBpbmcuXG4gICAgaWYgKHNjaGVtYS4kYW5jaG9yKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoXCIjXCIgKyBzY2hlbWEuJGFuY2hvciwgYmFzZVVSSS5ocmVmKTtcbiAgICAgICAgbG9va3VwW3VybC5ocmVmXSA9IHNjaGVtYTtcbiAgICB9XG4gICAgLy8gcHJvY2VzcyBzdWJzY2hlbWFzLlxuICAgIGZvciAobGV0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKGlnbm9yZWRLZXl3b3JkW2tleV0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleUJhc2UgPSBgJHtiYXNlUG9pbnRlcn0vJHtlbmNvZGVQb2ludGVyKGtleSl9YDtcbiAgICAgICAgY29uc3Qgc3ViU2NoZW1hID0gc2NoZW1hW2tleV07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN1YlNjaGVtYSkpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWFBcnJheUtleXdvcmRba2V5XSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHN1YlNjaGVtYS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBkZXJlZmVyZW5jZShzdWJTY2hlbWFbaV0sIGxvb2t1cCwgYmFzZVVSSSwgYCR7a2V5QmFzZX0vJHtpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzY2hlbWFNYXBLZXl3b3JkW2tleV0pIHtcbiAgICAgICAgICAgIGZvciAobGV0IHN1YktleSBpbiBzdWJTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBkZXJlZmVyZW5jZShzdWJTY2hlbWFbc3ViS2V5XSwgbG9va3VwLCBiYXNlVVJJLCBgJHtrZXlCYXNlfS8ke2VuY29kZVBvaW50ZXIoc3ViS2V5KX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlcmVmZXJlbmNlKHN1YlNjaGVtYSwgbG9va3VwLCBiYXNlVVJJLCBrZXlCYXNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG9va3VwO1xufVxuLy8gc2NoZW1hIGlkZW50aWZpY2F0aW9uIGV4YW1wbGVzXG4vLyBodHRwczovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC8yMDE5LTA5L2pzb24tc2NoZW1hLWNvcmUuaHRtbCNyZmMuYXBwZW5kaXguQVxuLy8gJHJlZiBkZWxlZ2F0aW9uXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanNvbi1zY2hlbWEtb3JnL2pzb24tc2NoZW1hLXNwZWMvaXNzdWVzLzUxNFxuLy8gb3V0cHV0IGZvcm1hdFxuLy8gaHR0cHM6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQvMjAxOS0wOS9qc29uLXNjaGVtYS1jb3JlLmh0bWwjb3V0cHV0XG4vLyBKU09OIHBvaW50ZXJcbi8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2OTAxXG4vLyBKU09OIHJlbGF0aXZlIHBvaW50ZXJcbi8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1oYW5kcmV3cy1yZWxhdGl2ZS1qc29uLXBvaW50ZXItMDFcbiIsICIvLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZXBvYmVyZXpraW4vYWp2L2Jsb2IvbWFzdGVyL2xpYi9jb21waWxlL2Zvcm1hdHMuanNcbmNvbnN0IERBVEUgPSAvXihcXGRcXGRcXGRcXGQpLShcXGRcXGQpLShcXGRcXGQpJC87XG5jb25zdCBEQVlTID0gWzAsIDMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xuY29uc3QgVElNRSA9IC9eKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkoXFwuXFxkKyk/KHp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pPyQvaTtcbmNvbnN0IEhPU1ROQU1FID0gL14oPz0uezEsMjUzfVxcLj8kKVthLXowLTldKD86W2EtejAtOS1dezAsNjF9W2EtejAtOV0pPyg/OlxcLlthLXowLTldKD86Wy0wLTlhLXpdezAsNjF9WzAtOWEtel0pPykqXFwuPyQvaTtcbi8vIGNvbnN0IFVSSSA9IC9eKD86W2Etel1bYS16MC05K1xcLS5dKjopKD86XFwvP1xcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdfCVbMC05YS1mXXsyfSkqQCk/KD86XFxbKD86KD86KD86KD86WzAtOWEtZl17MSw0fTopezZ9fDo6KD86WzAtOWEtZl17MSw0fTopezV9fCg/OlswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDF9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7M318KD86KD86WzAtOWEtZl17MSw0fTopezAsMn1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXsyfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwzfVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fTp8KD86KD86WzAtOWEtZl17MSw0fTopezAsNH1bMC05YS1mXXsxLDR9KT86OikoPzpbMC05YS1mXXsxLDR9OlswLTlhLWZdezEsNH18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw1fVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw2fVswLTlhLWZdezEsNH0pPzo6KXxbVnZdWzAtOWEtZl0rXFwuW2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol0rKVxcXXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPyl8KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9XXwlWzAtOWEtZl17Mn0pKikoPzo6XFxkKik/KD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSp8XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopP3woPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKikoPzpcXD8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/KD86Iyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8kL2k7XG5jb25zdCBVUklSRUYgPSAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KT8oPzpcXC8/XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol18JVswLTlhLWZdezJ9KSpAKT8oPzpcXFsoPzooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7Nn18OjooPzpbMC05YS1mXXsxLDR9Oil7NX18KD86WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7NH18KD86KD86WzAtOWEtZl17MSw0fTopezAsMX1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXszfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwyfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezJ9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDN9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9OnwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw0fVswLTlhLWZdezEsNH0pPzo6KSg/OlswLTlhLWZdezEsNH06WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykpfCg/Oig/OlswLTlhLWZdezEsNH06KXswLDV9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDZ9WzAtOWEtZl17MSw0fSk/OjopfFtWdl1bMC05YS1mXStcXC5bYS16MC05XFwtLl9+ISQmJygpKissOz06XSspXFxdfCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KXwoPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PV18JVswLTlhLWZdezJ9KSopKD86OlxcZCopPyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSp8XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT98KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT8oPzpcXD8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8oPzojKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/JC9pO1xuLy8gdXJpLXRlbXBsYXRlOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjU3MFxuY29uc3QgVVJJVEVNUExBVEUgPSAvXig/Oig/OlteXFx4MDAtXFx4MjBcIic8PiVcXFxcXmB7fH1dfCVbMC05YS1mXXsyfSl8XFx7WysjLi87PyY9LCFAfF0/KD86W2EtejAtOV9dfCVbMC05YS1mXXsyfSkrKD86OlsxLTldWzAtOV17MCwzfXxcXCopPyg/OiwoPzpbYS16MC05X118JVswLTlhLWZdezJ9KSsoPzo6WzEtOV1bMC05XXswLDN9fFxcKik/KSpcXH0pKiQvaTtcbi8vIEZvciB0aGUgc291cmNlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9kcGVyaW5pLzcyOTI5NFxuLy8gRm9yIHRlc3QgY2FzZXM6IGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9kZW1vL3VybC1yZWdleFxuY29uc3QgVVJMXyA9IC9eKD86KD86aHR0cHM/fGZ0cCk6XFwvXFwvKSg/OlxcUysoPzo6XFxTKik/QCk/KD86KD8hMTAoPzpcXC5cXGR7MSwzfSl7M30pKD8hMTI3KD86XFwuXFxkezEsM30pezN9KSg/ITE2OVxcLjI1NCg/OlxcLlxcZHsxLDN9KXsyfSkoPyExOTJcXC4xNjgoPzpcXC5cXGR7MSwzfSl7Mn0pKD8hMTcyXFwuKD86MVs2LTldfDJcXGR8M1swLTFdKSg/OlxcLlxcZHsxLDN9KXsyfSkoPzpbMS05XVxcZD98MVxcZFxcZHwyWzAxXVxcZHwyMlswLTNdKSg/OlxcLig/OjE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pKXsyfSg/OlxcLig/OlsxLTldXFxkP3wxXFxkXFxkfDJbMC00XVxcZHwyNVswLTRdKSl8KD86KD86W2EtelxcdXswMGExfS1cXHV7ZmZmZn0wLTldKy0/KSpbYS16XFx1ezAwYTF9LVxcdXtmZmZmfTAtOV0rKSg/OlxcLig/OlthLXpcXHV7MDBhMX0tXFx1e2ZmZmZ9MC05XSstPykqW2EtelxcdXswMGExfS1cXHV7ZmZmZn0wLTldKykqKD86XFwuKD86W2EtelxcdXswMGExfS1cXHV7ZmZmZn1dezIsfSkpKSg/OjpcXGR7Miw1fSk/KD86XFwvW15cXHNdKik/JC9pdTtcbmNvbnN0IFVVSUQgPSAvXig/OnVybjp1dWlkOik/WzAtOWEtZl17OH0tKD86WzAtOWEtZl17NH0tKXszfVswLTlhLWZdezEyfSQvaTtcbmNvbnN0IEpTT05fUE9JTlRFUiA9IC9eKD86XFwvKD86W15+L118fjB8fjEpKikqJC87XG5jb25zdCBKU09OX1BPSU5URVJfVVJJX0ZSQUdNRU5UID0gL14jKD86XFwvKD86W2EtejAtOV9cXC0uISQmJygpKissOzo9QF18JVswLTlhLWZdezJ9fH4wfH4xKSopKiQvaTtcbmNvbnN0IFJFTEFUSVZFX0pTT05fUE9JTlRFUiA9IC9eKD86MHxbMS05XVswLTldKikoPzojfCg/OlxcLyg/Oltefi9dfH4wfH4xKSopKikkLztcbi8vIGRhdGU6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbmNvbnN0IEZBU1REQVRFID0gL15cXGRcXGRcXGRcXGQtWzAtMV1cXGQtWzAtM11cXGQkLztcbi8vIGRhdGUtdGltZTogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuY29uc3QgRkFTVFRJTUUgPSAvXig/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pPyQvaTtcbmNvbnN0IEZBU1REQVRFVElNRSA9IC9eXFxkXFxkXFxkXFxkLVswLTFdXFxkLVswLTNdXFxkW3RcXHNdKD86WzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGR8MjM6NTk6NjApKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPykkL2k7XG4vLyB1cmk6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvaXMtbXktanNvbi12YWxpZC9ibG9iL21hc3Rlci9mb3JtYXRzLmpzXG4vLyBjb25zdCBGQVNUVVJJID0gL14oPzpbYS16XVthLXowLTkrLS5dKjopKD86XFwvP1xcLyk/W15cXHNdKiQvaTtcbmNvbnN0IEZBU1RVUklSRUZFUkVOQ0UgPSAvXig/Oig/OlthLXpdW2EtejAtOSstLl0qOik/XFwvP1xcLyk/KD86W15cXFxcXFxzI11bXlxccyNdKik/KD86I1teXFxcXFxcc10qKT8kL2k7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vRXhvZHVzTW92ZW1lbnQvc2NoZW1hc2FmZS9ibG9iL21hc3Rlci9zcmMvZm9ybWF0cy5qc1xuY29uc3QgRU1BSUwgPSAoaW5wdXQpID0+IHtcbiAgICBpZiAoaW5wdXRbMF0gPT09ICdcIicpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBbbmFtZSwgaG9zdCwgLi4ucmVzdF0gPSBpbnB1dC5zcGxpdChcIkBcIik7XG4gICAgaWYgKCFuYW1lIHx8XG4gICAgICAgICFob3N0IHx8XG4gICAgICAgIHJlc3QubGVuZ3RoICE9PSAwIHx8XG4gICAgICAgIG5hbWUubGVuZ3RoID4gNjQgfHxcbiAgICAgICAgaG9zdC5sZW5ndGggPiAyNTMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAobmFtZVswXSA9PT0gXCIuXCIgfHwgbmFtZS5lbmRzV2l0aChcIi5cIikgfHwgbmFtZS5pbmNsdWRlcyhcIi4uXCIpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCEvXlthLXowLTkuLV0rJC9pLnRlc3QoaG9zdCkgfHxcbiAgICAgICAgIS9eW2EtejAtOS4hIyQlJicqKy89P15fYHt8fX4tXSskL2kudGVzdChuYW1lKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBob3N0XG4gICAgICAgIC5zcGxpdChcIi5cIilcbiAgICAgICAgLmV2ZXJ5KChwYXJ0KSA9PiAvXlthLXowLTldKFthLXowLTktXXswLDYxfVthLXowLTldKT8kL2kudGVzdChwYXJ0KSk7XG59O1xuLy8gb3B0aW1pemVkIGh0dHBzOi8vd3d3LnNhZmFyaWJvb2tzb25saW5lLmNvbS9saWJyYXJ5L3ZpZXcvcmVndWxhci1leHByZXNzaW9ucy1jb29rYm9vay85NzgwNTk2ODAyODM3L2NoMDdzMTYuaHRtbFxuY29uc3QgSVBWNCA9IC9eKD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pJC87XG4vLyBvcHRpbWl6ZWQgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81MzQ5Ny9yZWd1bGFyLWV4cHJlc3Npb24tdGhhdC1tYXRjaGVzLXZhbGlkLWlwdjYtYWRkcmVzc2VzXG5jb25zdCBJUFY2ID0gL14oKChbMC05YS1mXXsxLDR9Oil7N30oWzAtOWEtZl17MSw0fXw6KSl8KChbMC05YS1mXXsxLDR9Oil7Nn0oOlswLTlhLWZdezEsNH18KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlhLWZdezEsNH06KXs1fSgoKDpbMC05YS1mXXsxLDR9KXsxLDJ9KXw6KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlhLWZdezEsNH06KXs0fSgoKDpbMC05YS1mXXsxLDR9KXsxLDN9KXwoKDpbMC05YS1mXXsxLDR9KT86KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05YS1mXXsxLDR9Oil7M30oKCg6WzAtOWEtZl17MSw0fSl7MSw0fSl8KCg6WzAtOWEtZl17MSw0fSl7MCwyfTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlhLWZdezEsNH06KXsyfSgoKDpbMC05YS1mXXsxLDR9KXsxLDV9KXwoKDpbMC05YS1mXXsxLDR9KXswLDN9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOWEtZl17MSw0fTopezF9KCgoOlswLTlhLWZdezEsNH0pezEsNn0pfCgoOlswLTlhLWZdezEsNH0pezAsNH06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KDooKCg6WzAtOWEtZl17MSw0fSl7MSw3fSl8KCg6WzAtOWEtZl17MSw0fSl7MCw1fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKSkkL2k7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vRXhvZHVzTW92ZW1lbnQvc2NoZW1hc2FmZS9ibG9iL21hc3Rlci9zcmMvZm9ybWF0cy5qc1xuY29uc3QgRFVSQVRJT04gPSAoaW5wdXQpID0+IGlucHV0Lmxlbmd0aCA+IDEgJiZcbiAgICBpbnB1dC5sZW5ndGggPCA4MCAmJlxuICAgICgvXlBcXGQrKFsuLF1cXGQrKT9XJC8udGVzdChpbnB1dCkgfHxcbiAgICAgICAgKC9eUFtcXGRZTURUSFNdKihcXGRbLixdXFxkKyk/W1lNREhTXSQvLnRlc3QoaW5wdXQpICYmXG4gICAgICAgICAgICAvXlAoWy4sXFxkXStZKT8oWy4sXFxkXStNKT8oWy4sXFxkXStEKT8oVChbLixcXGRdK0gpPyhbLixcXGRdK00pPyhbLixcXGRdK1MpPyk/JC8udGVzdChpbnB1dCkpKTtcbmZ1bmN0aW9uIGJpbmQocikge1xuICAgIHJldHVybiByLnRlc3QuYmluZChyKTtcbn1cbmV4cG9ydCBjb25zdCBmdWxsRm9ybWF0ID0ge1xuICAgIGRhdGUsXG4gICAgdGltZTogLyogI19fUFVSRV9fICovIHRpbWUuYmluZCh1bmRlZmluZWQsIGZhbHNlKSxcbiAgICBcImRhdGUtdGltZVwiOiBkYXRlX3RpbWUsXG4gICAgZHVyYXRpb246IERVUkFUSU9OLFxuICAgIHVyaSxcbiAgICBcInVyaS1yZWZlcmVuY2VcIjogLyogI19fUFVSRV9fICovIGJpbmQoVVJJUkVGKSxcbiAgICBcInVyaS10ZW1wbGF0ZVwiOiAvKiAjX19QVVJFX18gKi8gYmluZChVUklURU1QTEFURSksXG4gICAgdXJsOiAvKiAjX19QVVJFX18gKi8gYmluZChVUkxfKSxcbiAgICBlbWFpbDogRU1BSUwsXG4gICAgaG9zdG5hbWU6IC8qICNfX1BVUkVfXyAqLyBiaW5kKEhPU1ROQU1FKSxcbiAgICBpcHY0OiAvKiAjX19QVVJFX18gKi8gYmluZChJUFY0KSxcbiAgICBpcHY2OiAvKiAjX19QVVJFX18gKi8gYmluZChJUFY2KSxcbiAgICByZWdleDogcmVnZXgsXG4gICAgdXVpZDogLyogI19fUFVSRV9fICovIGJpbmQoVVVJRCksXG4gICAgXCJqc29uLXBvaW50ZXJcIjogLyogI19fUFVSRV9fICovIGJpbmQoSlNPTl9QT0lOVEVSKSxcbiAgICBcImpzb24tcG9pbnRlci11cmktZnJhZ21lbnRcIjogLyogI19fUFVSRV9fICovIGJpbmQoSlNPTl9QT0lOVEVSX1VSSV9GUkFHTUVOVCksXG4gICAgXCJyZWxhdGl2ZS1qc29uLXBvaW50ZXJcIjogLyogI19fUFVSRV9fICovIGJpbmQoUkVMQVRJVkVfSlNPTl9QT0lOVEVSKSxcbn07XG5leHBvcnQgY29uc3QgZmFzdEZvcm1hdCA9IHtcbiAgICAuLi5mdWxsRm9ybWF0LFxuICAgIGRhdGU6IC8qICNfX1BVUkVfXyAqLyBiaW5kKEZBU1REQVRFKSxcbiAgICB0aW1lOiAvKiAjX19QVVJFX18gKi8gYmluZChGQVNUVElNRSksXG4gICAgXCJkYXRlLXRpbWVcIjogLyogI19fUFVSRV9fICovIGJpbmQoRkFTVERBVEVUSU1FKSxcbiAgICBcInVyaS1yZWZlcmVuY2VcIjogLyogI19fUFVSRV9fICovIGJpbmQoRkFTVFVSSVJFRkVSRU5DRSksXG59O1xuZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjYXBwZW5kaXgtQ1xuICAgIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKTtcbn1cbmZ1bmN0aW9uIGRhdGUoc3RyKSB7XG4gICAgLy8gZnVsbC1kYXRlIGZyb20gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICAgIGNvbnN0IG1hdGNoZXMgPSBzdHIubWF0Y2goREFURSk7XG4gICAgaWYgKCFtYXRjaGVzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgeWVhciA9ICttYXRjaGVzWzFdO1xuICAgIGNvbnN0IG1vbnRoID0gK21hdGNoZXNbMl07XG4gICAgY29uc3QgZGF5ID0gK21hdGNoZXNbM107XG4gICAgcmV0dXJuIChtb250aCA+PSAxICYmXG4gICAgICAgIG1vbnRoIDw9IDEyICYmXG4gICAgICAgIGRheSA+PSAxICYmXG4gICAgICAgIGRheSA8PSAobW9udGggPT0gMiAmJiBpc0xlYXBZZWFyKHllYXIpID8gMjkgOiBEQVlTW21vbnRoXSkpO1xufVxuZnVuY3Rpb24gdGltZShmdWxsLCBzdHIpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gc3RyLm1hdGNoKFRJTUUpO1xuICAgIGlmICghbWF0Y2hlcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGhvdXIgPSArbWF0Y2hlc1sxXTtcbiAgICBjb25zdCBtaW51dGUgPSArbWF0Y2hlc1syXTtcbiAgICBjb25zdCBzZWNvbmQgPSArbWF0Y2hlc1szXTtcbiAgICBjb25zdCB0aW1lWm9uZSA9ICEhbWF0Y2hlc1s1XTtcbiAgICByZXR1cm4gKCgoaG91ciA8PSAyMyAmJiBtaW51dGUgPD0gNTkgJiYgc2Vjb25kIDw9IDU5KSB8fFxuICAgICAgICAoaG91ciA9PSAyMyAmJiBtaW51dGUgPT0gNTkgJiYgc2Vjb25kID09IDYwKSkgJiZcbiAgICAgICAgKCFmdWxsIHx8IHRpbWVab25lKSk7XG59XG5jb25zdCBEQVRFX1RJTUVfU0VQQVJBVE9SID0gL3R8XFxzL2k7XG5mdW5jdGlvbiBkYXRlX3RpbWUoc3RyKSB7XG4gICAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICAgIGNvbnN0IGRhdGVUaW1lID0gc3RyLnNwbGl0KERBVEVfVElNRV9TRVBBUkFUT1IpO1xuICAgIHJldHVybiBkYXRlVGltZS5sZW5ndGggPT0gMiAmJiBkYXRlKGRhdGVUaW1lWzBdKSAmJiB0aW1lKHRydWUsIGRhdGVUaW1lWzFdKTtcbn1cbmNvbnN0IE5PVF9VUklfRlJBR01FTlQgPSAvXFwvfDovO1xuY29uc3QgVVJJX1BBVFRFUk4gPSAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KSg/OlxcLz9cXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06XXwlWzAtOWEtZl17Mn0pKkApPyg/OlxcWyg/Oig/Oig/Oig/OlswLTlhLWZdezEsNH06KXs2fXw6Oig/OlswLTlhLWZdezEsNH06KXs1fXwoPzpbMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXs0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwxfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezN9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDJ9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7Mn18KD86KD86WzAtOWEtZl17MSw0fTopezAsM31bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH06fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDR9WzAtOWEtZl17MSw0fSk/OjopKD86WzAtOWEtZl17MSw0fTpbMC05YS1mXXsxLDR9fCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSl8KD86KD86WzAtOWEtZl17MSw0fTopezAsNX1bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH18KD86KD86WzAtOWEtZl17MSw0fTopezAsNn1bMC05YS1mXXsxLDR9KT86Oil8W1Z2XVswLTlhLWZdK1xcLlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdKylcXF18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pfCg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PV18JVswLTlhLWZdezJ9KSopKD86OlxcZCopPyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqfFxcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT98KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopKD86XFw/KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyg/OiMoPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/JC9pO1xuZnVuY3Rpb24gdXJpKHN0cikge1xuICAgIC8vIGh0dHA6Ly9qbXJ3YXJlLmNvbS9hcnRpY2xlcy8yMDA5L3VyaV9yZWdleHAvVVJJX3JlZ2V4Lmh0bWwgKyBvcHRpb25hbCBwcm90b2NvbCArIHJlcXVpcmVkIFwiLlwiXG4gICAgcmV0dXJuIE5PVF9VUklfRlJBR01FTlQudGVzdChzdHIpICYmIFVSSV9QQVRURVJOLnRlc3Qoc3RyKTtcbn1cbmNvbnN0IFpfQU5DSE9SID0gL1teXFxcXF1cXFxcWi87XG5mdW5jdGlvbiByZWdleChzdHIpIHtcbiAgICBpZiAoWl9BTkNIT1IudGVzdChzdHIpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IFJlZ0V4cChzdHIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBBSU1lc3NhZ2UsIGdldEJ1ZmZlclN0cmluZywgfSBmcm9tIFwiLi4vbWVzc2FnZXMvaW5kZXguanNcIjtcbmltcG9ydCB7IFJVTl9LRVksIEdlbmVyYXRpb25DaHVuaywgfSBmcm9tIFwiLi4vb3V0cHV0cy5qc1wiO1xuaW1wb3J0IHsgQ2FsbGJhY2tNYW5hZ2VyLCB9IGZyb20gXCIuLi9jYWxsYmFja3MvbWFuYWdlci5qc1wiO1xuaW1wb3J0IHsgQmFzZUxhbmd1YWdlTW9kZWwsIH0gZnJvbSBcIi4vYmFzZS5qc1wiO1xuLyoqXG4gKiBMTE0gV3JhcHBlci4gVGFrZXMgaW4gYSBwcm9tcHQgKG9yIHByb21wdHMpIGFuZCByZXR1cm5zIGEgc3RyaW5nLlxuICovXG5leHBvcnQgY2xhc3MgQmFzZUxMTSBleHRlbmRzIEJhc2VMYW5ndWFnZU1vZGVsIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGNvbmN1cnJlbmN5LCAuLi5yZXN0IH0pIHtcbiAgICAgICAgc3VwZXIoY29uY3VycmVuY3kgPyB7IG1heENvbmN1cnJlbmN5OiBjb25jdXJyZW5jeSwgLi4ucmVzdCB9IDogcmVzdCk7XG4gICAgICAgIC8vIE9ubHkgZXZlciBpbnN0YW50aWF0ZWQgaW4gbWFpbiBMYW5nQ2hhaW5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGNfbmFtZXNwYWNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXCJsYW5nY2hhaW5cIiwgXCJsbG1zXCIsIHRoaXMuX2xsbVR5cGUoKV1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHRha2VzIGFuIGlucHV0IGFuZCBvcHRpb25zLCBhbmQgcmV0dXJucyBhIHN0cmluZy4gSXRcbiAgICAgKiBjb252ZXJ0cyB0aGUgaW5wdXQgdG8gYSBwcm9tcHQgdmFsdWUgYW5kIGdlbmVyYXRlcyBhIHJlc3VsdCBiYXNlZCBvblxuICAgICAqIHRoZSBwcm9tcHQuXG4gICAgICogQHBhcmFtIGlucHV0IElucHV0IGZvciB0aGUgTExNLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSBMTE0gY2FsbC5cbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXN1bHQgYmFzZWQgb24gdGhlIHByb21wdC5cbiAgICAgKi9cbiAgICBhc3luYyBpbnZva2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcHJvbXB0VmFsdWUgPSBCYXNlTExNLl9jb252ZXJ0SW5wdXRUb1Byb21wdFZhbHVlKGlucHV0KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZW5lcmF0ZVByb21wdChbcHJvbXB0VmFsdWVdLCBvcHRpb25zLCBvcHRpb25zPy5jYWxsYmFja3MpO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmdlbmVyYXRpb25zWzBdWzBdLnRleHQ7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLXlpZWxkXG4gICAgYXN5bmMgKl9zdHJlYW1SZXNwb25zZUNodW5rcyhfaW5wdXQsIF9vcHRpb25zLCBfcnVuTWFuYWdlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cbiAgICBfc2VwYXJhdGVSdW5uYWJsZUNvbmZpZ0Zyb21DYWxsT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IFtydW5uYWJsZUNvbmZpZywgY2FsbE9wdGlvbnNdID0gc3VwZXIuX3NlcGFyYXRlUnVubmFibGVDb25maWdGcm9tQ2FsbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGlmIChjYWxsT3B0aW9ucz8udGltZW91dCAmJiAhY2FsbE9wdGlvbnMuc2lnbmFsKSB7XG4gICAgICAgICAgICBjYWxsT3B0aW9ucy5zaWduYWwgPSBBYm9ydFNpZ25hbC50aW1lb3V0KGNhbGxPcHRpb25zLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbcnVubmFibGVDb25maWcsIGNhbGxPcHRpb25zXTtcbiAgICB9XG4gICAgYXN5bmMgKl9zdHJlYW1JdGVyYXRvcihpbnB1dCwgb3B0aW9ucykge1xuICAgICAgICAvLyBTdWJjbGFzcyBjaGVjayByZXF1aXJlZCB0byBhdm9pZCBkb3VibGUgY2FsbGJhY2tzIHdpdGggZGVmYXVsdCBpbXBsZW1lbnRhdGlvblxuICAgICAgICBpZiAodGhpcy5fc3RyZWFtUmVzcG9uc2VDaHVua3MgPT09IEJhc2VMTE0ucHJvdG90eXBlLl9zdHJlYW1SZXNwb25zZUNodW5rcykge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5pbnZva2UoaW5wdXQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcHJvbXB0ID0gQmFzZUxMTS5fY29udmVydElucHV0VG9Qcm9tcHRWYWx1ZShpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBbcnVubmFibGVDb25maWcsIGNhbGxPcHRpb25zXSA9IHRoaXMuX3NlcGFyYXRlUnVubmFibGVDb25maWdGcm9tQ2FsbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgQ2FsbGJhY2tNYW5hZ2VyLmNvbmZpZ3VyZShydW5uYWJsZUNvbmZpZy5jYWxsYmFja3MsIHRoaXMuY2FsbGJhY2tzLCBydW5uYWJsZUNvbmZpZy50YWdzLCB0aGlzLnRhZ3MsIHJ1bm5hYmxlQ29uZmlnLm1ldGFkYXRhLCB0aGlzLm1ldGFkYXRhLCB7IHZlcmJvc2U6IHRoaXMudmVyYm9zZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhID0ge1xuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGNhbGxPcHRpb25zLFxuICAgICAgICAgICAgICAgIGludm9jYXRpb25fcGFyYW1zOiB0aGlzPy5pbnZvY2F0aW9uUGFyYW1zKGNhbGxPcHRpb25zKSxcbiAgICAgICAgICAgICAgICBiYXRjaF9zaXplOiAxLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJ1bk1hbmFnZXJzID0gYXdhaXQgY2FsbGJhY2tNYW5hZ2VyXz8uaGFuZGxlTExNU3RhcnQodGhpcy50b0pTT04oKSwgW3Byb21wdC50b1N0cmluZygpXSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGV4dHJhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgcnVubmFibGVDb25maWcucnVuTmFtZSk7XG4gICAgICAgICAgICBsZXQgZ2VuZXJhdGlvbiA9IG5ldyBHZW5lcmF0aW9uQ2h1bmsoe1xuICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiB0aGlzLl9zdHJlYW1SZXNwb25zZUNodW5rcyhpbnB1dC50b1N0cmluZygpLCBjYWxsT3B0aW9ucywgcnVuTWFuYWdlcnM/LlswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFnZW5lcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uID0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uID0gZ2VuZXJhdGlvbi5jb25jYXQoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsudGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgY2h1bmsudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCgocnVuTWFuYWdlcnMgPz8gW10pLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlTExNRXJyb3IoZXJyKSkpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKChydW5NYW5hZ2VycyA/PyBbXSkubWFwKChydW5NYW5hZ2VyKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVMTE1FbmQoe1xuICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zOiBbW2dlbmVyYXRpb25dXSxcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgdGFrZXMgcHJvbXB0IHZhbHVlcywgb3B0aW9ucywgYW5kIGNhbGxiYWNrcywgYW5kIGdlbmVyYXRlc1xuICAgICAqIGEgcmVzdWx0IGJhc2VkIG9uIHRoZSBwcm9tcHRzLlxuICAgICAqIEBwYXJhbSBwcm9tcHRWYWx1ZXMgUHJvbXB0IHZhbHVlcyBmb3IgdGhlIExMTS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgTExNIGNhbGwuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrcyBDYWxsYmFja3MgZm9yIHRoZSBMTE0gY2FsbC5cbiAgICAgKiBAcmV0dXJucyBBbiBMTE1SZXN1bHQgYmFzZWQgb24gdGhlIHByb21wdHMuXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGVQcm9tcHQocHJvbXB0VmFsdWVzLCBvcHRpb25zLCBjYWxsYmFja3MpIHtcbiAgICAgICAgY29uc3QgcHJvbXB0cyA9IHByb21wdFZhbHVlcy5tYXAoKHByb21wdFZhbHVlKSA9PiBwcm9tcHRWYWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGUocHJvbXB0cywgb3B0aW9ucywgY2FsbGJhY2tzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwYXJhbWV0ZXJzIHVzZWQgdG8gaW52b2tlIHRoZSBtb2RlbFxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgaW52b2NhdGlvblBhcmFtcyhfb3B0aW9ucykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIF9mbGF0dGVuTExNUmVzdWx0KGxsbVJlc3VsdCkge1xuICAgICAgICBjb25zdCBsbG1SZXN1bHRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGxtUmVzdWx0LmdlbmVyYXRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBnZW5MaXN0ID0gbGxtUmVzdWx0LmdlbmVyYXRpb25zW2ldO1xuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBsbG1SZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0aW9uczogW2dlbkxpc3RdLFxuICAgICAgICAgICAgICAgICAgICBsbG1PdXRwdXQ6IGxsbVJlc3VsdC5sbG1PdXRwdXQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsbG1PdXRwdXQgPSBsbG1SZXN1bHQubGxtT3V0cHV0XG4gICAgICAgICAgICAgICAgICAgID8geyAuLi5sbG1SZXN1bHQubGxtT3V0cHV0LCB0b2tlblVzYWdlOiB7fSB9XG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGxsbVJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zOiBbZ2VuTGlzdF0sXG4gICAgICAgICAgICAgICAgICAgIGxsbU91dHB1dCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGxtUmVzdWx0cztcbiAgICB9XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICBhc3luYyBfZ2VuZXJhdGVVbmNhY2hlZChwcm9tcHRzLCBwYXJzZWRPcHRpb25zLCBoYW5kbGVkT3B0aW9ucykge1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgQ2FsbGJhY2tNYW5hZ2VyLmNvbmZpZ3VyZShoYW5kbGVkT3B0aW9ucy5jYWxsYmFja3MsIHRoaXMuY2FsbGJhY2tzLCBoYW5kbGVkT3B0aW9ucy50YWdzLCB0aGlzLnRhZ3MsIGhhbmRsZWRPcHRpb25zLm1ldGFkYXRhLCB0aGlzLm1ldGFkYXRhLCB7IHZlcmJvc2U6IHRoaXMudmVyYm9zZSB9KTtcbiAgICAgICAgY29uc3QgZXh0cmEgPSB7XG4gICAgICAgICAgICBvcHRpb25zOiBwYXJzZWRPcHRpb25zLFxuICAgICAgICAgICAgaW52b2NhdGlvbl9wYXJhbXM6IHRoaXM/Lmludm9jYXRpb25QYXJhbXMocGFyc2VkT3B0aW9ucyksXG4gICAgICAgICAgICBiYXRjaF9zaXplOiBwcm9tcHRzLmxlbmd0aCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlcnMgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVMTE1TdGFydCh0aGlzLnRvSlNPTigpLCBwcm9tcHRzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZXh0cmEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBoYW5kbGVkT3B0aW9ucz8ucnVuTmFtZSk7XG4gICAgICAgIGxldCBvdXRwdXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBhd2FpdCB0aGlzLl9nZW5lcmF0ZShwcm9tcHRzLCBwYXJzZWRPcHRpb25zLCBydW5NYW5hZ2Vycz8uWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCgocnVuTWFuYWdlcnMgPz8gW10pLm1hcCgocnVuTWFuYWdlcikgPT4gcnVuTWFuYWdlcj8uaGFuZGxlTExNRXJyb3IoZXJyKSkpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZsYXR0ZW5lZE91dHB1dHMgPSB0aGlzLl9mbGF0dGVuTExNUmVzdWx0KG91dHB1dCk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKChydW5NYW5hZ2VycyA/PyBbXSkubWFwKChydW5NYW5hZ2VyLCBpKSA9PiBydW5NYW5hZ2VyPy5oYW5kbGVMTE1FbmQoZmxhdHRlbmVkT3V0cHV0c1tpXSkpKTtcbiAgICAgICAgY29uc3QgcnVuSWRzID0gcnVuTWFuYWdlcnM/Lm1hcCgobWFuYWdlcikgPT4gbWFuYWdlci5ydW5JZCkgfHwgdW5kZWZpbmVkO1xuICAgICAgICAvLyBUaGlzIGRlZmluZXMgUlVOX0tFWSBhcyBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IG9uIHRoZSBvdXRwdXQgb2JqZWN0XG4gICAgICAgIC8vIHNvIHRoYXQgaXQgaXMgbm90IHNlcmlhbGl6ZWQgd2hlbiB0aGUgb3V0cHV0IGlzIHN0cmluZ2lmaWVkLCBhbmQgc28gdGhhdFxuICAgICAgICAvLyBpdCBpc250IGluY2x1ZGVkIHdoZW4gbGlzdGluZyB0aGUga2V5cyBvZiB0aGUgb3V0cHV0IG9iamVjdC5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG91dHB1dCwgUlVOX0tFWSwge1xuICAgICAgICAgICAgdmFsdWU6IHJ1bklkcyA/IHsgcnVuSWRzIH0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBhc3luYyBfZ2VuZXJhdGVDYWNoZWQoeyBwcm9tcHRzLCBjYWNoZSwgbGxtU3RyaW5nS2V5LCBwYXJzZWRPcHRpb25zLCBoYW5kbGVkT3B0aW9ucywgfSkge1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXJfID0gYXdhaXQgQ2FsbGJhY2tNYW5hZ2VyLmNvbmZpZ3VyZShoYW5kbGVkT3B0aW9ucy5jYWxsYmFja3MsIHRoaXMuY2FsbGJhY2tzLCBoYW5kbGVkT3B0aW9ucy50YWdzLCB0aGlzLnRhZ3MsIGhhbmRsZWRPcHRpb25zLm1ldGFkYXRhLCB0aGlzLm1ldGFkYXRhLCB7IHZlcmJvc2U6IHRoaXMudmVyYm9zZSB9KTtcbiAgICAgICAgY29uc3QgZXh0cmEgPSB7XG4gICAgICAgICAgICBvcHRpb25zOiBwYXJzZWRPcHRpb25zLFxuICAgICAgICAgICAgaW52b2NhdGlvbl9wYXJhbXM6IHRoaXM/Lmludm9jYXRpb25QYXJhbXMocGFyc2VkT3B0aW9ucyksXG4gICAgICAgICAgICBiYXRjaF9zaXplOiBwcm9tcHRzLmxlbmd0aCxcbiAgICAgICAgICAgIGNhY2hlZDogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcnVuTWFuYWdlcnMgPSBhd2FpdCBjYWxsYmFja01hbmFnZXJfPy5oYW5kbGVMTE1TdGFydCh0aGlzLnRvSlNPTigpLCBwcm9tcHRzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZXh0cmEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBoYW5kbGVkT3B0aW9ucz8ucnVuTmFtZSk7XG4gICAgICAgIC8vIGdlbmVyYXRlIHJlc3VsdHNcbiAgICAgICAgY29uc3QgbWlzc2luZ1Byb21wdEluZGljZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChwcm9tcHRzLm1hcChhc3luYyAocHJvbXB0LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FjaGUubG9va3VwKHByb21wdCwgbGxtU3RyaW5nS2V5KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG1pc3NpbmdQcm9tcHRJbmRpY2VzLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyBNYXAgcnVuIG1hbmFnZXJzIHRvIHRoZSByZXN1bHRzIGJlZm9yZSBmaWx0ZXJpbmcgb3V0IG51bGwgcmVzdWx0c1xuICAgICAgICAvLyBOdWxsIHJlc3VsdHMgYXJlIGp1c3QgYWJzZW50IGZyb20gdGhlIGNhY2hlLlxuICAgICAgICBjb25zdCBjYWNoZWRSZXN1bHRzID0gcmVzdWx0c1xuICAgICAgICAgICAgLm1hcCgocmVzdWx0LCBpbmRleCkgPT4gKHsgcmVzdWx0LCBydW5NYW5hZ2VyOiBydW5NYW5hZ2Vycz8uW2luZGV4XSB9KSlcbiAgICAgICAgICAgIC5maWx0ZXIoKHsgcmVzdWx0IH0pID0+IChyZXN1bHQuc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiICYmIHJlc3VsdC52YWx1ZSAhPSBudWxsKSB8fFxuICAgICAgICAgICAgcmVzdWx0LnN0YXR1cyA9PT0gXCJyZWplY3RlZFwiKTtcbiAgICAgICAgLy8gSGFuZGxlIHJlc3VsdHMgYW5kIGNhbGwgcnVuIG1hbmFnZXJzXG4gICAgICAgIGNvbnN0IGdlbmVyYXRpb25zID0gW107XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGNhY2hlZFJlc3VsdHMubWFwKGFzeW5jICh7IHJlc3VsdDogcHJvbWlzZVJlc3VsdCwgcnVuTWFuYWdlciB9LCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZVJlc3VsdC5zdGF0dXMgPT09IFwiZnVsZmlsbGVkXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwcm9taXNlUmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zW2ldID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJ1bk1hbmFnZXI/LmhhbmRsZUxMTU5ld1Rva2VuKHJlc3VsdFswXS50ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bk1hbmFnZXI/LmhhbmRsZUxMTUVuZCh7XG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zOiBbcmVzdWx0XSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHN0YXR1cyA9PT0gXCJyZWplY3RlZFwiXG4gICAgICAgICAgICAgICAgYXdhaXQgcnVuTWFuYWdlcj8uaGFuZGxlTExNRXJyb3IocHJvbWlzZVJlc3VsdC5yZWFzb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChwcm9taXNlUmVzdWx0LnJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgICAgICAgZ2VuZXJhdGlvbnMsXG4gICAgICAgICAgICBtaXNzaW5nUHJvbXB0SW5kaWNlcyxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVGhpcyBkZWZpbmVzIFJVTl9LRVkgYXMgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBvbiB0aGUgb3V0cHV0IG9iamVjdFxuICAgICAgICAvLyBzbyB0aGF0IGl0IGlzIG5vdCBzZXJpYWxpemVkIHdoZW4gdGhlIG91dHB1dCBpcyBzdHJpbmdpZmllZCwgYW5kIHNvIHRoYXRcbiAgICAgICAgLy8gaXQgaXNudCBpbmNsdWRlZCB3aGVuIGxpc3RpbmcgdGhlIGtleXMgb2YgdGhlIG91dHB1dCBvYmplY3QuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvdXRwdXQsIFJVTl9LRVksIHtcbiAgICAgICAgICAgIHZhbHVlOiBydW5NYW5hZ2Vyc1xuICAgICAgICAgICAgICAgID8geyBydW5JZHM6IHJ1bk1hbmFnZXJzPy5tYXAoKG1hbmFnZXIpID0+IG1hbmFnZXIucnVuSWQpIH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1biB0aGUgTExNIG9uIHRoZSBnaXZlbiBwcm9tcHRzIGFuZCBpbnB1dCwgaGFuZGxpbmcgY2FjaGluZy5cbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZShwcm9tcHRzLCBvcHRpb25zLCBjYWxsYmFja3MpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb21wdHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudCAncHJvbXB0cycgaXMgZXhwZWN0ZWQgdG8gYmUgYSBzdHJpbmdbXVwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyc2VkT3B0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHBhcnNlZE9wdGlvbnMgPSB7IHN0b3A6IG9wdGlvbnMgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlZE9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtydW5uYWJsZUNvbmZpZywgY2FsbE9wdGlvbnNdID0gdGhpcy5fc2VwYXJhdGVSdW5uYWJsZUNvbmZpZ0Zyb21DYWxsT3B0aW9ucyhwYXJzZWRPcHRpb25zKTtcbiAgICAgICAgcnVubmFibGVDb25maWcuY2FsbGJhY2tzID0gcnVubmFibGVDb25maWcuY2FsbGJhY2tzID8/IGNhbGxiYWNrcztcbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2VuZXJhdGVVbmNhY2hlZChwcm9tcHRzLCBjYWxsT3B0aW9ucywgcnVubmFibGVDb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY2FjaGUgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGxsbVN0cmluZ0tleSA9IHRoaXMuX2dldFNlcmlhbGl6ZWRDYWNoZUtleVBhcmFtZXRlcnNGb3JDYWxsKGNhbGxPcHRpb25zKTtcbiAgICAgICAgY29uc3QgeyBnZW5lcmF0aW9ucywgbWlzc2luZ1Byb21wdEluZGljZXMgfSA9IGF3YWl0IHRoaXMuX2dlbmVyYXRlQ2FjaGVkKHtcbiAgICAgICAgICAgIHByb21wdHMsXG4gICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgIGxsbVN0cmluZ0tleSxcbiAgICAgICAgICAgIHBhcnNlZE9wdGlvbnM6IGNhbGxPcHRpb25zLFxuICAgICAgICAgICAgaGFuZGxlZE9wdGlvbnM6IHJ1bm5hYmxlQ29uZmlnLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGxsbU91dHB1dCA9IHt9O1xuICAgICAgICBpZiAobWlzc2luZ1Byb21wdEluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuX2dlbmVyYXRlVW5jYWNoZWQobWlzc2luZ1Byb21wdEluZGljZXMubWFwKChpKSA9PiBwcm9tcHRzW2ldKSwgY2FsbE9wdGlvbnMsIHJ1bm5hYmxlQ29uZmlnKTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJlc3VsdHMuZ2VuZXJhdGlvbnMubWFwKGFzeW5jIChnZW5lcmF0aW9uLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb21wdEluZGV4ID0gbWlzc2luZ1Byb21wdEluZGljZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGdlbmVyYXRpb25zW3Byb21wdEluZGV4XSA9IGdlbmVyYXRpb247XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlLnVwZGF0ZShwcm9tcHRzW3Byb21wdEluZGV4XSwgbGxtU3RyaW5nS2V5LCBnZW5lcmF0aW9uKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGxsbU91dHB1dCA9IHJlc3VsdHMubGxtT3V0cHV0ID8/IHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGdlbmVyYXRpb25zLCBsbG1PdXRwdXQgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIC5pbnZva2UoKSBpbnN0ZWFkLiBXaWxsIGJlIHJlbW92ZWQgaW4gMC4yLjAuXG4gICAgICogQ29udmVuaWVuY2Ugd3JhcHBlciBmb3Ige0BsaW5rIGdlbmVyYXRlfSB0aGF0IHRha2VzIGluIGEgc2luZ2xlIHN0cmluZyBwcm9tcHQgYW5kIHJldHVybnMgYSBzaW5nbGUgc3RyaW5nIG91dHB1dC5cbiAgICAgKi9cbiAgICBhc3luYyBjYWxsKHByb21wdCwgb3B0aW9ucywgY2FsbGJhY2tzKSB7XG4gICAgICAgIGNvbnN0IHsgZ2VuZXJhdGlvbnMgfSA9IGF3YWl0IHRoaXMuZ2VuZXJhdGUoW3Byb21wdF0sIG9wdGlvbnMsIGNhbGxiYWNrcyk7XG4gICAgICAgIHJldHVybiBnZW5lcmF0aW9uc1swXVswXS50ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgLmludm9rZSgpIGluc3RlYWQuIFdpbGwgYmUgcmVtb3ZlZCBpbiAwLjIuMC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHNpbWlsYXIgdG8gYGNhbGxgLCBidXQgaXQncyB1c2VkIGZvciBtYWtpbmcgcHJlZGljdGlvbnNcbiAgICAgKiBiYXNlZCBvbiB0aGUgaW5wdXQgdGV4dC5cbiAgICAgKiBAcGFyYW0gdGV4dCBJbnB1dCB0ZXh0IGZvciB0aGUgcHJlZGljdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgTExNIGNhbGwuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrcyBDYWxsYmFja3MgZm9yIHRoZSBMTE0gY2FsbC5cbiAgICAgKiBAcmV0dXJucyBBIHByZWRpY3Rpb24gYmFzZWQgb24gdGhlIGlucHV0IHRleHQuXG4gICAgICovXG4gICAgYXN5bmMgcHJlZGljdCh0ZXh0LCBvcHRpb25zLCBjYWxsYmFja3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbCh0ZXh0LCBvcHRpb25zLCBjYWxsYmFja3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgLmludm9rZSgpIGluc3RlYWQuIFdpbGwgYmUgcmVtb3ZlZCBpbiAwLjIuMC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHRha2VzIGEgbGlzdCBvZiBtZXNzYWdlcywgb3B0aW9ucywgYW5kIGNhbGxiYWNrcywgYW5kXG4gICAgICogcmV0dXJucyBhIHByZWRpY3RlZCBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlcyBBIGxpc3Qgb2YgbWVzc2FnZXMgZm9yIHRoZSBwcmVkaWN0aW9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSBMTE0gY2FsbC5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tzIENhbGxiYWNrcyBmb3IgdGhlIExMTSBjYWxsLlxuICAgICAqIEByZXR1cm5zIEEgcHJlZGljdGVkIG1lc3NhZ2UgYmFzZWQgb24gdGhlIGxpc3Qgb2YgbWVzc2FnZXMuXG4gICAgICovXG4gICAgYXN5bmMgcHJlZGljdE1lc3NhZ2VzKG1lc3NhZ2VzLCBvcHRpb25zLCBjYWxsYmFja3MpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IGdldEJ1ZmZlclN0cmluZyhtZXNzYWdlcyk7XG4gICAgICAgIGNvbnN0IHByZWRpY3Rpb24gPSBhd2FpdCB0aGlzLmNhbGwodGV4dCwgb3B0aW9ucywgY2FsbGJhY2tzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBSU1lc3NhZ2UocHJlZGljdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaWRlbnRpZnlpbmcgcGFyYW1ldGVycyBvZiB0aGUgTExNLlxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgX2lkZW50aWZ5aW5nUGFyYW1zKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogUmV0dXJuIGEganNvbi1saWtlIG9iamVjdCByZXByZXNlbnRpbmcgdGhpcyBMTE0uXG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udGhpcy5faWRlbnRpZnlpbmdQYXJhbXMoKSxcbiAgICAgICAgICAgIF90eXBlOiB0aGlzLl9sbG1UeXBlKCksXG4gICAgICAgICAgICBfbW9kZWw6IHRoaXMuX21vZGVsVHlwZSgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfbW9kZWxUeXBlKCkge1xuICAgICAgICByZXR1cm4gXCJiYXNlX2xsbVwiO1xuICAgIH1cbn1cbi8qKlxuICogTExNIGNsYXNzIHRoYXQgcHJvdmlkZXMgYSBzaW1wbGVyIGludGVyZmFjZSB0byBzdWJjbGFzcyB0aGFuIHtAbGluayBCYXNlTExNfS5cbiAqXG4gKiBSZXF1aXJlcyBvbmx5IGltcGxlbWVudGluZyBhIHNpbXBsZXIge0BsaW5rIF9jYWxsfSBtZXRob2QgaW5zdGVhZCBvZiB7QGxpbmsgX2dlbmVyYXRlfS5cbiAqXG4gKiBAYXVnbWVudHMgQmFzZUxMTVxuICovXG5leHBvcnQgY2xhc3MgTExNIGV4dGVuZHMgQmFzZUxMTSB7XG4gICAgYXN5bmMgX2dlbmVyYXRlKHByb21wdHMsIG9wdGlvbnMsIHJ1bk1hbmFnZXIpIHtcbiAgICAgICAgY29uc3QgZ2VuZXJhdGlvbnMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9tcHRzLm1hcCgocHJvbXB0LCBwcm9tcHRJbmRleCkgPT4gdGhpcy5fY2FsbChwcm9tcHQsIHsgLi4ub3B0aW9ucywgcHJvbXB0SW5kZXggfSwgcnVuTWFuYWdlcikudGhlbigodGV4dCkgPT4gW3sgdGV4dCB9XSkpKTtcbiAgICAgICAgcmV0dXJuIHsgZ2VuZXJhdGlvbnMgfTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgR2VuZXJhdGlvbkNodW5rIH0gZnJvbSBcIkBsYW5nY2hhaW4vY29yZS9vdXRwdXRzXCI7XG5pbXBvcnQgeyBMTE0gfSBmcm9tIFwiQGxhbmdjaGFpbi9jb3JlL2xhbmd1YWdlX21vZGVscy9sbG1zXCI7XG4vKipcbiAqIEEgZmFrZSBMTE0gdGhhdCByZXR1cm5zIGEgcHJlZGVmaW5lZCBsaXN0IG9mIHJlc3BvbnNlcy4gSXQgY2FuIGJlIHVzZWQgZm9yXG4gKiB0ZXN0aW5nIHB1cnBvc2VzLlxuICovXG5leHBvcnQgY2xhc3MgRmFrZUxpc3RMTE0gZXh0ZW5kcyBMTE0ge1xuICAgIHN0YXRpYyBsY19uYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJGYWtlTGlzdExMTVwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih7IHJlc3BvbnNlcywgc2xlZXAgfSkge1xuICAgICAgICBzdXBlcih7fSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlc3BvbnNlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzbGVlcFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlc3BvbnNlcyA9IHJlc3BvbnNlcztcbiAgICAgICAgdGhpcy5zbGVlcCA9IHNsZWVwO1xuICAgIH1cbiAgICBfbGxtVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFwiZmFrZS1saXN0XCI7XG4gICAgfVxuICAgIGFzeW5jIF9jYWxsKF9wcm9tcHQsIF9vcHRpb25zLCBfcnVuTWFuYWdlcikge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMuX2N1cnJlbnRSZXNwb25zZSgpO1xuICAgICAgICB0aGlzLl9pbmNyZW1lbnRSZXNwb25zZSgpO1xuICAgICAgICBhd2FpdCB0aGlzLl9zbGVlcElmUmVxdWVzdGVkKCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgX2N1cnJlbnRSZXNwb25zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2VzW3RoaXMuaV07XG4gICAgfVxuICAgIF9pbmNyZW1lbnRSZXNwb25zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaSA8IHRoaXMucmVzcG9uc2VzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHRoaXMuaSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAqX3N0cmVhbVJlc3BvbnNlQ2h1bmtzKF9pbnB1dCwgX29wdGlvbnMsIF9ydW5NYW5hZ2VyKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5fY3VycmVudFJlc3BvbnNlKCk7XG4gICAgICAgIHRoaXMuX2luY3JlbWVudFJlc3BvbnNlKCk7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdGV4dCBvZiByZXNwb25zZSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2xlZXBJZlJlcXVlc3RlZCgpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5fY3JlYXRlUmVzcG9uc2VDaHVuayh0ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfc2xlZXBJZlJlcXVlc3RlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2xlZXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2xlZXAoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfc2xlZXAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKCksIHRoaXMuc2xlZXApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2NyZWF0ZVJlc3BvbnNlQ2h1bmsodGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEdlbmVyYXRpb25DaHVuayh7XG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgZ2VuZXJhdGlvbkluZm86IHt9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgTGFuZ0NoYWluVHJhY2VyIH0gZnJvbSBcImxhbmdjaGFpbi9jYWxsYmFja3NcIjtcbmltcG9ydCB7IENsaWVudCB9IGZyb20gXCJsYW5nc21pdGhcIjtcbmltcG9ydCB7IENoYXRPcGVuQUkgfSBmcm9tIFwiQGxhbmdjaGFpbi9vcGVuYWlcIjtcbmltcG9ydCB7XG4gIERFRkFVTFRfU0VUVElOR1MsXG4gIHR5cGUgT2JzaWRpYW5DaGF0R1BUUGx1Z2luU2V0dGluZ3MsXG59IGZyb20gXCIuL3NldHRpbmdzXCI7XG5cbmltcG9ydCB7IEZha2VMaXN0TExNIH0gZnJvbSBcImxhbmdjaGFpbi9sbG1zL2Zha2VcIjtcblxuY29uc3Qgc3RvcmU6IHtcbiAgc2V0dGluZ3M6IE9ic2lkaWFuQ2hhdEdQVFBsdWdpblNldHRpbmdzO1xuICB0cmFjZXI/OiBMYW5nQ2hhaW5UcmFjZXI7XG59ID0ge1xuICBzZXR0aW5nczogREVGQVVMVF9TRVRUSU5HUyxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVMTE0oc2V0dGluZ3M6IE9ic2lkaWFuQ2hhdEdQVFBsdWdpblNldHRpbmdzKSB7XG4gIHN0b3JlLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gIHN0b3JlLnRyYWNlciA9IHNldHRpbmdzLkxBTkdDSEFJTl9UUkFDSU5HX1YyXG4gICAgPyBuZXcgTGFuZ0NoYWluVHJhY2VyKHtcbiAgICAgIHByb2plY3ROYW1lOiBzZXR0aW5ncy5MQU5HQ0hBSU5fUFJPSkVDVCB8fFxuICAgICAgICBERUZBVUxUX1NFVFRJTkdTLkxBTkdDSEFJTl9QUk9KRUNULFxuICAgICAgY2xpZW50OiBuZXcgQ2xpZW50KHtcbiAgICAgICAgYXBpVXJsOiBzZXR0aW5ncy5MQU5HQ0hBSU5fRU5EUE9JTlQgfHxcbiAgICAgICAgICBERUZBVUxUX1NFVFRJTkdTLkxBTkdDSEFJTl9FTkRQT0lOVCxcbiAgICAgICAgYXBpS2V5OiBzZXR0aW5ncy5MQU5HQ0hBSU5fQVBJX0tFWSB8fFxuICAgICAgICAgIERFRkFVTFRfU0VUVElOR1MuTEFOR0NIQUlOX0FQSV9LRVksXG4gICAgICB9KSxcbiAgICB9KVxuICAgIDogdW5kZWZpbmVkO1xufVxuXG5jb25zdCBsbG0gPSBuZXcgRmFrZUxpc3RMTE0oe1xuICByZXNwb25zZXM6IFtcbiAgICBcIkJlY2F1c2UgT2N0IDMxIGVxdWFscyBEZWMgMjVcIixcbiAgICBcIllvdSAnY29uc29sZScgdGhlbSFcIixcbiAgXSxcbiAgc2xlZXA6IDEwMCxcbn0pO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIGNoYXQocHJvbXB0OiBzdHJpbmcpIHtcbiAgLy8gY29uc3QgbGxtID0gbmV3IENoYXRPcGVuQUkoe1xuICAvLyAgIG9wZW5BSUFwaUtleTogc3RvcmUuc2V0dGluZ3MuT1BFTkFJX0FQSV9LRVksXG4gIC8vICAgY29uZmlndXJhdGlvbjoge1xuICAvLyAgICAgYmFzZVVSTDogc3RvcmUuc2V0dGluZ3MuT1BFTkFJX0FQSV9CQVNFLFxuICAvLyAgIH0sXG4gIC8vIH0pO1xuXG4gIGNvbnN0IHN0cmVhbSA9IGF3YWl0IGxsbS5zdHJlYW0oXG4gICAgW1xuICAgICAgW1wiaHVtYW5cIiwgcHJvbXB0XSxcbiAgICBdLFxuICAgIHN0b3JlLnRyYWNlciA/IHsgY2FsbGJhY2tzOiBbc3RvcmUudHJhY2VyXSB9IDoge30sXG4gICk7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgLy8geWllbGQgY2h1bmsuY29udGVudDtcbiAgICB5aWVsZCBjaHVuaztcbiAgfVxufVxuIiwgIi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBub29wKCkge31cblxuZXhwb3J0IGNvbnN0IGlkZW50aXR5ID0gKHgpID0+IHg7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSBTXG4gKiBAcGFyYW0ge1R9IHRhclxuICogQHBhcmFtIHtTfSBzcmNcbiAqIEByZXR1cm5zIHtUICYgU31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbih0YXIsIHNyYykge1xuXHQvLyBAdHMtaWdub3JlXG5cdGZvciAoY29uc3QgayBpbiBzcmMpIHRhcltrXSA9IHNyY1trXTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7VCAmIFN9ICovICh0YXIpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3RoZW4vaXMtcHJvbWlzZS9ibG9iL21hc3Rlci9pbmRleC5qc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgTUlUIExpY2Vuc2UgaHR0cHM6Ly9naXRodWIuY29tL3RoZW4vaXMtcHJvbWlzZS9ibG9iL21hc3Rlci9MSUNFTlNFXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybnMge3ZhbHVlIGlzIFByb21pc2VMaWtlPGFueT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19wcm9taXNlKHZhbHVlKSB7XG5cdHJldHVybiAoXG5cdFx0ISF2YWx1ZSAmJlxuXHRcdCh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgJiZcblx0XHR0eXBlb2YgKC8qKiBAdHlwZSB7YW55fSAqLyAodmFsdWUpLnRoZW4pID09PSAnZnVuY3Rpb24nXG5cdCk7XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRfbG9jYXRpb24oZWxlbWVudCwgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyKSB7XG5cdGVsZW1lbnQuX19zdmVsdGVfbWV0YSA9IHtcblx0XHRsb2M6IHsgZmlsZSwgbGluZSwgY29sdW1uLCBjaGFyIH1cblx0fTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJ1bihmbikge1xuXHRyZXR1cm4gZm4oKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJsYW5rX29iamVjdCgpIHtcblx0cmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbltdfSBmbnNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcnVuX2FsbChmbnMpIHtcblx0Zm5zLmZvckVhY2gocnVuKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdGhpbmdcbiAqIEByZXR1cm5zIHt0aGluZyBpcyBGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2Z1bmN0aW9uKHRoaW5nKSB7XG5cdHJldHVybiB0eXBlb2YgdGhpbmcgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKiBAcmV0dXJucyB7Ym9vbGVhbn0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlX25vdF9lcXVhbChhLCBiKSB7XG5cdHJldHVybiBhICE9IGEgPyBiID09IGIgOiBhICE9PSBiIHx8IChhICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JykgfHwgdHlwZW9mIGEgPT09ICdmdW5jdGlvbic7XG59XG5cbmxldCBzcmNfdXJsX2VxdWFsX2FuY2hvcjtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudF9zcmNcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3JjX3VybF9lcXVhbChlbGVtZW50X3NyYywgdXJsKSB7XG5cdGlmIChlbGVtZW50X3NyYyA9PT0gdXJsKSByZXR1cm4gdHJ1ZTtcblx0aWYgKCFzcmNfdXJsX2VxdWFsX2FuY2hvcikge1xuXHRcdHNyY191cmxfZXF1YWxfYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuXHR9XG5cdC8vIFRoaXMgaXMgYWN0dWFsbHkgZmFzdGVyIHRoYW4gZG9pbmcgVVJMKC4uKS5ocmVmXG5cdHNyY191cmxfZXF1YWxfYW5jaG9yLmhyZWYgPSB1cmw7XG5cdHJldHVybiBlbGVtZW50X3NyYyA9PT0gc3JjX3VybF9lcXVhbF9hbmNob3IuaHJlZjtcbn1cblxuLyoqIEBwYXJhbSB7c3RyaW5nfSBzcmNzZXQgKi9cbmZ1bmN0aW9uIHNwbGl0X3NyY3NldChzcmNzZXQpIHtcblx0cmV0dXJuIHNyY3NldC5zcGxpdCgnLCcpLm1hcCgoc3JjKSA9PiBzcmMudHJpbSgpLnNwbGl0KCcgJykuZmlsdGVyKEJvb2xlYW4pKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxTb3VyY2VFbGVtZW50IHwgSFRNTEltYWdlRWxlbWVudH0gZWxlbWVudF9zcmNzZXRcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbH0gc3Jjc2V0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNyY3NldF91cmxfZXF1YWwoZWxlbWVudF9zcmNzZXQsIHNyY3NldCkge1xuXHRjb25zdCBlbGVtZW50X3VybHMgPSBzcGxpdF9zcmNzZXQoZWxlbWVudF9zcmNzZXQuc3Jjc2V0KTtcblx0Y29uc3QgdXJscyA9IHNwbGl0X3NyY3NldChzcmNzZXQgfHwgJycpO1xuXG5cdHJldHVybiAoXG5cdFx0dXJscy5sZW5ndGggPT09IGVsZW1lbnRfdXJscy5sZW5ndGggJiZcblx0XHR1cmxzLmV2ZXJ5KFxuXHRcdFx0KFt1cmwsIHdpZHRoXSwgaSkgPT5cblx0XHRcdFx0d2lkdGggPT09IGVsZW1lbnRfdXJsc1tpXVsxXSAmJlxuXHRcdFx0XHQvLyBXZSBuZWVkIHRvIHRlc3QgYm90aCB3YXlzIGJlY2F1c2UgVml0ZSB3aWxsIGNyZWF0ZSBhbiBhIGZ1bGwgVVJMIHdpdGhcblx0XHRcdFx0Ly8gYG5ldyBVUkwoYXNzZXQsIGltcG9ydC5tZXRhLnVybCkuaHJlZmAgZm9yIHRoZSBjbGllbnQgd2hlbiBgYmFzZTogJy4vJ2AsIGFuZCB0aGVcblx0XHRcdFx0Ly8gcmVsYXRpdmUgVVJMcyBpbnNpZGUgc3Jjc2V0IGFyZSBub3QgYXV0b21hdGljYWxseSByZXNvbHZlZCB0byBhYnNvbHV0ZSBVUkxzIGJ5XG5cdFx0XHRcdC8vIGJyb3dzZXJzIChpbiBjb250cmFzdCB0byBpbWcuc3JjKS4gVGhpcyBtZWFucyBib3RoIFNTUiBhbmQgRE9NIGNvZGUgY291bGRcblx0XHRcdFx0Ly8gY29udGFpbiByZWxhdGl2ZSBvciBhYnNvbHV0ZSBVUkxzLlxuXHRcdFx0XHQoc3JjX3VybF9lcXVhbChlbGVtZW50X3VybHNbaV1bMF0sIHVybCkgfHwgc3JjX3VybF9lcXVhbCh1cmwsIGVsZW1lbnRfdXJsc1tpXVswXSkpXG5cdFx0KVxuXHQpO1xufVxuXG4vKiogQHJldHVybnMge2Jvb2xlYW59ICovXG5leHBvcnQgZnVuY3Rpb24gbm90X2VxdWFsKGEsIGIpIHtcblx0cmV0dXJuIGEgIT0gYSA/IGIgPT0gYiA6IGEgIT09IGI7XG59XG5cbi8qKiBAcmV0dXJucyB7Ym9vbGVhbn0gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19lbXB0eShvYmopIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfc3RvcmUoc3RvcmUsIG5hbWUpIHtcblx0aWYgKHN0b3JlICE9IG51bGwgJiYgdHlwZW9mIHN0b3JlLnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93IG5ldyBFcnJvcihgJyR7bmFtZX0nIGlzIG5vdCBhIHN0b3JlIHdpdGggYSAnc3Vic2NyaWJlJyBtZXRob2RgKTtcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3Vic2NyaWJlKHN0b3JlLCAuLi5jYWxsYmFja3MpIHtcblx0aWYgKHN0b3JlID09IG51bGwpIHtcblx0XHRmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIGNhbGxiYWNrcykge1xuXHRcdFx0Y2FsbGJhY2sodW5kZWZpbmVkKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5vb3A7XG5cdH1cblx0Y29uc3QgdW5zdWIgPSBzdG9yZS5zdWJzY3JpYmUoLi4uY2FsbGJhY2tzKTtcblx0cmV0dXJuIHVuc3ViLnVuc3Vic2NyaWJlID8gKCkgPT4gdW5zdWIudW5zdWJzY3JpYmUoKSA6IHVuc3ViO1xufVxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCB2YWx1ZSBmcm9tIGEgc3RvcmUgYnkgc3Vic2NyaWJpbmcgYW5kIGltbWVkaWF0ZWx5IHVuc3Vic2NyaWJpbmcuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLXN0b3JlI2dldFxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9zdG9yZS9wdWJsaWMuanMnKS5SZWFkYWJsZTxUPn0gc3RvcmVcbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X3N0b3JlX3ZhbHVlKHN0b3JlKSB7XG5cdGxldCB2YWx1ZTtcblx0c3Vic2NyaWJlKHN0b3JlLCAoXykgPT4gKHZhbHVlID0gXykpKCk7XG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvbmVudF9zdWJzY3JpYmUoY29tcG9uZW50LCBzdG9yZSwgY2FsbGJhY2spIHtcblx0Y29tcG9uZW50LiQkLm9uX2Rlc3Ryb3kucHVzaChzdWJzY3JpYmUoc3RvcmUsIGNhbGxiYWNrKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfc2xvdChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKSB7XG5cdGlmIChkZWZpbml0aW9uKSB7XG5cdFx0Y29uc3Qgc2xvdF9jdHggPSBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pO1xuXHRcdHJldHVybiBkZWZpbml0aW9uWzBdKHNsb3RfY3R4KTtcblx0fVxufVxuXG5mdW5jdGlvbiBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pIHtcblx0cmV0dXJuIGRlZmluaXRpb25bMV0gJiYgZm4gPyBhc3NpZ24oJCRzY29wZS5jdHguc2xpY2UoKSwgZGVmaW5pdGlvblsxXShmbihjdHgpKSkgOiAkJHNjb3BlLmN0eDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldF9zbG90X2NoYW5nZXMoZGVmaW5pdGlvbiwgJCRzY29wZSwgZGlydHksIGZuKSB7XG5cdGlmIChkZWZpbml0aW9uWzJdICYmIGZuKSB7XG5cdFx0Y29uc3QgbGV0cyA9IGRlZmluaXRpb25bMl0oZm4oZGlydHkpKTtcblx0XHRpZiAoJCRzY29wZS5kaXJ0eSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gbGV0cztcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiBsZXRzID09PSAnb2JqZWN0Jykge1xuXHRcdFx0Y29uc3QgbWVyZ2VkID0gW107XG5cdFx0XHRjb25zdCBsZW4gPSBNYXRoLm1heCgkJHNjb3BlLmRpcnR5Lmxlbmd0aCwgbGV0cy5sZW5ndGgpO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuXHRcdFx0XHRtZXJnZWRbaV0gPSAkJHNjb3BlLmRpcnR5W2ldIHwgbGV0c1tpXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtZXJnZWQ7XG5cdFx0fVxuXHRcdHJldHVybiAkJHNjb3BlLmRpcnR5IHwgbGV0cztcblx0fVxuXHRyZXR1cm4gJCRzY29wZS5kaXJ0eTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9zbG90X2Jhc2UoXG5cdHNsb3QsXG5cdHNsb3RfZGVmaW5pdGlvbixcblx0Y3R4LFxuXHQkJHNjb3BlLFxuXHRzbG90X2NoYW5nZXMsXG5cdGdldF9zbG90X2NvbnRleHRfZm5cbikge1xuXHRpZiAoc2xvdF9jaGFuZ2VzKSB7XG5cdFx0Y29uc3Qgc2xvdF9jb250ZXh0ID0gZ2V0X3Nsb3RfY29udGV4dChzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZ2V0X3Nsb3RfY29udGV4dF9mbik7XG5cdFx0c2xvdC5wKHNsb3RfY29udGV4dCwgc2xvdF9jaGFuZ2VzKTtcblx0fVxufVxuXG4vKiogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX3Nsb3QoXG5cdHNsb3QsXG5cdHNsb3RfZGVmaW5pdGlvbixcblx0Y3R4LFxuXHQkJHNjb3BlLFxuXHRkaXJ0eSxcblx0Z2V0X3Nsb3RfY2hhbmdlc19mbixcblx0Z2V0X3Nsb3RfY29udGV4dF9mblxuKSB7XG5cdGNvbnN0IHNsb3RfY2hhbmdlcyA9IGdldF9zbG90X2NoYW5nZXMoc2xvdF9kZWZpbml0aW9uLCAkJHNjb3BlLCBkaXJ0eSwgZ2V0X3Nsb3RfY2hhbmdlc19mbik7XG5cdHVwZGF0ZV9zbG90X2Jhc2Uoc2xvdCwgc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIHNsb3RfY2hhbmdlcywgZ2V0X3Nsb3RfY29udGV4dF9mbik7XG59XG5cbi8qKiBAcmV0dXJucyB7YW55W10gfCAtMX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfYWxsX2RpcnR5X2Zyb21fc2NvcGUoJCRzY29wZSkge1xuXHRpZiAoJCRzY29wZS5jdHgubGVuZ3RoID4gMzIpIHtcblx0XHRjb25zdCBkaXJ0eSA9IFtdO1xuXHRcdGNvbnN0IGxlbmd0aCA9ICQkc2NvcGUuY3R4Lmxlbmd0aCAvIDMyO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdGRpcnR5W2ldID0gLTE7XG5cdFx0fVxuXHRcdHJldHVybiBkaXJ0eTtcblx0fVxuXHRyZXR1cm4gLTE7XG59XG5cbi8qKiBAcmV0dXJucyB7e319ICovXG5leHBvcnQgZnVuY3Rpb24gZXhjbHVkZV9pbnRlcm5hbF9wcm9wcyhwcm9wcykge1xuXHRjb25zdCByZXN1bHQgPSB7fTtcblx0Zm9yIChjb25zdCBrIGluIHByb3BzKSBpZiAoa1swXSAhPT0gJyQnKSByZXN1bHRba10gPSBwcm9wc1trXTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIEByZXR1cm5zIHt7fX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlX3Jlc3RfcHJvcHMocHJvcHMsIGtleXMpIHtcblx0Y29uc3QgcmVzdCA9IHt9O1xuXHRrZXlzID0gbmV3IFNldChrZXlzKTtcblx0Zm9yIChjb25zdCBrIGluIHByb3BzKSBpZiAoIWtleXMuaGFzKGspICYmIGtbMF0gIT09ICckJykgcmVzdFtrXSA9IHByb3BzW2tdO1xuXHRyZXR1cm4gcmVzdDtcbn1cblxuLyoqIEByZXR1cm5zIHt7fX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlX3Nsb3RzKHNsb3RzKSB7XG5cdGNvbnN0IHJlc3VsdCA9IHt9O1xuXHRmb3IgKGNvbnN0IGtleSBpbiBzbG90cykge1xuXHRcdHJlc3VsdFtrZXldID0gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogQHJldHVybnMgeyh0aGlzOiBhbnksIC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uY2UoZm4pIHtcblx0bGV0IHJhbiA9IGZhbHNlO1xuXHRyZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblx0XHRpZiAocmFuKSByZXR1cm47XG5cdFx0cmFuID0gdHJ1ZTtcblx0XHRmbi5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuXHR9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbnVsbF90b19lbXB0eSh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRfc3RvcmVfdmFsdWUoc3RvcmUsIHJldCwgdmFsdWUpIHtcblx0c3RvcmUuc2V0KHZhbHVlKTtcblx0cmV0dXJuIHJldDtcbn1cblxuZXhwb3J0IGNvbnN0IGhhc19wcm9wID0gKG9iaiwgcHJvcCkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBhY3Rpb25fZGVzdHJveWVyKGFjdGlvbl9yZXN1bHQpIHtcblx0cmV0dXJuIGFjdGlvbl9yZXN1bHQgJiYgaXNfZnVuY3Rpb24oYWN0aW9uX3Jlc3VsdC5kZXN0cm95KSA/IGFjdGlvbl9yZXN1bHQuZGVzdHJveSA6IG5vb3A7XG59XG5cbi8qKiBAcGFyYW0ge251bWJlciB8IHN0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtbbnVtYmVyLCBzdHJpbmddfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRfY3NzX3VuaXQodmFsdWUpIHtcblx0Y29uc3Qgc3BsaXQgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLm1hdGNoKC9eXFxzKigtP1tcXGQuXSspKFteXFxzXSopXFxzKiQvKTtcblx0cmV0dXJuIHNwbGl0ID8gW3BhcnNlRmxvYXQoc3BsaXRbMV0pLCBzcGxpdFsyXSB8fCAncHgnXSA6IFsvKiogQHR5cGUge251bWJlcn0gKi8gKHZhbHVlKSwgJ3B4J107XG59XG5cbmV4cG9ydCBjb25zdCBjb250ZW50ZWRpdGFibGVfdHJ1dGh5X3ZhbHVlcyA9IFsnJywgdHJ1ZSwgMSwgJ3RydWUnLCAnY29udGVudGVkaXRhYmxlJ107XG4iLCAiLyoqIEB0eXBlIHt0eXBlb2YgZ2xvYmFsVGhpc30gKi9cbmV4cG9ydCBjb25zdCBnbG9iYWxzID1cblx0dHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcblx0XHQ/IHdpbmRvd1xuXHRcdDogdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnXG5cdFx0PyBnbG9iYWxUaGlzXG5cdFx0OiAvLyBAdHMtaWdub3JlIE5vZGUgdHlwaW5ncyBoYXZlIHRoaXNcblx0XHQgIGdsb2JhbDtcbiIsICJpbXBvcnQgeyBnbG9iYWxzIH0gZnJvbSAnLi9nbG9iYWxzLmpzJztcblxuLyoqXG4gKiBSZXNpemUgb2JzZXJ2ZXIgc2luZ2xldG9uLlxuICogT25lIGxpc3RlbmVyIHBlciBlbGVtZW50IG9ubHkhXG4gKiBodHRwczovL2dyb3Vwcy5nb29nbGUuY29tL2EvY2hyb21pdW0ub3JnL2cvYmxpbmstZGV2L2MvejZpZW5PTlViNUEvbS9GNS1WY1VadEJBQUpcbiAqL1xuZXhwb3J0IGNsYXNzIFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uIHtcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEByZWFkb25seVxuXHQgKiBAdHlwZSB7V2Vha01hcDxFbGVtZW50LCBpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLkxpc3RlbmVyPn1cblx0ICovXG5cdF9saXN0ZW5lcnMgPSAnV2Vha01hcCcgaW4gZ2xvYmFscyA/IG5ldyBXZWFrTWFwKCkgOiB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEB0eXBlIHtSZXNpemVPYnNlcnZlcn1cblx0ICovXG5cdF9vYnNlcnZlciA9IHVuZGVmaW5lZDtcblxuXHQvKiogQHR5cGUge1Jlc2l6ZU9ic2VydmVyT3B0aW9uc30gKi9cblx0b3B0aW9ucztcblxuXHQvKiogQHBhcmFtIHtSZXNpemVPYnNlcnZlck9wdGlvbnN9IG9wdGlvbnMgKi9cblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG5cdCAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5MaXN0ZW5lcn0gbGlzdGVuZXJcblx0ICogQHJldHVybnMgeygpID0+IHZvaWR9XG5cdCAqL1xuXHRvYnNlcnZlKGVsZW1lbnQsIGxpc3RlbmVyKSB7XG5cdFx0dGhpcy5fbGlzdGVuZXJzLnNldChlbGVtZW50LCBsaXN0ZW5lcik7XG5cdFx0dGhpcy5fZ2V0T2JzZXJ2ZXIoKS5vYnNlcnZlKGVsZW1lbnQsIHRoaXMub3B0aW9ucyk7XG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdHRoaXMuX2xpc3RlbmVycy5kZWxldGUoZWxlbWVudCk7XG5cdFx0XHR0aGlzLl9vYnNlcnZlci51bm9ic2VydmUoZWxlbWVudCk7IC8vIHRoaXMgbGluZSBjYW4gcHJvYmFibHkgYmUgcmVtb3ZlZFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRPYnNlcnZlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0dGhpcy5fb2JzZXJ2ZXIgPz9cblx0XHRcdCh0aGlzLl9vYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuXHRcdFx0XHRmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcblx0XHRcdFx0XHRSZXNpemVPYnNlcnZlclNpbmdsZXRvbi5lbnRyaWVzLnNldChlbnRyeS50YXJnZXQsIGVudHJ5KTtcblx0XHRcdFx0XHR0aGlzLl9saXN0ZW5lcnMuZ2V0KGVudHJ5LnRhcmdldCk/LihlbnRyeSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pKVxuXHRcdCk7XG5cdH1cbn1cblxuLy8gTmVlZHMgdG8gYmUgd3JpdHRlbiBsaWtlIHRoaXMgdG8gcGFzcyB0aGUgdHJlZS1zaGFrZS10ZXN0XG5SZXNpemVPYnNlcnZlclNpbmdsZXRvbi5lbnRyaWVzID0gJ1dlYWtNYXAnIGluIGdsb2JhbHMgPyBuZXcgV2Vha01hcCgpIDogdW5kZWZpbmVkO1xuIiwgImltcG9ydCB7IGNvbnRlbnRlZGl0YWJsZV90cnV0aHlfdmFsdWVzLCBoYXNfcHJvcCB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG5pbXBvcnQgeyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbiB9IGZyb20gJy4vUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24uanMnO1xuXG4vLyBUcmFjayB3aGljaCBub2RlcyBhcmUgY2xhaW1lZCBkdXJpbmcgaHlkcmF0aW9uLiBVbmNsYWltZWQgbm9kZXMgY2FuIHRoZW4gYmUgcmVtb3ZlZCBmcm9tIHRoZSBET01cbi8vIGF0IHRoZSBlbmQgb2YgaHlkcmF0aW9uIHdpdGhvdXQgdG91Y2hpbmcgdGhlIHJlbWFpbmluZyBub2Rlcy5cbmxldCBpc19oeWRyYXRpbmcgPSBmYWxzZTtcblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0X2h5ZHJhdGluZygpIHtcblx0aXNfaHlkcmF0aW5nID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuZF9oeWRyYXRpbmcoKSB7XG5cdGlzX2h5ZHJhdGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoXG4gKiBAcGFyYW0geyhpbmRleDogbnVtYmVyKSA9PiBudW1iZXJ9IGtleVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiB1cHBlcl9ib3VuZChsb3csIGhpZ2gsIGtleSwgdmFsdWUpIHtcblx0Ly8gUmV0dXJuIGZpcnN0IGluZGV4IG9mIHZhbHVlIGxhcmdlciB0aGFuIGlucHV0IHZhbHVlIGluIHRoZSByYW5nZSBbbG93LCBoaWdoKVxuXHR3aGlsZSAobG93IDwgaGlnaCkge1xuXHRcdGNvbnN0IG1pZCA9IGxvdyArICgoaGlnaCAtIGxvdykgPj4gMSk7XG5cdFx0aWYgKGtleShtaWQpIDw9IHZhbHVlKSB7XG5cdFx0XHRsb3cgPSBtaWQgKyAxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRoaWdoID0gbWlkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbG93O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZUV4fSB0YXJnZXRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBpbml0X2h5ZHJhdGUodGFyZ2V0KSB7XG5cdGlmICh0YXJnZXQuaHlkcmF0ZV9pbml0KSByZXR1cm47XG5cdHRhcmdldC5oeWRyYXRlX2luaXQgPSB0cnVlO1xuXHQvLyBXZSBrbm93IHRoYXQgYWxsIGNoaWxkcmVuIGhhdmUgY2xhaW1fb3JkZXIgdmFsdWVzIHNpbmNlIHRoZSB1bmNsYWltZWQgaGF2ZSBiZWVuIGRldGFjaGVkIGlmIHRhcmdldCBpcyBub3QgPGhlYWQ+XG5cblx0bGV0IGNoaWxkcmVuID0gLyoqIEB0eXBlIHtBcnJheUxpa2U8Tm9kZUV4Mj59ICovICh0YXJnZXQuY2hpbGROb2Rlcyk7XG5cdC8vIElmIHRhcmdldCBpcyA8aGVhZD4sIHRoZXJlIG1heSBiZSBjaGlsZHJlbiB3aXRob3V0IGNsYWltX29yZGVyXG5cdGlmICh0YXJnZXQubm9kZU5hbWUgPT09ICdIRUFEJykge1xuXHRcdGNvbnN0IG15X2NoaWxkcmVuID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3Qgbm9kZSA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKG5vZGUuY2xhaW1fb3JkZXIgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRteV9jaGlsZHJlbi5wdXNoKG5vZGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjaGlsZHJlbiA9IG15X2NoaWxkcmVuO1xuXHR9XG5cdC8qXG5cdCAqIFJlb3JkZXIgY2xhaW1lZCBjaGlsZHJlbiBvcHRpbWFsbHkuXG5cdCAqIFdlIGNhbiByZW9yZGVyIGNsYWltZWQgY2hpbGRyZW4gb3B0aW1hbGx5IGJ5IGZpbmRpbmcgdGhlIGxvbmdlc3Qgc3Vic2VxdWVuY2Ugb2Zcblx0ICogbm9kZXMgdGhhdCBhcmUgYWxyZWFkeSBjbGFpbWVkIGluIG9yZGVyIGFuZCBvbmx5IG1vdmluZyB0aGUgcmVzdC4gVGhlIGxvbmdlc3Rcblx0ICogc3Vic2VxdWVuY2Ugb2Ygbm9kZXMgdGhhdCBhcmUgY2xhaW1lZCBpbiBvcmRlciBjYW4gYmUgZm91bmQgYnlcblx0ICogY29tcHV0aW5nIHRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgLmNsYWltX29yZGVyIHZhbHVlcy5cblx0ICpcblx0ICogVGhpcyBhbGdvcml0aG0gaXMgb3B0aW1hbCBpbiBnZW5lcmF0aW5nIHRoZSBsZWFzdCBhbW91bnQgb2YgcmVvcmRlciBvcGVyYXRpb25zXG5cdCAqIHBvc3NpYmxlLlxuXHQgKlxuXHQgKiBQcm9vZjpcblx0ICogV2Uga25vdyB0aGF0LCBnaXZlbiBhIHNldCBvZiByZW9yZGVyaW5nIG9wZXJhdGlvbnMsIHRoZSBub2RlcyB0aGF0IGRvIG5vdCBtb3ZlXG5cdCAqIGFsd2F5cyBmb3JtIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2UsIHNpbmNlIHRoZXkgZG8gbm90IG1vdmUgYW1vbmcgZWFjaCBvdGhlclxuXHQgKiBtZWFuaW5nIHRoYXQgdGhleSBtdXN0IGJlIGFscmVhZHkgb3JkZXJlZCBhbW9uZyBlYWNoIG90aGVyLiBUaHVzLCB0aGUgbWF4aW1hbFxuXHQgKiBzZXQgb2Ygbm9kZXMgdGhhdCBkbyBub3QgbW92ZSBmb3JtIGEgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlLlxuXHQgKi9cblx0Ly8gQ29tcHV0ZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Vcblx0Ly8gbTogc3Vic2VxdWVuY2UgbGVuZ3RoIGogPT4gaW5kZXggayBvZiBzbWFsbGVzdCB2YWx1ZSB0aGF0IGVuZHMgYW4gaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiBsZW5ndGggalxuXHRjb25zdCBtID0gbmV3IEludDMyQXJyYXkoY2hpbGRyZW4ubGVuZ3RoICsgMSk7XG5cdC8vIFByZWRlY2Vzc29yIGluZGljZXMgKyAxXG5cdGNvbnN0IHAgPSBuZXcgSW50MzJBcnJheShjaGlsZHJlbi5sZW5ndGgpO1xuXHRtWzBdID0gLTE7XG5cdGxldCBsb25nZXN0ID0gMDtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdGNvbnN0IGN1cnJlbnQgPSBjaGlsZHJlbltpXS5jbGFpbV9vcmRlcjtcblx0XHQvLyBGaW5kIHRoZSBsYXJnZXN0IHN1YnNlcXVlbmNlIGxlbmd0aCBzdWNoIHRoYXQgaXQgZW5kcyBpbiBhIHZhbHVlIGxlc3MgdGhhbiBvdXIgY3VycmVudCB2YWx1ZVxuXHRcdC8vIHVwcGVyX2JvdW5kIHJldHVybnMgZmlyc3QgZ3JlYXRlciB2YWx1ZSwgc28gd2Ugc3VidHJhY3Qgb25lXG5cdFx0Ly8gd2l0aCBmYXN0IHBhdGggZm9yIHdoZW4gd2UgYXJlIG9uIHRoZSBjdXJyZW50IGxvbmdlc3Qgc3Vic2VxdWVuY2Vcblx0XHRjb25zdCBzZXFfbGVuID1cblx0XHRcdChsb25nZXN0ID4gMCAmJiBjaGlsZHJlblttW2xvbmdlc3RdXS5jbGFpbV9vcmRlciA8PSBjdXJyZW50XG5cdFx0XHRcdD8gbG9uZ2VzdCArIDFcblx0XHRcdFx0OiB1cHBlcl9ib3VuZCgxLCBsb25nZXN0LCAoaWR4KSA9PiBjaGlsZHJlblttW2lkeF1dLmNsYWltX29yZGVyLCBjdXJyZW50KSkgLSAxO1xuXHRcdHBbaV0gPSBtW3NlcV9sZW5dICsgMTtcblx0XHRjb25zdCBuZXdfbGVuID0gc2VxX2xlbiArIDE7XG5cdFx0Ly8gV2UgY2FuIGd1YXJhbnRlZSB0aGF0IGN1cnJlbnQgaXMgdGhlIHNtYWxsZXN0IHZhbHVlLiBPdGhlcndpc2UsIHdlIHdvdWxkIGhhdmUgZ2VuZXJhdGVkIGEgbG9uZ2VyIHNlcXVlbmNlLlxuXHRcdG1bbmV3X2xlbl0gPSBpO1xuXHRcdGxvbmdlc3QgPSBNYXRoLm1heChuZXdfbGVuLCBsb25nZXN0KTtcblx0fVxuXHQvLyBUaGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIG5vZGVzIChpbml0aWFsbHkgcmV2ZXJzZWQpXG5cblx0LyoqXG5cdCAqIEB0eXBlIHtOb2RlRXgyW119XG5cdCAqL1xuXHRjb25zdCBsaXMgPSBbXTtcblx0Ly8gVGhlIHJlc3Qgb2YgdGhlIG5vZGVzLCBub2RlcyB0aGF0IHdpbGwgYmUgbW92ZWRcblxuXHQvKipcblx0ICogQHR5cGUge05vZGVFeDJbXX1cblx0ICovXG5cdGNvbnN0IHRvX21vdmUgPSBbXTtcblx0bGV0IGxhc3QgPSBjaGlsZHJlbi5sZW5ndGggLSAxO1xuXHRmb3IgKGxldCBjdXIgPSBtW2xvbmdlc3RdICsgMTsgY3VyICE9IDA7IGN1ciA9IHBbY3VyIC0gMV0pIHtcblx0XHRsaXMucHVzaChjaGlsZHJlbltjdXIgLSAxXSk7XG5cdFx0Zm9yICg7IGxhc3QgPj0gY3VyOyBsYXN0LS0pIHtcblx0XHRcdHRvX21vdmUucHVzaChjaGlsZHJlbltsYXN0XSk7XG5cdFx0fVxuXHRcdGxhc3QtLTtcblx0fVxuXHRmb3IgKDsgbGFzdCA+PSAwOyBsYXN0LS0pIHtcblx0XHR0b19tb3ZlLnB1c2goY2hpbGRyZW5bbGFzdF0pO1xuXHR9XG5cdGxpcy5yZXZlcnNlKCk7XG5cdC8vIFdlIHNvcnQgdGhlIG5vZGVzIGJlaW5nIG1vdmVkIHRvIGd1YXJhbnRlZSB0aGF0IHRoZWlyIGluc2VydGlvbiBvcmRlciBtYXRjaGVzIHRoZSBjbGFpbSBvcmRlclxuXHR0b19tb3ZlLnNvcnQoKGEsIGIpID0+IGEuY2xhaW1fb3JkZXIgLSBiLmNsYWltX29yZGVyKTtcblx0Ly8gRmluYWxseSwgd2UgbW92ZSB0aGUgbm9kZXNcblx0Zm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgdG9fbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdHdoaWxlIChqIDwgbGlzLmxlbmd0aCAmJiB0b19tb3ZlW2ldLmNsYWltX29yZGVyID49IGxpc1tqXS5jbGFpbV9vcmRlcikge1xuXHRcdFx0aisrO1xuXHRcdH1cblx0XHRjb25zdCBhbmNob3IgPSBqIDwgbGlzLmxlbmd0aCA/IGxpc1tqXSA6IG51bGw7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSh0b19tb3ZlW2ldLCBhbmNob3IpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmQodGFyZ2V0LCBub2RlKSB7XG5cdHRhcmdldC5hcHBlbmRDaGlsZChub2RlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlX3NoZWV0X2lkXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZF9zdHlsZXModGFyZ2V0LCBzdHlsZV9zaGVldF9pZCwgc3R5bGVzKSB7XG5cdGNvbnN0IGFwcGVuZF9zdHlsZXNfdG8gPSBnZXRfcm9vdF9mb3Jfc3R5bGUodGFyZ2V0KTtcblx0aWYgKCFhcHBlbmRfc3R5bGVzX3RvLmdldEVsZW1lbnRCeUlkKHN0eWxlX3NoZWV0X2lkKSkge1xuXHRcdGNvbnN0IHN0eWxlID0gZWxlbWVudCgnc3R5bGUnKTtcblx0XHRzdHlsZS5pZCA9IHN0eWxlX3NoZWV0X2lkO1xuXHRcdHN0eWxlLnRleHRDb250ZW50ID0gc3R5bGVzO1xuXHRcdGFwcGVuZF9zdHlsZXNoZWV0KGFwcGVuZF9zdHlsZXNfdG8sIHN0eWxlKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybnMge1NoYWRvd1Jvb3QgfCBEb2N1bWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9yb290X2Zvcl9zdHlsZShub2RlKSB7XG5cdGlmICghbm9kZSkgcmV0dXJuIGRvY3VtZW50O1xuXHRjb25zdCByb290ID0gbm9kZS5nZXRSb290Tm9kZSA/IG5vZGUuZ2V0Um9vdE5vZGUoKSA6IG5vZGUub3duZXJEb2N1bWVudDtcblx0aWYgKHJvb3QgJiYgLyoqIEB0eXBlIHtTaGFkb3dSb290fSAqLyAocm9vdCkuaG9zdCkge1xuXHRcdHJldHVybiAvKiogQHR5cGUge1NoYWRvd1Jvb3R9ICovIChyb290KTtcblx0fVxuXHRyZXR1cm4gbm9kZS5vd25lckRvY3VtZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybnMge0NTU1N0eWxlU2hlZXR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRfZW1wdHlfc3R5bGVzaGVldChub2RlKSB7XG5cdGNvbnN0IHN0eWxlX2VsZW1lbnQgPSBlbGVtZW50KCdzdHlsZScpO1xuXHQvLyBGb3IgdHJhbnNpdGlvbnMgdG8gd29yayB3aXRob3V0ICdzdHlsZS1zcmM6IHVuc2FmZS1pbmxpbmUnIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5LFxuXHQvLyB0aGVzZSBlbXB0eSB0YWdzIG5lZWQgdG8gYmUgYWxsb3dlZCB3aXRoIGEgaGFzaCBhcyBhIHdvcmthcm91bmQgdW50aWwgd2UgbW92ZSB0byB0aGUgV2ViIEFuaW1hdGlvbnMgQVBJLlxuXHQvLyBVc2luZyB0aGUgaGFzaCBmb3IgdGhlIGVtcHR5IHN0cmluZyAoZm9yIGFuIGVtcHR5IHRhZykgd29ya3MgaW4gYWxsIGJyb3dzZXJzIGV4Y2VwdCBTYWZhcmkuXG5cdC8vIFNvIGFzIGEgd29ya2Fyb3VuZCBmb3IgdGhlIHdvcmthcm91bmQsIHdoZW4gd2UgYXBwZW5kIGVtcHR5IHN0eWxlIHRhZ3Mgd2Ugc2V0IHRoZWlyIGNvbnRlbnQgdG8gLyogZW1wdHkgKi8uXG5cdC8vIFRoZSBoYXNoICdzaGEyNTYtOU9sTk8wRE5FZWFWekhMNFJad0NMc0JIQThXQlE4dG9CcC80RjVYVjJuYz0nIHdpbGwgdGhlbiB3b3JrIGV2ZW4gaW4gU2FmYXJpLlxuXHRzdHlsZV9lbGVtZW50LnRleHRDb250ZW50ID0gJy8qIGVtcHR5ICovJztcblx0YXBwZW5kX3N0eWxlc2hlZXQoZ2V0X3Jvb3RfZm9yX3N0eWxlKG5vZGUpLCBzdHlsZV9lbGVtZW50KTtcblx0cmV0dXJuIHN0eWxlX2VsZW1lbnQuc2hlZXQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTaGFkb3dSb290IHwgRG9jdW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7SFRNTFN0eWxlRWxlbWVudH0gc3R5bGVcbiAqIEByZXR1cm5zIHtDU1NTdHlsZVNoZWV0fVxuICovXG5mdW5jdGlvbiBhcHBlbmRfc3R5bGVzaGVldChub2RlLCBzdHlsZSkge1xuXHRhcHBlbmQoLyoqIEB0eXBlIHtEb2N1bWVudH0gKi8gKG5vZGUpLmhlYWQgfHwgbm9kZSwgc3R5bGUpO1xuXHRyZXR1cm4gc3R5bGUuc2hlZXQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlRXh9IHRhcmdldFxuICogQHBhcmFtIHtOb2RlRXh9IG5vZGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpIHtcblx0aWYgKGlzX2h5ZHJhdGluZykge1xuXHRcdGluaXRfaHlkcmF0ZSh0YXJnZXQpO1xuXHRcdGlmIChcblx0XHRcdHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID09PSB1bmRlZmluZWQgfHxcblx0XHRcdCh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCAhPT0gbnVsbCAmJiB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZC5wYXJlbnROb2RlICE9PSB0YXJnZXQpXG5cdFx0KSB7XG5cdFx0XHR0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IHRhcmdldC5maXJzdENoaWxkO1xuXHRcdH1cblx0XHQvLyBTa2lwIG5vZGVzIG9mIHVuZGVmaW5lZCBvcmRlcmluZ1xuXHRcdHdoaWxlICh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCAhPT0gbnVsbCAmJiB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZC5jbGFpbV9vcmRlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLm5leHRTaWJsaW5nO1xuXHRcdH1cblx0XHRpZiAobm9kZSAhPT0gdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQpIHtcblx0XHRcdC8vIFdlIG9ubHkgaW5zZXJ0IGlmIHRoZSBvcmRlcmluZyBvZiB0aGlzIG5vZGUgc2hvdWxkIGJlIG1vZGlmaWVkIG9yIHRoZSBwYXJlbnQgbm9kZSBpcyBub3QgdGFyZ2V0XG5cdFx0XHRpZiAobm9kZS5jbGFpbV9vcmRlciAhPT0gdW5kZWZpbmVkIHx8IG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0KSB7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IG5vZGUubmV4dFNpYmxpbmc7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0IHx8IG5vZGUubmV4dFNpYmxpbmcgIT09IG51bGwpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQobm9kZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge05vZGV9IFthbmNob3JdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluc2VydCh0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuXHR0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIGFuY2hvciB8fCBudWxsKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGVFeH0gdGFyZ2V0XG4gKiBAcGFyYW0ge05vZGVFeH0gbm9kZVxuICogQHBhcmFtIHtOb2RlRXh9IFthbmNob3JdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluc2VydF9oeWRyYXRpb24odGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcblx0aWYgKGlzX2h5ZHJhdGluZyAmJiAhYW5jaG9yKSB7XG5cdFx0YXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpO1xuXHR9IGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0IHx8IG5vZGUubmV4dFNpYmxpbmcgIT0gYW5jaG9yKSB7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCBhbmNob3IgfHwgbnVsbCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0YWNoKG5vZGUpIHtcblx0aWYgKG5vZGUucGFyZW50Tm9kZSkge1xuXHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcblx0fVxufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lfZWFjaChpdGVyYXRpb25zLCBkZXRhY2hpbmcpIHtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0aWYgKGl0ZXJhdGlvbnNbaV0pIGl0ZXJhdGlvbnNbaV0uZChkZXRhY2hpbmcpO1xuXHR9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtrZXlvZiBIVE1MRWxlbWVudFRhZ05hbWVNYXB9IEtcbiAqIEBwYXJhbSB7S30gbmFtZVxuICogQHJldHVybnMge0hUTUxFbGVtZW50VGFnTmFtZU1hcFtLXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVsZW1lbnQobmFtZSkge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge2tleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcH0gS1xuICogQHBhcmFtIHtLfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gaXNcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudFRhZ05hbWVNYXBbS119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbGVtZW50X2lzKG5hbWUsIGlzKSB7XG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUsIHsgaXMgfSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSB7a2V5b2YgVH0gS1xuICogQHBhcmFtIHtUfSBvYmpcbiAqIEBwYXJhbSB7S1tdfSBleGNsdWRlXG4gKiBAcmV0dXJucyB7UGljazxULCBFeGNsdWRlPGtleW9mIFQsIEs+Pn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdF93aXRob3V0X3Byb3BlcnRpZXMob2JqLCBleGNsdWRlKSB7XG5cdGNvbnN0IHRhcmdldCA9IC8qKiBAdHlwZSB7UGljazxULCBFeGNsdWRlPGtleW9mIFQsIEs+Pn0gKi8gKHt9KTtcblx0Zm9yIChjb25zdCBrIGluIG9iaikge1xuXHRcdGlmIChcblx0XHRcdGhhc19wcm9wKG9iaiwgaykgJiZcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdGV4Y2x1ZGUuaW5kZXhPZihrKSA9PT0gLTFcblx0XHQpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdHRhcmdldFtrXSA9IG9ialtrXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge2tleW9mIFNWR0VsZW1lbnRUYWdOYW1lTWFwfSBLXG4gKiBAcGFyYW0ge0t9IG5hbWVcbiAqIEByZXR1cm5zIHtTVkdFbGVtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3ZnX2VsZW1lbnQobmFtZSkge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5hbWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhXG4gKiBAcmV0dXJucyB7VGV4dH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRleHQoZGF0YSkge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGF0YSk7XG59XG5cbi8qKlxuICogQHJldHVybnMge1RleHR9ICovXG5leHBvcnQgZnVuY3Rpb24gc3BhY2UoKSB7XG5cdHJldHVybiB0ZXh0KCcgJyk7XG59XG5cbi8qKlxuICogQHJldHVybnMge1RleHR9ICovXG5leHBvcnQgZnVuY3Rpb24gZW1wdHkoKSB7XG5cdHJldHVybiB0ZXh0KCcnKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICogQHJldHVybnMge0NvbW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21tZW50KGNvbnRlbnQpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoY29udGVudCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3R9IGhhbmRsZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbiB8IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zIHwgRXZlbnRMaXN0ZW5lck9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMgeygpID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW4obm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcblx0bm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcblx0cmV0dXJuICgpID0+IG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQHJldHVybnMgeyhldmVudDogYW55KSA9PiBhbnl9ICovXG5leHBvcnQgZnVuY3Rpb24gcHJldmVudF9kZWZhdWx0KGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XG5cdH07XG59XG5cbi8qKlxuICogQHJldHVybnMgeyhldmVudDogYW55KSA9PiBhbnl9ICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcF9wcm9wYWdhdGlvbihmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBhbnkpID0+IGFueX0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9wX2ltbWVkaWF0ZV9wcm9wYWdhdGlvbihmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBhbnkpID0+IHZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2VsZihmbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdGlmIChldmVudC50YXJnZXQgPT09IHRoaXMpIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuXHR9O1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHsoZXZlbnQ6IGFueSkgPT4gdm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cnVzdGVkKGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0aWYgKGV2ZW50LmlzVHJ1c3RlZCkgZm4uY2FsbCh0aGlzLCBldmVudCk7XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW3ZhbHVlXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcblx0aWYgKHZhbHVlID09IG51bGwpIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG5cdGVsc2UgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSkgIT09IHZhbHVlKSBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cbi8qKlxuICogTGlzdCBvZiBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGFsd2F5cyBiZSBzZXQgdGhyb3VnaCB0aGUgYXR0ciBtZXRob2QsXG4gKiBiZWNhdXNlIHVwZGF0aW5nIHRoZW0gdGhyb3VnaCB0aGUgcHJvcGVydHkgc2V0dGVyIGRvZXNuJ3Qgd29yayByZWxpYWJseS5cbiAqIEluIHRoZSBleGFtcGxlIG9mIGB3aWR0aGAvYGhlaWdodGAsIHRoZSBwcm9ibGVtIGlzIHRoYXQgdGhlIHNldHRlciBvbmx5XG4gKiBhY2NlcHRzIG51bWVyaWMgdmFsdWVzLCBidXQgdGhlIGF0dHJpYnV0ZSBjYW4gYWxzbyBiZSBzZXQgdG8gYSBzdHJpbmcgbGlrZSBgNTAlYC5cbiAqIElmIHRoaXMgbGlzdCBiZWNvbWVzIHRvbyBiaWcsIHJldGhpbmsgdGhpcyBhcHByb2FjaC5cbiAqL1xuY29uc3QgYWx3YXlzX3NldF90aHJvdWdoX3NldF9hdHRyaWJ1dGUgPSBbJ3dpZHRoJywgJ2hlaWdodCddO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gbm9kZVxuICogQHBhcmFtIHt7IFt4OiBzdHJpbmddOiBzdHJpbmcgfX0gYXR0cmlidXRlc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfYXR0cmlidXRlcyhub2RlLCBhdHRyaWJ1dGVzKSB7XG5cdC8vIEB0cy1pZ25vcmVcblx0Y29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhub2RlLl9fcHJvdG9fXyk7XG5cdGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcblx0XHRpZiAoYXR0cmlidXRlc1trZXldID09IG51bGwpIHtcblx0XHRcdG5vZGUucmVtb3ZlQXR0cmlidXRlKGtleSk7XG5cdFx0fSBlbHNlIGlmIChrZXkgPT09ICdzdHlsZScpIHtcblx0XHRcdG5vZGUuc3R5bGUuY3NzVGV4dCA9IGF0dHJpYnV0ZXNba2V5XTtcblx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ19fdmFsdWUnKSB7XG5cdFx0XHQvKiogQHR5cGUge2FueX0gKi8gKG5vZGUpLnZhbHVlID0gbm9kZVtrZXldID0gYXR0cmlidXRlc1trZXldO1xuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRkZXNjcmlwdG9yc1trZXldICYmXG5cdFx0XHRkZXNjcmlwdG9yc1trZXldLnNldCAmJlxuXHRcdFx0YWx3YXlzX3NldF90aHJvdWdoX3NldF9hdHRyaWJ1dGUuaW5kZXhPZihrZXkpID09PSAtMVxuXHRcdCkge1xuXHRcdFx0bm9kZVtrZXldID0gYXR0cmlidXRlc1trZXldO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhdHRyKG5vZGUsIGtleSwgYXR0cmlidXRlc1trZXldKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IG5vZGVcbiAqIEBwYXJhbSB7eyBbeDogc3RyaW5nXTogc3RyaW5nIH19IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3N2Z19hdHRyaWJ1dGVzKG5vZGUsIGF0dHJpYnV0ZXMpIHtcblx0Zm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuXHRcdGF0dHIobm9kZSwga2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gZGF0YV9tYXBcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2N1c3RvbV9lbGVtZW50X2RhdGFfbWFwKG5vZGUsIGRhdGFfbWFwKSB7XG5cdE9iamVjdC5rZXlzKGRhdGFfbWFwKS5mb3JFYWNoKChrZXkpID0+IHtcblx0XHRzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YShub2RlLCBrZXksIGRhdGFfbWFwW2tleV0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YShub2RlLCBwcm9wLCB2YWx1ZSkge1xuXHRjb25zdCBsb3dlciA9IHByb3AudG9Mb3dlckNhc2UoKTsgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggZXhpc3RpbmcgYmVoYXZpb3Igd2UgZG8gbG93ZXJjYXNlIGZpcnN0XG5cdGlmIChsb3dlciBpbiBub2RlKSB7XG5cdFx0bm9kZVtsb3dlcl0gPSB0eXBlb2Ygbm9kZVtsb3dlcl0gPT09ICdib29sZWFuJyAmJiB2YWx1ZSA9PT0gJycgPyB0cnVlIDogdmFsdWU7XG5cdH0gZWxzZSBpZiAocHJvcCBpbiBub2RlKSB7XG5cdFx0bm9kZVtwcm9wXSA9IHR5cGVvZiBub2RlW3Byb3BdID09PSAnYm9vbGVhbicgJiYgdmFsdWUgPT09ICcnID8gdHJ1ZSA6IHZhbHVlO1xuXHR9IGVsc2Uge1xuXHRcdGF0dHIobm9kZSwgcHJvcCwgdmFsdWUpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2R5bmFtaWNfZWxlbWVudF9kYXRhKHRhZykge1xuXHRyZXR1cm4gLy0vLnRlc3QodGFnKSA/IHNldF9jdXN0b21fZWxlbWVudF9kYXRhX21hcCA6IHNldF9hdHRyaWJ1dGVzO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24geGxpbmtfYXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG5cdG5vZGUuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X3N2ZWx0ZV9kYXRhc2V0KG5vZGUpIHtcblx0cmV0dXJuIG5vZGUuZGF0YXNldC5zdmVsdGVIO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHt1bmtub3duW119ICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUoZ3JvdXAsIF9fdmFsdWUsIGNoZWNrZWQpIHtcblx0Y29uc3QgdmFsdWUgPSBuZXcgU2V0KCk7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRpZiAoZ3JvdXBbaV0uY2hlY2tlZCkgdmFsdWUuYWRkKGdyb3VwW2ldLl9fdmFsdWUpO1xuXHR9XG5cdGlmICghY2hlY2tlZCkge1xuXHRcdHZhbHVlLmRlbGV0ZShfX3ZhbHVlKTtcblx0fVxuXHRyZXR1cm4gQXJyYXkuZnJvbSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50W119IGdyb3VwXG4gKiBAcmV0dXJucyB7eyBwKC4uLmlucHV0czogSFRNTElucHV0RWxlbWVudFtdKTogdm9pZDsgcigpOiB2b2lkOyB9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdF9iaW5kaW5nX2dyb3VwKGdyb3VwKSB7XG5cdC8qKlxuXHQgKiBAdHlwZSB7SFRNTElucHV0RWxlbWVudFtdfSAqL1xuXHRsZXQgX2lucHV0cztcblx0cmV0dXJuIHtcblx0XHQvKiBwdXNoICovIHAoLi4uaW5wdXRzKSB7XG5cdFx0XHRfaW5wdXRzID0gaW5wdXRzO1xuXHRcdFx0X2lucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4gZ3JvdXAucHVzaChpbnB1dCkpO1xuXHRcdH0sXG5cdFx0LyogcmVtb3ZlICovIHIoKSB7XG5cdFx0XHRfaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiBncm91cC5zcGxpY2UoZ3JvdXAuaW5kZXhPZihpbnB1dCksIDEpKTtcblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJbXX0gaW5kZXhlc1xuICogQHJldHVybnMge3sgdShuZXdfaW5kZXhlczogbnVtYmVyW10pOiB2b2lkOyBwKC4uLmlucHV0czogSFRNTElucHV0RWxlbWVudFtdKTogdm9pZDsgcjogKCkgPT4gdm9pZDsgfX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRfYmluZGluZ19ncm91cF9keW5hbWljKGdyb3VwLCBpbmRleGVzKSB7XG5cdC8qKlxuXHQgKiBAdHlwZSB7SFRNTElucHV0RWxlbWVudFtdfSAqL1xuXHRsZXQgX2dyb3VwID0gZ2V0X2JpbmRpbmdfZ3JvdXAoZ3JvdXApO1xuXG5cdC8qKlxuXHQgKiBAdHlwZSB7SFRNTElucHV0RWxlbWVudFtdfSAqL1xuXHRsZXQgX2lucHV0cztcblxuXHRmdW5jdGlvbiBnZXRfYmluZGluZ19ncm91cChncm91cCkge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXhlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Z3JvdXAgPSBncm91cFtpbmRleGVzW2ldXSA9IGdyb3VwW2luZGV4ZXNbaV1dIHx8IFtdO1xuXHRcdH1cblx0XHRyZXR1cm4gZ3JvdXA7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGZ1bmN0aW9uIHB1c2goKSB7XG5cdFx0X2lucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4gX2dyb3VwLnB1c2goaW5wdXQpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0ZnVuY3Rpb24gcmVtb3ZlKCkge1xuXHRcdF9pbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IF9ncm91cC5zcGxpY2UoX2dyb3VwLmluZGV4T2YoaW5wdXQpLCAxKSk7XG5cdH1cblx0cmV0dXJuIHtcblx0XHQvKiB1cGRhdGUgKi8gdShuZXdfaW5kZXhlcykge1xuXHRcdFx0aW5kZXhlcyA9IG5ld19pbmRleGVzO1xuXHRcdFx0Y29uc3QgbmV3X2dyb3VwID0gZ2V0X2JpbmRpbmdfZ3JvdXAoZ3JvdXApO1xuXHRcdFx0aWYgKG5ld19ncm91cCAhPT0gX2dyb3VwKSB7XG5cdFx0XHRcdHJlbW92ZSgpO1xuXHRcdFx0XHRfZ3JvdXAgPSBuZXdfZ3JvdXA7XG5cdFx0XHRcdHB1c2goKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qIHB1c2ggKi8gcCguLi5pbnB1dHMpIHtcblx0XHRcdF9pbnB1dHMgPSBpbnB1dHM7XG5cdFx0XHRwdXNoKCk7XG5cdFx0fSxcblx0XHQvKiByZW1vdmUgKi8gcjogcmVtb3ZlXG5cdH07XG59XG5cbi8qKiBAcmV0dXJucyB7bnVtYmVyfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvX251bWJlcih2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgPT09ICcnID8gbnVsbCA6ICt2YWx1ZTtcbn1cblxuLyoqIEByZXR1cm5zIHthbnlbXX0gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aW1lX3Jhbmdlc190b19hcnJheShyYW5nZXMpIHtcblx0Y29uc3QgYXJyYXkgPSBbXTtcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRhcnJheS5wdXNoKHsgc3RhcnQ6IHJhbmdlcy5zdGFydChpKSwgZW5kOiByYW5nZXMuZW5kKGkpIH0pO1xuXHR9XG5cdHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtDaGlsZE5vZGVbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoaWxkcmVuKGVsZW1lbnQpIHtcblx0cmV0dXJuIEFycmF5LmZyb20oZWxlbWVudC5jaGlsZE5vZGVzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoaWxkTm9kZUFycmF5fSBub2Rlc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGluaXRfY2xhaW1faW5mbyhub2Rlcykge1xuXHRpZiAobm9kZXMuY2xhaW1faW5mbyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0bm9kZXMuY2xhaW1faW5mbyA9IHsgbGFzdF9pbmRleDogMCwgdG90YWxfY2xhaW1lZDogMCB9O1xuXHR9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtDaGlsZE5vZGVFeH0gUlxuICogQHBhcmFtIHtDaGlsZE5vZGVBcnJheX0gbm9kZXNcbiAqIEBwYXJhbSB7KG5vZGU6IENoaWxkTm9kZUV4KSA9PiBub2RlIGlzIFJ9IHByZWRpY2F0ZVxuICogQHBhcmFtIHsobm9kZTogQ2hpbGROb2RlRXgpID0+IENoaWxkTm9kZUV4IHwgdW5kZWZpbmVkfSBwcm9jZXNzX25vZGVcbiAqIEBwYXJhbSB7KCkgPT4gUn0gY3JlYXRlX25vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9udF91cGRhdGVfbGFzdF9pbmRleFxuICogQHJldHVybnMge1J9XG4gKi9cbmZ1bmN0aW9uIGNsYWltX25vZGUobm9kZXMsIHByZWRpY2F0ZSwgcHJvY2Vzc19ub2RlLCBjcmVhdGVfbm9kZSwgZG9udF91cGRhdGVfbGFzdF9pbmRleCA9IGZhbHNlKSB7XG5cdC8vIFRyeSB0byBmaW5kIG5vZGVzIGluIGFuIG9yZGVyIHN1Y2ggdGhhdCB3ZSBsZW5ndGhlbiB0aGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlXG5cdGluaXRfY2xhaW1faW5mbyhub2Rlcyk7XG5cdGNvbnN0IHJlc3VsdF9ub2RlID0gKCgpID0+IHtcblx0XHQvLyBXZSBmaXJzdCB0cnkgdG8gZmluZCBhbiBlbGVtZW50IGFmdGVyIHRoZSBwcmV2aW91cyBvbmVcblx0XHRmb3IgKGxldCBpID0gbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4OyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblx0XHRcdGlmIChwcmVkaWNhdGUobm9kZSkpIHtcblx0XHRcdFx0Y29uc3QgcmVwbGFjZW1lbnQgPSBwcm9jZXNzX25vZGUobm9kZSk7XG5cdFx0XHRcdGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0bm9kZXMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5vZGVzW2ldID0gcmVwbGFjZW1lbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFkb250X3VwZGF0ZV9sYXN0X2luZGV4KSB7XG5cdFx0XHRcdFx0bm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4ID0gaTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbm9kZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gT3RoZXJ3aXNlLCB3ZSB0cnkgdG8gZmluZCBvbmUgYmVmb3JlXG5cdFx0Ly8gV2UgaXRlcmF0ZSBpbiByZXZlcnNlIHNvIHRoYXQgd2UgZG9uJ3QgZ28gdG9vIGZhciBiYWNrXG5cdFx0Zm9yIChsZXQgaSA9IG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRjb25zdCBub2RlID0gbm9kZXNbaV07XG5cdFx0XHRpZiAocHJlZGljYXRlKG5vZGUpKSB7XG5cdFx0XHRcdGNvbnN0IHJlcGxhY2VtZW50ID0gcHJvY2Vzc19ub2RlKG5vZGUpO1xuXHRcdFx0XHRpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdG5vZGVzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRub2Rlc1tpXSA9IHJlcGxhY2VtZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghZG9udF91cGRhdGVfbGFzdF9pbmRleCkge1xuXHRcdFx0XHRcdG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCA9IGk7XG5cdFx0XHRcdH0gZWxzZSBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdC8vIFNpbmNlIHdlIHNwbGljZWQgYmVmb3JlIHRoZSBsYXN0X2luZGV4LCB3ZSBkZWNyZWFzZSBpdFxuXHRcdFx0XHRcdG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBub2RlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBJZiB3ZSBjYW4ndCBmaW5kIGFueSBtYXRjaGluZyBub2RlLCB3ZSBjcmVhdGUgYSBuZXcgb25lXG5cdFx0cmV0dXJuIGNyZWF0ZV9ub2RlKCk7XG5cdH0pKCk7XG5cdHJlc3VsdF9ub2RlLmNsYWltX29yZGVyID0gbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkO1xuXHRub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQgKz0gMTtcblx0cmV0dXJuIHJlc3VsdF9ub2RlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hpbGROb2RlQXJyYXl9IG5vZGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHt7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfX0gYXR0cmlidXRlc1xuICogQHBhcmFtIHsobmFtZTogc3RyaW5nKSA9PiBFbGVtZW50IHwgU1ZHRWxlbWVudH0gY3JlYXRlX2VsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50IHwgU1ZHRWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBjcmVhdGVfZWxlbWVudCkge1xuXHRyZXR1cm4gY2xhaW1fbm9kZShcblx0XHRub2Rlcyxcblx0XHQvKiogQHJldHVybnMge25vZGUgaXMgRWxlbWVudCB8IFNWR0VsZW1lbnR9ICovXG5cdFx0KG5vZGUpID0+IG5vZGUubm9kZU5hbWUgPT09IG5hbWUsXG5cdFx0LyoqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSAqL1xuXHRcdChub2RlKSA9PiB7XG5cdFx0XHRjb25zdCByZW1vdmUgPSBbXTtcblx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGNvbnN0IGF0dHJpYnV0ZSA9IG5vZGUuYXR0cmlidXRlc1tqXTtcblx0XHRcdFx0aWYgKCFhdHRyaWJ1dGVzW2F0dHJpYnV0ZS5uYW1lXSkge1xuXHRcdFx0XHRcdHJlbW92ZS5wdXNoKGF0dHJpYnV0ZS5uYW1lKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVtb3ZlLmZvckVhY2goKHYpID0+IG5vZGUucmVtb3ZlQXR0cmlidXRlKHYpKTtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fSxcblx0XHQoKSA9PiBjcmVhdGVfZWxlbWVudChuYW1lKVxuXHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hpbGROb2RlQXJyYXl9IG5vZGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHt7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfX0gYXR0cmlidXRlc1xuICogQHJldHVybnMge0VsZW1lbnQgfCBTVkdFbGVtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1fZWxlbWVudChub2RlcywgbmFtZSwgYXR0cmlidXRlcykge1xuXHRyZXR1cm4gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBlbGVtZW50KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoaWxkTm9kZUFycmF5fSBub2Rlc1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7eyBba2V5OiBzdHJpbmddOiBib29sZWFuIH19IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm5zIHtFbGVtZW50IHwgU1ZHRWxlbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYWltX3N2Z19lbGVtZW50KG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzKSB7XG5cdHJldHVybiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIHN2Z19lbGVtZW50KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoaWxkTm9kZUFycmF5fSBub2Rlc1xuICogQHJldHVybnMge1RleHR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGFpbV90ZXh0KG5vZGVzLCBkYXRhKSB7XG5cdHJldHVybiBjbGFpbV9ub2RlKFxuXHRcdG5vZGVzLFxuXHRcdC8qKiBAcmV0dXJucyB7bm9kZSBpcyBUZXh0fSAqL1xuXHRcdChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSAzLFxuXHRcdC8qKiBAcGFyYW0ge1RleHR9IG5vZGUgKi9cblx0XHQobm9kZSkgPT4ge1xuXHRcdFx0Y29uc3QgZGF0YV9zdHIgPSAnJyArIGRhdGE7XG5cdFx0XHRpZiAobm9kZS5kYXRhLnN0YXJ0c1dpdGgoZGF0YV9zdHIpKSB7XG5cdFx0XHRcdGlmIChub2RlLmRhdGEubGVuZ3RoICE9PSBkYXRhX3N0ci5sZW5ndGgpIHtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZS5zcGxpdFRleHQoZGF0YV9zdHIubGVuZ3RoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZS5kYXRhID0gZGF0YV9zdHI7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQoKSA9PiB0ZXh0KGRhdGEpLFxuXHRcdHRydWUgLy8gVGV4dCBub2RlcyBzaG91bGQgbm90IHVwZGF0ZSBsYXN0IGluZGV4IHNpbmNlIGl0IGlzIGxpa2VseSBub3Qgd29ydGggaXQgdG8gZWxpbWluYXRlIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgYWN0dWFsIGVsZW1lbnRzXG5cdCk7XG59XG5cbi8qKlxuICogQHJldHVybnMge1RleHR9ICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1fc3BhY2Uobm9kZXMpIHtcblx0cmV0dXJuIGNsYWltX3RleHQobm9kZXMsICcgJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGlsZE5vZGVBcnJheX0gbm9kZXNcbiAqIEByZXR1cm5zIHtDb21tZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1fY29tbWVudChub2RlcywgZGF0YSkge1xuXHRyZXR1cm4gY2xhaW1fbm9kZShcblx0XHRub2Rlcyxcblx0XHQvKiogQHJldHVybnMge25vZGUgaXMgQ29tbWVudH0gKi9cblx0XHQobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gOCxcblx0XHQvKiogQHBhcmFtIHtDb21tZW50fSBub2RlICovXG5cdFx0KG5vZGUpID0+IHtcblx0XHRcdG5vZGUuZGF0YSA9ICcnICsgZGF0YTtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fSxcblx0XHQoKSA9PiBjb21tZW50KGRhdGEpLFxuXHRcdHRydWVcblx0KTtcbn1cblxuZnVuY3Rpb24gZ2V0X2NvbW1lbnRfaWR4KG5vZGVzLCB0ZXh0LCBzdGFydCkge1xuXHRmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBub2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblx0XHRpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBjb21tZW50IG5vZGUgKi8gJiYgbm9kZS50ZXh0Q29udGVudC50cmltKCkgPT09IHRleHQpIHtcblx0XHRcdHJldHVybiBpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gLTE7XG59XG5cbi8qKlxuICogQHBhcmFtIHtib29sZWFufSBpc19zdmdcbiAqIEByZXR1cm5zIHtIdG1sVGFnSHlkcmF0aW9ufVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xhaW1faHRtbF90YWcobm9kZXMsIGlzX3N2Zykge1xuXHQvLyBmaW5kIGh0bWwgb3BlbmluZyB0YWdcblx0Y29uc3Qgc3RhcnRfaW5kZXggPSBnZXRfY29tbWVudF9pZHgobm9kZXMsICdIVE1MX1RBR19TVEFSVCcsIDApO1xuXHRjb25zdCBlbmRfaW5kZXggPSBnZXRfY29tbWVudF9pZHgobm9kZXMsICdIVE1MX1RBR19FTkQnLCBzdGFydF9pbmRleCArIDEpO1xuXHRpZiAoc3RhcnRfaW5kZXggPT09IC0xIHx8IGVuZF9pbmRleCA9PT0gLTEpIHtcblx0XHRyZXR1cm4gbmV3IEh0bWxUYWdIeWRyYXRpb24oaXNfc3ZnKTtcblx0fVxuXG5cdGluaXRfY2xhaW1faW5mbyhub2Rlcyk7XG5cdGNvbnN0IGh0bWxfdGFnX25vZGVzID0gbm9kZXMuc3BsaWNlKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpO1xuXHRkZXRhY2goaHRtbF90YWdfbm9kZXNbMF0pO1xuXHRkZXRhY2goaHRtbF90YWdfbm9kZXNbaHRtbF90YWdfbm9kZXMubGVuZ3RoIC0gMV0pO1xuXHRjb25zdCBjbGFpbWVkX25vZGVzID0gaHRtbF90YWdfbm9kZXMuc2xpY2UoMSwgaHRtbF90YWdfbm9kZXMubGVuZ3RoIC0gMSk7XG5cdGlmIChjbGFpbWVkX25vZGVzLmxlbmd0aCA9PT0gMCkge1xuXHRcdHJldHVybiBuZXcgSHRtbFRhZ0h5ZHJhdGlvbihpc19zdmcpO1xuXHR9XG5cdGZvciAoY29uc3QgbiBvZiBjbGFpbWVkX25vZGVzKSB7XG5cdFx0bi5jbGFpbV9vcmRlciA9IG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZDtcblx0XHRub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQgKz0gMTtcblx0fVxuXHRyZXR1cm4gbmV3IEh0bWxUYWdIeWRyYXRpb24oaXNfc3ZnLCBjbGFpbWVkX25vZGVzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RleHR9IHRleHRcbiAqIEBwYXJhbSB7dW5rbm93bn0gZGF0YVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZGF0YSh0ZXh0LCBkYXRhKSB7XG5cdGRhdGEgPSAnJyArIGRhdGE7XG5cdGlmICh0ZXh0LmRhdGEgPT09IGRhdGEpIHJldHVybjtcblx0dGV4dC5kYXRhID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChkYXRhKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RleHR9IHRleHRcbiAqIEBwYXJhbSB7dW5rbm93bn0gZGF0YVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZGF0YV9jb250ZW50ZWRpdGFibGUodGV4dCwgZGF0YSkge1xuXHRkYXRhID0gJycgKyBkYXRhO1xuXHRpZiAodGV4dC53aG9sZVRleHQgPT09IGRhdGEpIHJldHVybjtcblx0dGV4dC5kYXRhID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChkYXRhKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RleHR9IHRleHRcbiAqIEBwYXJhbSB7dW5rbm93bn0gZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJfdmFsdWVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2RhdGFfbWF5YmVfY29udGVudGVkaXRhYmxlKHRleHQsIGRhdGEsIGF0dHJfdmFsdWUpIHtcblx0aWYgKH5jb250ZW50ZWRpdGFibGVfdHJ1dGh5X3ZhbHVlcy5pbmRleE9mKGF0dHJfdmFsdWUpKSB7XG5cdFx0c2V0X2RhdGFfY29udGVudGVkaXRhYmxlKHRleHQsIGRhdGEpO1xuXHR9IGVsc2Uge1xuXHRcdHNldF9kYXRhKHRleHQsIGRhdGEpO1xuXHR9XG59XG5cbi8qKlxuICogQHJldHVybnMge3ZvaWR9ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2lucHV0X3ZhbHVlKGlucHV0LCB2YWx1ZSkge1xuXHRpbnB1dC52YWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9pbnB1dF90eXBlKGlucHV0LCB0eXBlKSB7XG5cdHRyeSB7XG5cdFx0aW5wdXQudHlwZSA9IHR5cGU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBkbyBub3RoaW5nXG5cdH1cbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfc3R5bGUobm9kZSwga2V5LCB2YWx1ZSwgaW1wb3J0YW50KSB7XG5cdGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdFx0bm9kZS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShrZXkpO1xuXHR9IGVsc2Uge1xuXHRcdG5vZGUuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSwgaW1wb3J0YW50ID8gJ2ltcG9ydGFudCcgOiAnJyk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3Rfb3B0aW9uKHNlbGVjdCwgdmFsdWUsIG1vdW50aW5nKSB7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRjb25zdCBvcHRpb24gPSBzZWxlY3Qub3B0aW9uc1tpXTtcblx0XHRpZiAob3B0aW9uLl9fdmFsdWUgPT09IHZhbHVlKSB7XG5cdFx0XHRvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0fVxuXHRpZiAoIW1vdW50aW5nIHx8IHZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRzZWxlY3Quc2VsZWN0ZWRJbmRleCA9IC0xOyAvLyBubyBvcHRpb24gc2hvdWxkIGJlIHNlbGVjdGVkXG5cdH1cbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3Rfb3B0aW9ucyhzZWxlY3QsIHZhbHVlKSB7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRjb25zdCBvcHRpb24gPSBzZWxlY3Qub3B0aW9uc1tpXTtcblx0XHRvcHRpb24uc2VsZWN0ZWQgPSB+dmFsdWUuaW5kZXhPZihvcHRpb24uX192YWx1ZSk7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdF92YWx1ZShzZWxlY3QpIHtcblx0Y29uc3Qgc2VsZWN0ZWRfb3B0aW9uID0gc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJzpjaGVja2VkJyk7XG5cdHJldHVybiBzZWxlY3RlZF9vcHRpb24gJiYgc2VsZWN0ZWRfb3B0aW9uLl9fdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3RfbXVsdGlwbGVfdmFsdWUoc2VsZWN0KSB7XG5cdHJldHVybiBbXS5tYXAuY2FsbChzZWxlY3QucXVlcnlTZWxlY3RvckFsbCgnOmNoZWNrZWQnKSwgKG9wdGlvbikgPT4gb3B0aW9uLl9fdmFsdWUpO1xufVxuLy8gdW5mb3J0dW5hdGVseSB0aGlzIGNhbid0IGJlIGEgY29uc3RhbnQgYXMgdGhhdCB3b3VsZG4ndCBiZSB0cmVlLXNoYWtlYWJsZVxuLy8gc28gd2UgY2FjaGUgdGhlIHJlc3VsdCBpbnN0ZWFkXG5cbi8qKlxuICogQHR5cGUge2Jvb2xlYW59ICovXG5sZXQgY3Jvc3NvcmlnaW47XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59ICovXG5leHBvcnQgZnVuY3Rpb24gaXNfY3Jvc3NvcmlnaW4oKSB7XG5cdGlmIChjcm9zc29yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Y3Jvc3NvcmlnaW4gPSBmYWxzZTtcblx0XHR0cnkge1xuXHRcdFx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wYXJlbnQpIHtcblx0XHRcdFx0dm9pZCB3aW5kb3cucGFyZW50LmRvY3VtZW50O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjcm9zc29yaWdpbiA9IHRydWU7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBjcm9zc29yaWdpbjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7KCkgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZF9pZnJhbWVfcmVzaXplX2xpc3RlbmVyKG5vZGUsIGZuKSB7XG5cdGNvbnN0IGNvbXB1dGVkX3N0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblx0aWYgKGNvbXB1dGVkX3N0eWxlLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuXHRcdG5vZGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuXHR9XG5cdGNvbnN0IGlmcmFtZSA9IGVsZW1lbnQoJ2lmcmFtZScpO1xuXHRpZnJhbWUuc2V0QXR0cmlidXRlKFxuXHRcdCdzdHlsZScsXG5cdFx0J2Rpc3BsYXk6IGJsb2NrOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgbGVmdDogMDsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsgJyArXG5cdFx0XHQnb3ZlcmZsb3c6IGhpZGRlbjsgYm9yZGVyOiAwOyBvcGFjaXR5OiAwOyBwb2ludGVyLWV2ZW50czogbm9uZTsgei1pbmRleDogLTE7J1xuXHQpO1xuXHRpZnJhbWUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG5cdGlmcmFtZS50YWJJbmRleCA9IC0xO1xuXHRjb25zdCBjcm9zc29yaWdpbiA9IGlzX2Nyb3Nzb3JpZ2luKCk7XG5cblx0LyoqXG5cdCAqIEB0eXBlIHsoKSA9PiB2b2lkfVxuXHQgKi9cblx0bGV0IHVuc3Vic2NyaWJlO1xuXHRpZiAoY3Jvc3NvcmlnaW4pIHtcblx0XHRpZnJhbWUuc3JjID0gXCJkYXRhOnRleHQvaHRtbCw8c2NyaXB0Pm9ucmVzaXplPWZ1bmN0aW9uKCl7cGFyZW50LnBvc3RNZXNzYWdlKDAsJyonKX08L3NjcmlwdD5cIjtcblx0XHR1bnN1YnNjcmliZSA9IGxpc3Rlbihcblx0XHRcdHdpbmRvdyxcblx0XHRcdCdtZXNzYWdlJyxcblx0XHRcdC8qKiBAcGFyYW0ge01lc3NhZ2VFdmVudH0gZXZlbnQgKi8gKGV2ZW50KSA9PiB7XG5cdFx0XHRcdGlmIChldmVudC5zb3VyY2UgPT09IGlmcmFtZS5jb250ZW50V2luZG93KSBmbigpO1xuXHRcdFx0fVxuXHRcdCk7XG5cdH0gZWxzZSB7XG5cdFx0aWZyYW1lLnNyYyA9ICdhYm91dDpibGFuayc7XG5cdFx0aWZyYW1lLm9ubG9hZCA9ICgpID0+IHtcblx0XHRcdHVuc3Vic2NyaWJlID0gbGlzdGVuKGlmcmFtZS5jb250ZW50V2luZG93LCAncmVzaXplJywgZm4pO1xuXHRcdFx0Ly8gbWFrZSBzdXJlIGFuIGluaXRpYWwgcmVzaXplIGV2ZW50IGlzIGZpcmVkIF9hZnRlcl8gdGhlIGlmcmFtZSBpcyBsb2FkZWQgKHdoaWNoIGlzIGFzeW5jaHJvbm91cylcblx0XHRcdC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL2lzc3Vlcy80MjMzXG5cdFx0XHRmbigpO1xuXHRcdH07XG5cdH1cblx0YXBwZW5kKG5vZGUsIGlmcmFtZSk7XG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKGNyb3Nzb3JpZ2luKSB7XG5cdFx0XHR1bnN1YnNjcmliZSgpO1xuXHRcdH0gZWxzZSBpZiAodW5zdWJzY3JpYmUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcblx0XHRcdHVuc3Vic2NyaWJlKCk7XG5cdFx0fVxuXHRcdGRldGFjaChpZnJhbWUpO1xuXHR9O1xufVxuZXhwb3J0IGNvbnN0IHJlc2l6ZV9vYnNlcnZlcl9jb250ZW50X2JveCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24oe1xuXHRib3g6ICdjb250ZW50LWJveCdcbn0pO1xuZXhwb3J0IGNvbnN0IHJlc2l6ZV9vYnNlcnZlcl9ib3JkZXJfYm94ID0gLyogQF9fUFVSRV9fICovIG5ldyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbih7XG5cdGJveDogJ2JvcmRlci1ib3gnXG59KTtcbmV4cG9ydCBjb25zdCByZXNpemVfb2JzZXJ2ZXJfZGV2aWNlX3BpeGVsX2NvbnRlbnRfYm94ID0gLyogQF9fUFVSRV9fICovIG5ldyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbihcblx0eyBib3g6ICdkZXZpY2UtcGl4ZWwtY29udGVudC1ib3gnIH1cbik7XG5leHBvcnQgeyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbiB9O1xuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvZ2dsZV9jbGFzcyhlbGVtZW50LCBuYW1lLCB0b2dnbGUpIHtcblx0Ly8gVGhlIGAhIWAgaXMgcmVxdWlyZWQgYmVjYXVzZSBhbiBgdW5kZWZpbmVkYCBmbGFnIG1lYW5zIGZsaXBwaW5nIHRoZSBjdXJyZW50IHN0YXRlLlxuXHRlbGVtZW50LmNsYXNzTGlzdC50b2dnbGUobmFtZSwgISF0b2dnbGUpO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtUfSBbZGV0YWlsXVxuICogQHBhcmFtIHt7IGJ1YmJsZXM/OiBib29sZWFuLCBjYW5jZWxhYmxlPzogYm9vbGVhbiB9fSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtDdXN0b21FdmVudDxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGN1c3RvbV9ldmVudCh0eXBlLCBkZXRhaWwsIHsgYnViYmxlcyA9IGZhbHNlLCBjYW5jZWxhYmxlID0gZmFsc2UgfSA9IHt9KSB7XG5cdHJldHVybiBuZXcgQ3VzdG9tRXZlbnQodHlwZSwgeyBkZXRhaWwsIGJ1YmJsZXMsIGNhbmNlbGFibGUgfSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAqIEByZXR1cm5zIHtDaGlsZE5vZGVBcnJheX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1ZXJ5X3NlbGVjdG9yX2FsbChzZWxlY3RvciwgcGFyZW50ID0gZG9jdW1lbnQuYm9keSkge1xuXHRyZXR1cm4gQXJyYXkuZnJvbShwYXJlbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBub2RlSWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGhlYWRcbiAqIEByZXR1cm5zIHthbnlbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhlYWRfc2VsZWN0b3Iobm9kZUlkLCBoZWFkKSB7XG5cdGNvbnN0IHJlc3VsdCA9IFtdO1xuXHRsZXQgc3RhcnRlZCA9IDA7XG5cdGZvciAoY29uc3Qgbm9kZSBvZiBoZWFkLmNoaWxkTm9kZXMpIHtcblx0XHRpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBjb21tZW50IG5vZGUgKi8pIHtcblx0XHRcdGNvbnN0IGNvbW1lbnQgPSBub2RlLnRleHRDb250ZW50LnRyaW0oKTtcblx0XHRcdGlmIChjb21tZW50ID09PSBgSEVBRF8ke25vZGVJZH1fRU5EYCkge1xuXHRcdFx0XHRzdGFydGVkIC09IDE7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKG5vZGUpO1xuXHRcdFx0fSBlbHNlIGlmIChjb21tZW50ID09PSBgSEVBRF8ke25vZGVJZH1fU1RBUlRgKSB7XG5cdFx0XHRcdHN0YXJ0ZWQgKz0gMTtcblx0XHRcdFx0cmVzdWx0LnB1c2gobm9kZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChzdGFydGVkID4gMCkge1xuXHRcdFx0cmVzdWx0LnB1c2gobm9kZSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG4vKiogKi9cbmV4cG9ydCBjbGFzcyBIdG1sVGFnIHtcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBkZWZhdWx0IGZhbHNlXG5cdCAqL1xuXHRpc19zdmcgPSBmYWxzZTtcblx0LyoqIHBhcmVudCBmb3IgY3JlYXRpbmcgbm9kZSAqL1xuXHRlID0gdW5kZWZpbmVkO1xuXHQvKiogaHRtbCB0YWcgbm9kZXMgKi9cblx0biA9IHVuZGVmaW5lZDtcblx0LyoqIHRhcmdldCAqL1xuXHR0ID0gdW5kZWZpbmVkO1xuXHQvKiogYW5jaG9yICovXG5cdGEgPSB1bmRlZmluZWQ7XG5cdGNvbnN0cnVjdG9yKGlzX3N2ZyA9IGZhbHNlKSB7XG5cdFx0dGhpcy5pc19zdmcgPSBpc19zdmc7XG5cdFx0dGhpcy5lID0gdGhpcy5uID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGMoaHRtbCkge1xuXHRcdHRoaXMuaChodG1sKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgU1ZHRWxlbWVudH0gdGFyZ2V0XG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50fSBhbmNob3Jcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRtKGh0bWwsIHRhcmdldCwgYW5jaG9yID0gbnVsbCkge1xuXHRcdGlmICghdGhpcy5lKSB7XG5cdFx0XHRpZiAodGhpcy5pc19zdmcpXG5cdFx0XHRcdHRoaXMuZSA9IHN2Z19lbGVtZW50KC8qKiBAdHlwZSB7a2V5b2YgU1ZHRWxlbWVudFRhZ05hbWVNYXB9ICovICh0YXJnZXQubm9kZU5hbWUpKTtcblx0XHRcdC8qKiAjNzM2NCAgdGFyZ2V0IGZvciA8dGVtcGxhdGU+IG1heSBiZSBwcm92aWRlZCBhcyAjZG9jdW1lbnQtZnJhZ21lbnQoMTEpICovIGVsc2Vcblx0XHRcdFx0dGhpcy5lID0gZWxlbWVudChcblx0XHRcdFx0XHQvKiogQHR5cGUge2tleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcH0gKi8gKFxuXHRcdFx0XHRcdFx0dGFyZ2V0Lm5vZGVUeXBlID09PSAxMSA/ICdURU1QTEFURScgOiB0YXJnZXQubm9kZU5hbWVcblx0XHRcdFx0XHQpXG5cdFx0XHRcdCk7XG5cdFx0XHR0aGlzLnQgPVxuXHRcdFx0XHR0YXJnZXQudGFnTmFtZSAhPT0gJ1RFTVBMQVRFJ1xuXHRcdFx0XHRcdD8gdGFyZ2V0XG5cdFx0XHRcdFx0OiAvKiogQHR5cGUge0hUTUxUZW1wbGF0ZUVsZW1lbnR9ICovICh0YXJnZXQpLmNvbnRlbnQ7XG5cdFx0XHR0aGlzLmMoaHRtbCk7XG5cdFx0fVxuXHRcdHRoaXMuaShhbmNob3IpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0aChodG1sKSB7XG5cdFx0dGhpcy5lLmlubmVySFRNTCA9IGh0bWw7XG5cdFx0dGhpcy5uID0gQXJyYXkuZnJvbShcblx0XHRcdHRoaXMuZS5ub2RlTmFtZSA9PT0gJ1RFTVBMQVRFJyA/IHRoaXMuZS5jb250ZW50LmNoaWxkTm9kZXMgOiB0aGlzLmUuY2hpbGROb2Rlc1xuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGkoYW5jaG9yKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm4ubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdGluc2VydCh0aGlzLnQsIHRoaXMubltpXSwgYW5jaG9yKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRwKGh0bWwpIHtcblx0XHR0aGlzLmQoKTtcblx0XHR0aGlzLmgoaHRtbCk7XG5cdFx0dGhpcy5pKHRoaXMuYSk7XG5cdH1cblxuXHQvKipcblx0ICogQHJldHVybnMge3ZvaWR9ICovXG5cdGQoKSB7XG5cdFx0dGhpcy5uLmZvckVhY2goZGV0YWNoKTtcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgSHRtbFRhZ0h5ZHJhdGlvbiBleHRlbmRzIEh0bWxUYWcge1xuXHQvKiogQHR5cGUge0VsZW1lbnRbXX0gaHlkcmF0aW9uIGNsYWltZWQgbm9kZXMgKi9cblx0bCA9IHVuZGVmaW5lZDtcblxuXHRjb25zdHJ1Y3Rvcihpc19zdmcgPSBmYWxzZSwgY2xhaW1lZF9ub2Rlcykge1xuXHRcdHN1cGVyKGlzX3N2Zyk7XG5cdFx0dGhpcy5lID0gdGhpcy5uID0gbnVsbDtcblx0XHR0aGlzLmwgPSBjbGFpbWVkX25vZGVzO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0YyhodG1sKSB7XG5cdFx0aWYgKHRoaXMubCkge1xuXHRcdFx0dGhpcy5uID0gdGhpcy5sO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdXBlci5jKGh0bWwpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcmV0dXJucyB7dm9pZH0gKi9cblx0aShhbmNob3IpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubi5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0aW5zZXJ0X2h5ZHJhdGlvbih0aGlzLnQsIHRoaXMubltpXSwgYW5jaG9yKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge05hbWVkTm9kZU1hcH0gYXR0cmlidXRlc1xuICogQHJldHVybnMge3t9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXR0cmlidXRlX3RvX29iamVjdChhdHRyaWJ1dGVzKSB7XG5cdGNvbnN0IHJlc3VsdCA9IHt9O1xuXHRmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGVzKSB7XG5cdFx0cmVzdWx0W2F0dHJpYnV0ZS5uYW1lXSA9IGF0dHJpYnV0ZS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBlc2NhcGVkID0ge1xuXHQnXCInOiAnJnF1b3Q7Jyxcblx0JyYnOiAnJmFtcDsnLFxuXHQnPCc6ICcmbHQ7J1xufTtcblxuY29uc3QgcmVnZXhfYXR0cmlidXRlX2NoYXJhY3RlcnNfdG9fZXNjYXBlID0gL1tcIiY8XS9nO1xuXG4vKipcbiAqIE5vdGUgdGhhdCB0aGUgYXR0cmlidXRlIGl0c2VsZiBzaG91bGQgYmUgc3Vycm91bmRlZCBpbiBkb3VibGUgcXVvdGVzXG4gKiBAcGFyYW0ge2FueX0gYXR0cmlidXRlXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZV9hdHRyaWJ1dGUoYXR0cmlidXRlKSB7XG5cdHJldHVybiBTdHJpbmcoYXR0cmlidXRlKS5yZXBsYWNlKHJlZ2V4X2F0dHJpYnV0ZV9jaGFyYWN0ZXJzX3RvX2VzY2FwZSwgKG1hdGNoKSA9PiBlc2NhcGVkW21hdGNoXSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSBhdHRyaWJ1dGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnlfc3ByZWFkKGF0dHJpYnV0ZXMpIHtcblx0bGV0IHN0ciA9ICcgJztcblx0Zm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuXHRcdGlmIChhdHRyaWJ1dGVzW2tleV0gIT0gbnVsbCkge1xuXHRcdFx0c3RyICs9IGAke2tleX09XCIke2VzY2FwZV9hdHRyaWJ1dGUoYXR0cmlidXRlc1trZXldKX1cIiBgO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBzdHI7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge3t9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cyhlbGVtZW50KSB7XG5cdGNvbnN0IHJlc3VsdCA9IHt9O1xuXHRlbGVtZW50LmNoaWxkTm9kZXMuZm9yRWFjaChcblx0XHQvKiogQHBhcmFtIHtFbGVtZW50fSBub2RlICovIChub2RlKSA9PiB7XG5cdFx0XHRyZXN1bHRbbm9kZS5zbG90IHx8ICdkZWZhdWx0J10gPSB0cnVlO1xuXHRcdH1cblx0KTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cnVjdF9zdmVsdGVfY29tcG9uZW50KGNvbXBvbmVudCwgcHJvcHMpIHtcblx0cmV0dXJuIG5ldyBjb21wb25lbnQocHJvcHMpO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtOb2RlICYge1xuICogXHRjbGFpbV9vcmRlcj86IG51bWJlcjtcbiAqIFx0aHlkcmF0ZV9pbml0PzogdHJ1ZTtcbiAqIFx0YWN0dWFsX2VuZF9jaGlsZD86IE5vZGVFeDtcbiAqIFx0Y2hpbGROb2RlczogTm9kZUxpc3RPZjxOb2RlRXg+O1xuICogfX0gTm9kZUV4XG4gKi9cblxuLyoqIEB0eXBlZGVmIHtDaGlsZE5vZGUgJiBOb2RlRXh9IENoaWxkTm9kZUV4ICovXG5cbi8qKiBAdHlwZWRlZiB7Tm9kZUV4ICYgeyBjbGFpbV9vcmRlcjogbnVtYmVyIH19IE5vZGVFeDIgKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7Q2hpbGROb2RlRXhbXSAmIHtcbiAqIFx0Y2xhaW1faW5mbz86IHtcbiAqIFx0XHRsYXN0X2luZGV4OiBudW1iZXI7XG4gKiBcdFx0dG90YWxfY2xhaW1lZDogbnVtYmVyO1xuICogXHR9O1xuICogfX0gQ2hpbGROb2RlQXJyYXlcbiAqL1xuIiwgImNvbnN0IF9ib29sZWFuX2F0dHJpYnV0ZXMgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoW1xuXHQnYWxsb3dmdWxsc2NyZWVuJyxcblx0J2FsbG93cGF5bWVudHJlcXVlc3QnLFxuXHQnYXN5bmMnLFxuXHQnYXV0b2ZvY3VzJyxcblx0J2F1dG9wbGF5Jyxcblx0J2NoZWNrZWQnLFxuXHQnY29udHJvbHMnLFxuXHQnZGVmYXVsdCcsXG5cdCdkZWZlcicsXG5cdCdkaXNhYmxlZCcsXG5cdCdmb3Jtbm92YWxpZGF0ZScsXG5cdCdoaWRkZW4nLFxuXHQnaW5lcnQnLFxuXHQnaXNtYXAnLFxuXHQnbG9vcCcsXG5cdCdtdWx0aXBsZScsXG5cdCdtdXRlZCcsXG5cdCdub21vZHVsZScsXG5cdCdub3ZhbGlkYXRlJyxcblx0J29wZW4nLFxuXHQncGxheXNpbmxpbmUnLFxuXHQncmVhZG9ubHknLFxuXHQncmVxdWlyZWQnLFxuXHQncmV2ZXJzZWQnLFxuXHQnc2VsZWN0ZWQnXG5dKTtcblxuLyoqXG4gKiBMaXN0IG9mIEhUTUwgYm9vbGVhbiBhdHRyaWJ1dGVzIChlLmcuIGA8aW5wdXQgZGlzYWJsZWQ+YCkuXG4gKiBTb3VyY2U6IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbFxuICpcbiAqIEB0eXBlIHtTZXQ8c3RyaW5nPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGJvb2xlYW5fYXR0cmlidXRlcyA9IG5ldyBTZXQoWy4uLl9ib29sZWFuX2F0dHJpYnV0ZXNdKTtcblxuLyoqIEB0eXBlZGVmIHt0eXBlb2YgX2Jvb2xlYW5fYXR0cmlidXRlc1tudW1iZXJdfSBCb29sZWFuQXR0cmlidXRlcyAqL1xuIiwgImltcG9ydCB7XG5cdGFkZF9yZW5kZXJfY2FsbGJhY2ssXG5cdGZsdXNoLFxuXHRmbHVzaF9yZW5kZXJfY2FsbGJhY2tzLFxuXHRzY2hlZHVsZV91cGRhdGUsXG5cdGRpcnR5X2NvbXBvbmVudHNcbn0gZnJvbSAnLi9zY2hlZHVsZXIuanMnO1xuaW1wb3J0IHsgY3VycmVudF9jb21wb25lbnQsIHNldF9jdXJyZW50X2NvbXBvbmVudCB9IGZyb20gJy4vbGlmZWN5Y2xlLmpzJztcbmltcG9ydCB7IGJsYW5rX29iamVjdCwgaXNfZW1wdHksIGlzX2Z1bmN0aW9uLCBydW4sIHJ1bl9hbGwsIG5vb3AgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7XG5cdGNoaWxkcmVuLFxuXHRkZXRhY2gsXG5cdHN0YXJ0X2h5ZHJhdGluZyxcblx0ZW5kX2h5ZHJhdGluZyxcblx0Z2V0X2N1c3RvbV9lbGVtZW50c19zbG90cyxcblx0aW5zZXJ0LFxuXHRlbGVtZW50LFxuXHRhdHRyXG59IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7IHRyYW5zaXRpb25faW4gfSBmcm9tICcuL3RyYW5zaXRpb25zLmpzJztcblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmQoY29tcG9uZW50LCBuYW1lLCBjYWxsYmFjaykge1xuXHRjb25zdCBpbmRleCA9IGNvbXBvbmVudC4kJC5wcm9wc1tuYW1lXTtcblx0aWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRjb21wb25lbnQuJCQuYm91bmRbaW5kZXhdID0gY2FsbGJhY2s7XG5cdFx0Y2FsbGJhY2soY29tcG9uZW50LiQkLmN0eFtpbmRleF0pO1xuXHR9XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfY29tcG9uZW50KGJsb2NrKSB7XG5cdGJsb2NrICYmIGJsb2NrLmMoKTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYWltX2NvbXBvbmVudChibG9jaywgcGFyZW50X25vZGVzKSB7XG5cdGJsb2NrICYmIGJsb2NrLmwocGFyZW50X25vZGVzKTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vdW50X2NvbXBvbmVudChjb21wb25lbnQsIHRhcmdldCwgYW5jaG9yKSB7XG5cdGNvbnN0IHsgZnJhZ21lbnQsIGFmdGVyX3VwZGF0ZSB9ID0gY29tcG9uZW50LiQkO1xuXHRmcmFnbWVudCAmJiBmcmFnbWVudC5tKHRhcmdldCwgYW5jaG9yKTtcblx0Ly8gb25Nb3VudCBoYXBwZW5zIGJlZm9yZSB0aGUgaW5pdGlhbCBhZnRlclVwZGF0ZVxuXHRhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IHtcblx0XHRjb25zdCBuZXdfb25fZGVzdHJveSA9IGNvbXBvbmVudC4kJC5vbl9tb3VudC5tYXAocnVuKS5maWx0ZXIoaXNfZnVuY3Rpb24pO1xuXHRcdC8vIGlmIHRoZSBjb21wb25lbnQgd2FzIGRlc3Ryb3llZCBpbW1lZGlhdGVseVxuXHRcdC8vIGl0IHdpbGwgdXBkYXRlIHRoZSBgJCQub25fZGVzdHJveWAgcmVmZXJlbmNlIHRvIGBudWxsYC5cblx0XHQvLyB0aGUgZGVzdHJ1Y3R1cmVkIG9uX2Rlc3Ryb3kgbWF5IHN0aWxsIHJlZmVyZW5jZSB0byB0aGUgb2xkIGFycmF5XG5cdFx0aWYgKGNvbXBvbmVudC4kJC5vbl9kZXN0cm95KSB7XG5cdFx0XHRjb21wb25lbnQuJCQub25fZGVzdHJveS5wdXNoKC4uLm5ld19vbl9kZXN0cm95KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRWRnZSBjYXNlIC0gY29tcG9uZW50IHdhcyBkZXN0cm95ZWQgaW1tZWRpYXRlbHksXG5cdFx0XHQvLyBtb3N0IGxpa2VseSBhcyBhIHJlc3VsdCBvZiBhIGJpbmRpbmcgaW5pdGlhbGlzaW5nXG5cdFx0XHRydW5fYWxsKG5ld19vbl9kZXN0cm95KTtcblx0XHR9XG5cdFx0Y29tcG9uZW50LiQkLm9uX21vdW50ID0gW107XG5cdH0pO1xuXHRhZnRlcl91cGRhdGUuZm9yRWFjaChhZGRfcmVuZGVyX2NhbGxiYWNrKTtcbn1cblxuLyoqIEByZXR1cm5zIHt2b2lkfSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lfY29tcG9uZW50KGNvbXBvbmVudCwgZGV0YWNoaW5nKSB7XG5cdGNvbnN0ICQkID0gY29tcG9uZW50LiQkO1xuXHRpZiAoJCQuZnJhZ21lbnQgIT09IG51bGwpIHtcblx0XHRmbHVzaF9yZW5kZXJfY2FsbGJhY2tzKCQkLmFmdGVyX3VwZGF0ZSk7XG5cdFx0cnVuX2FsbCgkJC5vbl9kZXN0cm95KTtcblx0XHQkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5kKGRldGFjaGluZyk7XG5cdFx0Ly8gVE9ETyBudWxsIG91dCBvdGhlciByZWZzLCBpbmNsdWRpbmcgY29tcG9uZW50LiQkIChidXQgbmVlZCB0b1xuXHRcdC8vIHByZXNlcnZlIGZpbmFsIHN0YXRlPylcblx0XHQkJC5vbl9kZXN0cm95ID0gJCQuZnJhZ21lbnQgPSBudWxsO1xuXHRcdCQkLmN0eCA9IFtdO1xuXHR9XG59XG5cbi8qKiBAcmV0dXJucyB7dm9pZH0gKi9cbmZ1bmN0aW9uIG1ha2VfZGlydHkoY29tcG9uZW50LCBpKSB7XG5cdGlmIChjb21wb25lbnQuJCQuZGlydHlbMF0gPT09IC0xKSB7XG5cdFx0ZGlydHlfY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG5cdFx0c2NoZWR1bGVfdXBkYXRlKCk7XG5cdFx0Y29tcG9uZW50LiQkLmRpcnR5LmZpbGwoMCk7XG5cdH1cblx0Y29tcG9uZW50LiQkLmRpcnR5WyhpIC8gMzEpIHwgMF0gfD0gMSA8PCBpICUgMzE7XG59XG5cbi8vIFRPRE86IERvY3VtZW50IHRoZSBvdGhlciBwYXJhbXNcbi8qKlxuICogQHBhcmFtIHtTdmVsdGVDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHVibGljLmpzJykuQ29tcG9uZW50Q29uc3RydWN0b3JPcHRpb25zfSBvcHRpb25zXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vdXRpbHMuanMnKVsnbm90X2VxdWFsJ119IG5vdF9lcXVhbCBVc2VkIHRvIGNvbXBhcmUgcHJvcHMgYW5kIHN0YXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7KHRhcmdldDogRWxlbWVudCB8IFNoYWRvd1Jvb3QpID0+IHZvaWR9IFthcHBlbmRfc3R5bGVzXSBGdW5jdGlvbiB0aGF0IGFwcGVuZHMgc3R5bGVzIHRvIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGlzIGZpcnN0IGluaXRpYWxpc2VkLlxuICogVGhpcyB3aWxsIGJlIHRoZSBgYWRkX2Nzc2AgZnVuY3Rpb24gZnJvbSB0aGUgY29tcGlsZWQgY29tcG9uZW50LlxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdChcblx0Y29tcG9uZW50LFxuXHRvcHRpb25zLFxuXHRpbnN0YW5jZSxcblx0Y3JlYXRlX2ZyYWdtZW50LFxuXHRub3RfZXF1YWwsXG5cdHByb3BzLFxuXHRhcHBlbmRfc3R5bGVzID0gbnVsbCxcblx0ZGlydHkgPSBbLTFdXG4pIHtcblx0Y29uc3QgcGFyZW50X2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuXHRzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KTtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLlQkJH0gKi9cblx0Y29uc3QgJCQgPSAoY29tcG9uZW50LiQkID0ge1xuXHRcdGZyYWdtZW50OiBudWxsLFxuXHRcdGN0eDogW10sXG5cdFx0Ly8gc3RhdGVcblx0XHRwcm9wcyxcblx0XHR1cGRhdGU6IG5vb3AsXG5cdFx0bm90X2VxdWFsLFxuXHRcdGJvdW5kOiBibGFua19vYmplY3QoKSxcblx0XHQvLyBsaWZlY3ljbGVcblx0XHRvbl9tb3VudDogW10sXG5cdFx0b25fZGVzdHJveTogW10sXG5cdFx0b25fZGlzY29ubmVjdDogW10sXG5cdFx0YmVmb3JlX3VwZGF0ZTogW10sXG5cdFx0YWZ0ZXJfdXBkYXRlOiBbXSxcblx0XHRjb250ZXh0OiBuZXcgTWFwKG9wdGlvbnMuY29udGV4dCB8fCAocGFyZW50X2NvbXBvbmVudCA/IHBhcmVudF9jb21wb25lbnQuJCQuY29udGV4dCA6IFtdKSksXG5cdFx0Ly8gZXZlcnl0aGluZyBlbHNlXG5cdFx0Y2FsbGJhY2tzOiBibGFua19vYmplY3QoKSxcblx0XHRkaXJ0eSxcblx0XHRza2lwX2JvdW5kOiBmYWxzZSxcblx0XHRyb290OiBvcHRpb25zLnRhcmdldCB8fCBwYXJlbnRfY29tcG9uZW50LiQkLnJvb3Rcblx0fSk7XG5cdGFwcGVuZF9zdHlsZXMgJiYgYXBwZW5kX3N0eWxlcygkJC5yb290KTtcblx0bGV0IHJlYWR5ID0gZmFsc2U7XG5cdCQkLmN0eCA9IGluc3RhbmNlXG5cdFx0PyBpbnN0YW5jZShjb21wb25lbnQsIG9wdGlvbnMucHJvcHMgfHwge30sIChpLCByZXQsIC4uLnJlc3QpID0+IHtcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSByZXN0Lmxlbmd0aCA/IHJlc3RbMF0gOiByZXQ7XG5cdFx0XHRcdGlmICgkJC5jdHggJiYgbm90X2VxdWFsKCQkLmN0eFtpXSwgKCQkLmN0eFtpXSA9IHZhbHVlKSkpIHtcblx0XHRcdFx0XHRpZiAoISQkLnNraXBfYm91bmQgJiYgJCQuYm91bmRbaV0pICQkLmJvdW5kW2ldKHZhbHVlKTtcblx0XHRcdFx0XHRpZiAocmVhZHkpIG1ha2VfZGlydHkoY29tcG9uZW50LCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdCAgfSlcblx0XHQ6IFtdO1xuXHQkJC51cGRhdGUoKTtcblx0cmVhZHkgPSB0cnVlO1xuXHRydW5fYWxsKCQkLmJlZm9yZV91cGRhdGUpO1xuXHQvLyBgZmFsc2VgIGFzIGEgc3BlY2lhbCBjYXNlIG9mIG5vIERPTSBjb21wb25lbnRcblx0JCQuZnJhZ21lbnQgPSBjcmVhdGVfZnJhZ21lbnQgPyBjcmVhdGVfZnJhZ21lbnQoJCQuY3R4KSA6IGZhbHNlO1xuXHRpZiAob3B0aW9ucy50YXJnZXQpIHtcblx0XHRpZiAob3B0aW9ucy5oeWRyYXRlKSB7XG5cdFx0XHRzdGFydF9oeWRyYXRpbmcoKTtcblx0XHRcdC8vIFRPRE86IHdoYXQgaXMgdGhlIGNvcnJlY3QgdHlwZSBoZXJlP1xuXHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0Y29uc3Qgbm9kZXMgPSBjaGlsZHJlbihvcHRpb25zLnRhcmdldCk7XG5cdFx0XHQkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5sKG5vZGVzKTtcblx0XHRcdG5vZGVzLmZvckVhY2goZGV0YWNoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cblx0XHRcdCQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LmMoKTtcblx0XHR9XG5cdFx0aWYgKG9wdGlvbnMuaW50cm8pIHRyYW5zaXRpb25faW4oY29tcG9uZW50LiQkLmZyYWdtZW50KTtcblx0XHRtb3VudF9jb21wb25lbnQoY29tcG9uZW50LCBvcHRpb25zLnRhcmdldCwgb3B0aW9ucy5hbmNob3IpO1xuXHRcdGVuZF9oeWRyYXRpbmcoKTtcblx0XHRmbHVzaCgpO1xuXHR9XG5cdHNldF9jdXJyZW50X2NvbXBvbmVudChwYXJlbnRfY29tcG9uZW50KTtcbn1cblxuZXhwb3J0IGxldCBTdmVsdGVFbGVtZW50O1xuXG5pZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAnZnVuY3Rpb24nKSB7XG5cdFN2ZWx0ZUVsZW1lbnQgPSBjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcblx0XHQvKiogVGhlIFN2ZWx0ZSBjb21wb25lbnQgY29uc3RydWN0b3IgKi9cblx0XHQkJGN0b3I7XG5cdFx0LyoqIFNsb3RzICovXG5cdFx0JCRzO1xuXHRcdC8qKiBUaGUgU3ZlbHRlIGNvbXBvbmVudCBpbnN0YW5jZSAqL1xuXHRcdCQkYztcblx0XHQvKiogV2hldGhlciBvciBub3QgdGhlIGN1c3RvbSBlbGVtZW50IGlzIGNvbm5lY3RlZCAqL1xuXHRcdCQkY24gPSBmYWxzZTtcblx0XHQvKiogQ29tcG9uZW50IHByb3BzIGRhdGEgKi9cblx0XHQkJGQgPSB7fTtcblx0XHQvKiogYHRydWVgIGlmIGN1cnJlbnRseSBpbiB0aGUgcHJvY2VzcyBvZiByZWZsZWN0aW5nIGNvbXBvbmVudCBwcm9wcyBiYWNrIHRvIGF0dHJpYnV0ZXMgKi9cblx0XHQkJHIgPSBmYWxzZTtcblx0XHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIEN1c3RvbUVsZW1lbnRQcm9wRGVmaW5pdGlvbj59IFByb3BzIGRlZmluaXRpb24gKG5hbWUsIHJlZmxlY3RlZCwgdHlwZSBldGMpICovXG5cdFx0JCRwX2QgPSB7fTtcblx0XHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIEZ1bmN0aW9uW10+fSBFdmVudCBsaXN0ZW5lcnMgKi9cblx0XHQkJGwgPSB7fTtcblx0XHQvKiogQHR5cGUge01hcDxGdW5jdGlvbiwgRnVuY3Rpb24+fSBFdmVudCBsaXN0ZW5lciB1bnN1YnNjcmliZSBmdW5jdGlvbnMgKi9cblx0XHQkJGxfdSA9IG5ldyBNYXAoKTtcblxuXHRcdGNvbnN0cnVjdG9yKCQkY29tcG9uZW50Q3RvciwgJCRzbG90cywgdXNlX3NoYWRvd19kb20pIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLiQkY3RvciA9ICQkY29tcG9uZW50Q3Rvcjtcblx0XHRcdHRoaXMuJCRzID0gJCRzbG90cztcblx0XHRcdGlmICh1c2Vfc2hhZG93X2RvbSkge1xuXHRcdFx0XHR0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG5cdFx0XHQvLyBXZSBjYW4ndCBkZXRlcm1pbmUgdXBmcm9udCBpZiB0aGUgZXZlbnQgaXMgYSBjdXN0b20gZXZlbnQgb3Igbm90LCBzbyB3ZSBoYXZlIHRvXG5cdFx0XHQvLyBsaXN0ZW4gdG8gYm90aC4gSWYgc29tZW9uZSB1c2VzIGEgY3VzdG9tIGV2ZW50IHdpdGggdGhlIHNhbWUgbmFtZSBhcyBhIHJlZ3VsYXJcblx0XHRcdC8vIGJyb3dzZXIgZXZlbnQsIHRoaXMgZmlyZXMgdHdpY2UgLSB3ZSBjYW4ndCBhdm9pZCB0aGF0LlxuXHRcdFx0dGhpcy4kJGxbdHlwZV0gPSB0aGlzLiQkbFt0eXBlXSB8fCBbXTtcblx0XHRcdHRoaXMuJCRsW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuXHRcdFx0aWYgKHRoaXMuJCRjKSB7XG5cdFx0XHRcdGNvbnN0IHVuc3ViID0gdGhpcy4kJGMuJG9uKHR5cGUsIGxpc3RlbmVyKTtcblx0XHRcdFx0dGhpcy4kJGxfdS5zZXQobGlzdGVuZXIsIHVuc3ViKTtcblx0XHRcdH1cblx0XHRcdHN1cGVyLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcblx0XHRcdHN1cGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuXHRcdFx0aWYgKHRoaXMuJCRjKSB7XG5cdFx0XHRcdGNvbnN0IHVuc3ViID0gdGhpcy4kJGxfdS5nZXQobGlzdGVuZXIpO1xuXHRcdFx0XHRpZiAodW5zdWIpIHtcblx0XHRcdFx0XHR1bnN1YigpO1xuXHRcdFx0XHRcdHRoaXMuJCRsX3UuZGVsZXRlKGxpc3RlbmVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGFzeW5jIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuXHRcdFx0dGhpcy4kJGNuID0gdHJ1ZTtcblx0XHRcdGlmICghdGhpcy4kJGMpIHtcblx0XHRcdFx0Ly8gV2Ugd2FpdCBvbmUgdGljayB0byBsZXQgcG9zc2libGUgY2hpbGQgc2xvdCBlbGVtZW50cyBiZSBjcmVhdGVkL21vdW50ZWRcblx0XHRcdFx0YXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG5cdFx0XHRcdGlmICghdGhpcy4kJGNuIHx8IHRoaXMuJCRjKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZ1bmN0aW9uIGNyZWF0ZV9zbG90KG5hbWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0XHRcdFx0bGV0IG5vZGU7XG5cdFx0XHRcdFx0XHRjb25zdCBvYmogPSB7XG5cdFx0XHRcdFx0XHRcdGM6IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbWVudCgnc2xvdCcpO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChuYW1lICE9PSAnZGVmYXVsdCcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGF0dHIobm9kZSwgJ25hbWUnLCBuYW1lKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdC8qKlxuXHRcdFx0XHRcdFx0XHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRcblx0XHRcdFx0XHRcdFx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2FuY2hvcl1cblx0XHRcdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0XHRcdG06IGZ1bmN0aW9uIG1vdW50KHRhcmdldCwgYW5jaG9yKSB7XG5cdFx0XHRcdFx0XHRcdFx0aW5zZXJ0KHRhcmdldCwgbm9kZSwgYW5jaG9yKTtcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZDogZnVuY3Rpb24gZGVzdHJveShkZXRhY2hpbmcpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoZGV0YWNoaW5nKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRkZXRhY2gobm9kZSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0ICQkc2xvdHMgPSB7fTtcblx0XHRcdFx0Y29uc3QgZXhpc3Rpbmdfc2xvdHMgPSBnZXRfY3VzdG9tX2VsZW1lbnRzX3Nsb3RzKHRoaXMpO1xuXHRcdFx0XHRmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy4kJHMpIHtcblx0XHRcdFx0XHRpZiAobmFtZSBpbiBleGlzdGluZ19zbG90cykge1xuXHRcdFx0XHRcdFx0JCRzbG90c1tuYW1lXSA9IFtjcmVhdGVfc2xvdChuYW1lKV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoY29uc3QgYXR0cmlidXRlIG9mIHRoaXMuYXR0cmlidXRlcykge1xuXHRcdFx0XHRcdC8vIHRoaXMuJCRkYXRhIHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0aGlzLmF0dHJpYnV0ZXNcblx0XHRcdFx0XHRjb25zdCBuYW1lID0gdGhpcy4kJGdfcChhdHRyaWJ1dGUubmFtZSk7XG5cdFx0XHRcdFx0aWYgKCEobmFtZSBpbiB0aGlzLiQkZCkpIHtcblx0XHRcdFx0XHRcdHRoaXMuJCRkW25hbWVdID0gZ2V0X2N1c3RvbV9lbGVtZW50X3ZhbHVlKG5hbWUsIGF0dHJpYnV0ZS52YWx1ZSwgdGhpcy4kJHBfZCwgJ3RvUHJvcCcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBQb3J0IG92ZXIgcHJvcHMgdGhhdCB3ZXJlIHNldCBwcm9ncmFtbWF0aWNhbGx5IGJlZm9yZSBjZSB3YXMgaW5pdGlhbGl6ZWRcblx0XHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gdGhpcy4kJHBfZCkge1xuXHRcdFx0XHRcdGlmICghKGtleSBpbiB0aGlzLiQkZCkgJiYgdGhpc1trZXldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHRoaXMuJCRkW2tleV0gPSB0aGlzW2tleV07IC8vIGRvbid0IHRyYW5zZm9ybSwgdGhlc2Ugd2VyZSBzZXQgdGhyb3VnaCBKYXZhU2NyaXB0XG5cdFx0XHRcdFx0XHRkZWxldGUgdGhpc1trZXldOyAvLyByZW1vdmUgdGhlIHByb3BlcnR5IHRoYXQgc2hhZG93cyB0aGUgZ2V0dGVyL3NldHRlclxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLiQkYyA9IG5ldyB0aGlzLiQkY3Rvcih7XG5cdFx0XHRcdFx0dGFyZ2V0OiB0aGlzLnNoYWRvd1Jvb3QgfHwgdGhpcyxcblx0XHRcdFx0XHRwcm9wczoge1xuXHRcdFx0XHRcdFx0Li4udGhpcy4kJGQsXG5cdFx0XHRcdFx0XHQkJHNsb3RzLFxuXHRcdFx0XHRcdFx0JCRzY29wZToge1xuXHRcdFx0XHRcdFx0XHRjdHg6IFtdXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyBSZWZsZWN0IGNvbXBvbmVudCBwcm9wcyBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdGNvbnN0IHJlZmxlY3RfYXR0cmlidXRlcyA9ICgpID0+IHtcblx0XHRcdFx0XHR0aGlzLiQkciA9IHRydWU7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gdGhpcy4kJHBfZCkge1xuXHRcdFx0XHRcdFx0dGhpcy4kJGRba2V5XSA9IHRoaXMuJCRjLiQkLmN0eFt0aGlzLiQkYy4kJC5wcm9wc1trZXldXTtcblx0XHRcdFx0XHRcdGlmICh0aGlzLiQkcF9kW2tleV0ucmVmbGVjdCkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBhdHRyaWJ1dGVfdmFsdWUgPSBnZXRfY3VzdG9tX2VsZW1lbnRfdmFsdWUoXG5cdFx0XHRcdFx0XHRcdFx0a2V5LFxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuJCRkW2tleV0sXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy4kJHBfZCxcblx0XHRcdFx0XHRcdFx0XHQndG9BdHRyaWJ1dGUnXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdGlmIChhdHRyaWJ1dGVfdmFsdWUgPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMucmVtb3ZlQXR0cmlidXRlKHRoaXMuJCRwX2Rba2V5XS5hdHRyaWJ1dGUgfHwga2V5KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSh0aGlzLiQkcF9kW2tleV0uYXR0cmlidXRlIHx8IGtleSwgYXR0cmlidXRlX3ZhbHVlKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLiQkciA9IGZhbHNlO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHR0aGlzLiQkYy4kJC5hZnRlcl91cGRhdGUucHVzaChyZWZsZWN0X2F0dHJpYnV0ZXMpO1xuXHRcdFx0XHRyZWZsZWN0X2F0dHJpYnV0ZXMoKTsgLy8gb25jZSBpbml0aWFsbHkgYmVjYXVzZSBhZnRlcl91cGRhdGUgaXMgYWRkZWQgdG9vIGxhdGUgZm9yIGZpcnN0IHJlbmRlclxuXG5cdFx0XHRcdGZvciAoY29uc3QgdHlwZSBpbiB0aGlzLiQkbCkge1xuXHRcdFx0XHRcdGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy4kJGxbdHlwZV0pIHtcblx0XHRcdFx0XHRcdGNvbnN0IHVuc3ViID0gdGhpcy4kJGMuJG9uKHR5cGUsIGxpc3RlbmVyKTtcblx0XHRcdFx0XHRcdHRoaXMuJCRsX3Uuc2V0KGxpc3RlbmVyLCB1bnN1Yik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuJCRsID0ge307XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gV2UgZG9uJ3QgbmVlZCB0aGlzIHdoZW4gd29ya2luZyB3aXRoaW4gU3ZlbHRlIGNvZGUsIGJ1dCBmb3IgY29tcGF0aWJpbGl0eSBvZiBwZW9wbGUgdXNpbmcgdGhpcyBvdXRzaWRlIG9mIFN2ZWx0ZVxuXHRcdC8vIGFuZCBzZXR0aW5nIGF0dHJpYnV0ZXMgdGhyb3VnaCBzZXRBdHRyaWJ1dGUgZXRjLCB0aGlzIGlzIGhlbHBmdWxcblx0XHRhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ciwgX29sZFZhbHVlLCBuZXdWYWx1ZSkge1xuXHRcdFx0aWYgKHRoaXMuJCRyKSByZXR1cm47XG5cdFx0XHRhdHRyID0gdGhpcy4kJGdfcChhdHRyKTtcblx0XHRcdHRoaXMuJCRkW2F0dHJdID0gZ2V0X2N1c3RvbV9lbGVtZW50X3ZhbHVlKGF0dHIsIG5ld1ZhbHVlLCB0aGlzLiQkcF9kLCAndG9Qcm9wJyk7XG5cdFx0XHR0aGlzLiQkYz8uJHNldCh7IFthdHRyXTogdGhpcy4kJGRbYXR0cl0gfSk7XG5cdFx0fVxuXG5cdFx0ZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG5cdFx0XHR0aGlzLiQkY24gPSBmYWxzZTtcblx0XHRcdC8vIEluIGEgbWljcm90YXNrLCBiZWNhdXNlIHRoaXMgY291bGQgYmUgYSBtb3ZlIHdpdGhpbiB0aGUgRE9NXG5cdFx0XHRQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcblx0XHRcdFx0aWYgKCF0aGlzLiQkY24pIHtcblx0XHRcdFx0XHR0aGlzLiQkYy4kZGVzdHJveSgpO1xuXHRcdFx0XHRcdHRoaXMuJCRjID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQkJGdfcChhdHRyaWJ1dGVfbmFtZSkge1xuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0T2JqZWN0LmtleXModGhpcy4kJHBfZCkuZmluZChcblx0XHRcdFx0XHQoa2V5KSA9PlxuXHRcdFx0XHRcdFx0dGhpcy4kJHBfZFtrZXldLmF0dHJpYnV0ZSA9PT0gYXR0cmlidXRlX25hbWUgfHxcblx0XHRcdFx0XHRcdCghdGhpcy4kJHBfZFtrZXldLmF0dHJpYnV0ZSAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gYXR0cmlidXRlX25hbWUpXG5cdFx0XHRcdCkgfHwgYXR0cmlidXRlX25hbWVcblx0XHRcdCk7XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgQ3VzdG9tRWxlbWVudFByb3BEZWZpbml0aW9uPn0gcHJvcHNfZGVmaW5pdGlvblxuICogQHBhcmFtIHsndG9BdHRyaWJ1dGUnIHwgJ3RvUHJvcCd9IFt0cmFuc2Zvcm1dXG4gKi9cbmZ1bmN0aW9uIGdldF9jdXN0b21fZWxlbWVudF92YWx1ZShwcm9wLCB2YWx1ZSwgcHJvcHNfZGVmaW5pdGlvbiwgdHJhbnNmb3JtKSB7XG5cdGNvbnN0IHR5cGUgPSBwcm9wc19kZWZpbml0aW9uW3Byb3BdPy50eXBlO1xuXHR2YWx1ZSA9IHR5cGUgPT09ICdCb29sZWFuJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJyA/IHZhbHVlICE9IG51bGwgOiB2YWx1ZTtcblx0aWYgKCF0cmFuc2Zvcm0gfHwgIXByb3BzX2RlZmluaXRpb25bcHJvcF0pIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0gZWxzZSBpZiAodHJhbnNmb3JtID09PSAndG9BdHRyaWJ1dGUnKSB7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRjYXNlICdPYmplY3QnOlxuXHRcdFx0Y2FzZSAnQXJyYXknOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IG51bGwgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG5cdFx0XHRjYXNlICdCb29sZWFuJzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlID8gJycgOiBudWxsO1xuXHRcdFx0Y2FzZSAnTnVtYmVyJzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBudWxsIDogdmFsdWU7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0Y2FzZSAnT2JqZWN0Jzpcblx0XHRcdGNhc2UgJ0FycmF5Jzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlICYmIEpTT04ucGFyc2UodmFsdWUpO1xuXHRcdFx0Y2FzZSAnQm9vbGVhbic6XG5cdFx0XHRcdHJldHVybiB2YWx1ZTsgLy8gY29udmVyc2lvbiBhbHJlYWR5IGhhbmRsZWQgYWJvdmVcblx0XHRcdGNhc2UgJ051bWJlcic6XG5cdFx0XHRcdHJldHVybiB2YWx1ZSAhPSBudWxsID8gK3ZhbHVlIDogdmFsdWU7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKlxuICogVHVybiBhIFN2ZWx0ZSBjb21wb25lbnQgaW50byBhIGN1c3RvbSBlbGVtZW50LlxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHVibGljLmpzJykuQ29tcG9uZW50VHlwZX0gQ29tcG9uZW50ICBBIFN2ZWx0ZSBjb21wb25lbnQgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgQ3VzdG9tRWxlbWVudFByb3BEZWZpbml0aW9uPn0gcHJvcHNfZGVmaW5pdGlvbiAgVGhlIHByb3BzIHRvIG9ic2VydmVcbiAqIEBwYXJhbSB7c3RyaW5nW119IHNsb3RzICBUaGUgc2xvdHMgdG8gY3JlYXRlXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBhY2Nlc3NvcnMgIE90aGVyIGFjY2Vzc29ycyBiZXNpZGVzIHRoZSBvbmVzIGZvciBwcm9wcyB0aGUgY29tcG9uZW50IGhhc1xuICogQHBhcmFtIHtib29sZWFufSB1c2Vfc2hhZG93X2RvbSAgV2hldGhlciB0byB1c2Ugc2hhZG93IERPTVxuICogQHBhcmFtIHsoY2U6IG5ldyAoKSA9PiBIVE1MRWxlbWVudCkgPT4gbmV3ICgpID0+IEhUTUxFbGVtZW50fSBbZXh0ZW5kXVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX2N1c3RvbV9lbGVtZW50KFxuXHRDb21wb25lbnQsXG5cdHByb3BzX2RlZmluaXRpb24sXG5cdHNsb3RzLFxuXHRhY2Nlc3NvcnMsXG5cdHVzZV9zaGFkb3dfZG9tLFxuXHRleHRlbmRcbikge1xuXHRsZXQgQ2xhc3MgPSBjbGFzcyBleHRlbmRzIFN2ZWx0ZUVsZW1lbnQge1xuXHRcdGNvbnN0cnVjdG9yKCkge1xuXHRcdFx0c3VwZXIoQ29tcG9uZW50LCBzbG90cywgdXNlX3NoYWRvd19kb20pO1xuXHRcdFx0dGhpcy4kJHBfZCA9IHByb3BzX2RlZmluaXRpb247XG5cdFx0fVxuXHRcdHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5rZXlzKHByb3BzX2RlZmluaXRpb24pLm1hcCgoa2V5KSA9PlxuXHRcdFx0XHQocHJvcHNfZGVmaW5pdGlvbltrZXldLmF0dHJpYnV0ZSB8fCBrZXkpLnRvTG93ZXJDYXNlKClcblx0XHRcdCk7XG5cdFx0fVxuXHR9O1xuXHRPYmplY3Qua2V5cyhwcm9wc19kZWZpbml0aW9uKS5mb3JFYWNoKChwcm9wKSA9PiB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KENsYXNzLnByb3RvdHlwZSwgcHJvcCwge1xuXHRcdFx0Z2V0KCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy4kJGMgJiYgcHJvcCBpbiB0aGlzLiQkYyA/IHRoaXMuJCRjW3Byb3BdIDogdGhpcy4kJGRbcHJvcF07XG5cdFx0XHR9LFxuXHRcdFx0c2V0KHZhbHVlKSB7XG5cdFx0XHRcdHZhbHVlID0gZ2V0X2N1c3RvbV9lbGVtZW50X3ZhbHVlKHByb3AsIHZhbHVlLCBwcm9wc19kZWZpbml0aW9uKTtcblx0XHRcdFx0dGhpcy4kJGRbcHJvcF0gPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy4kJGM/LiRzZXQoeyBbcHJvcF06IHZhbHVlIH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblx0YWNjZXNzb3JzLmZvckVhY2goKGFjY2Vzc29yKSA9PiB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KENsYXNzLnByb3RvdHlwZSwgYWNjZXNzb3IsIHtcblx0XHRcdGdldCgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuJCRjPy5bYWNjZXNzb3JdO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblx0aWYgKGV4dGVuZCkge1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgLSBhc3NpZ25pbmcgaGVyZSBpcyBmaW5lXG5cdFx0Q2xhc3MgPSBleHRlbmQoQ2xhc3MpO1xuXHR9XG5cdENvbXBvbmVudC5lbGVtZW50ID0gLyoqIEB0eXBlIHthbnl9ICovIChDbGFzcyk7XG5cdHJldHVybiBDbGFzcztcbn1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBTdmVsdGUgY29tcG9uZW50cy4gVXNlZCB3aGVuIGRldj1mYWxzZS5cbiAqXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFtQcm9wcz1hbnldXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFtFdmVudHM9YW55XVxuICovXG5leHBvcnQgY2xhc3MgU3ZlbHRlQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqICMjIyBQUklWQVRFIEFQSVxuXHQgKlxuXHQgKiBEbyBub3QgdXNlLCBtYXkgY2hhbmdlIGF0IGFueSB0aW1lXG5cdCAqXG5cdCAqIEB0eXBlIHthbnl9XG5cdCAqL1xuXHQkJCA9IHVuZGVmaW5lZDtcblx0LyoqXG5cdCAqICMjIyBQUklWQVRFIEFQSVxuXHQgKlxuXHQgKiBEbyBub3QgdXNlLCBtYXkgY2hhbmdlIGF0IGFueSB0aW1lXG5cdCAqXG5cdCAqIEB0eXBlIHthbnl9XG5cdCAqL1xuXHQkJHNldCA9IHVuZGVmaW5lZDtcblxuXHQvKiogQHJldHVybnMge3ZvaWR9ICovXG5cdCRkZXN0cm95KCkge1xuXHRcdGRlc3Ryb3lfY29tcG9uZW50KHRoaXMsIDEpO1xuXHRcdHRoaXMuJGRlc3Ryb3kgPSBub29wO1xuXHR9XG5cblx0LyoqXG5cdCAqIEB0ZW1wbGF0ZSB7RXh0cmFjdDxrZXlvZiBFdmVudHMsIHN0cmluZz59IEtcblx0ICogQHBhcmFtIHtLfSB0eXBlXG5cdCAqIEBwYXJhbSB7KChlOiBFdmVudHNbS10pID0+IHZvaWQpIHwgbnVsbCB8IHVuZGVmaW5lZH0gY2FsbGJhY2tcblx0ICogQHJldHVybnMgeygpID0+IHZvaWR9XG5cdCAqL1xuXHQkb24odHlwZSwgY2FsbGJhY2spIHtcblx0XHRpZiAoIWlzX2Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuXHRcdFx0cmV0dXJuIG5vb3A7XG5cdFx0fVxuXHRcdGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdIHx8ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSA9IFtdKTtcblx0XHRjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdGNvbnN0IGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xuXHRcdFx0aWYgKGluZGV4ICE9PSAtMSkgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1BhcnRpYWw8UHJvcHM+fSBwcm9wc1xuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdCRzZXQocHJvcHMpIHtcblx0XHRpZiAodGhpcy4kJHNldCAmJiAhaXNfZW1wdHkocHJvcHMpKSB7XG5cdFx0XHR0aGlzLiQkLnNraXBfYm91bmQgPSB0cnVlO1xuXHRcdFx0dGhpcy4kJHNldChwcm9wcyk7XG5cdFx0XHR0aGlzLiQkLnNraXBfYm91bmQgPSBmYWxzZTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDdXN0b21FbGVtZW50UHJvcERlZmluaXRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYXR0cmlidXRlXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbcmVmbGVjdF1cbiAqIEBwcm9wZXJ0eSB7J1N0cmluZyd8J0Jvb2xlYW4nfCdOdW1iZXInfCdBcnJheSd8J09iamVjdCd9IFt0eXBlXVxuICovXG4iLCAiLy8gZ2VuZXJhdGVkIGR1cmluZyByZWxlYXNlLCBkbyBub3QgbW9kaWZ5XG5cbi8qKlxuICogVGhlIGN1cnJlbnQgdmVyc2lvbiwgYXMgc2V0IGluIHBhY2thZ2UuanNvbi5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtY29tcGlsZXIjc3ZlbHRlLXZlcnNpb25cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBWRVJTSU9OID0gJzQuMi4xMic7XG5leHBvcnQgY29uc3QgUFVCTElDX1ZFUlNJT04gPSAnNCc7XG4iLCAiaW1wb3J0IHtcblx0cnVuX2FsbCxcblx0c3Vic2NyaWJlLFxuXHRub29wLFxuXHRzYWZlX25vdF9lcXVhbCxcblx0aXNfZnVuY3Rpb24sXG5cdGdldF9zdG9yZV92YWx1ZVxufSBmcm9tICcuLi9pbnRlcm5hbC9pbmRleC5qcyc7XG5cbmNvbnN0IHN1YnNjcmliZXJfcXVldWUgPSBbXTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYFJlYWRhYmxlYCBzdG9yZSB0aGF0IGFsbG93cyByZWFkaW5nIGJ5IHN1YnNjcmlwdGlvbi5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtc3RvcmUjcmVhZGFibGVcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IFt2YWx1ZV0gaW5pdGlhbCB2YWx1ZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHVibGljLmpzJykuU3RhcnRTdG9wTm90aWZpZXI8VD59IFtzdGFydF1cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHVibGljLmpzJykuUmVhZGFibGU8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkYWJsZSh2YWx1ZSwgc3RhcnQpIHtcblx0cmV0dXJuIHtcblx0XHRzdWJzY3JpYmU6IHdyaXRhYmxlKHZhbHVlLCBzdGFydCkuc3Vic2NyaWJlXG5cdH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYFdyaXRhYmxlYCBzdG9yZSB0aGF0IGFsbG93cyBib3RoIHVwZGF0aW5nIGFuZCByZWFkaW5nIGJ5IHN1YnNjcmlwdGlvbi5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtc3RvcmUjd3JpdGFibGVcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IFt2YWx1ZV0gaW5pdGlhbCB2YWx1ZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vcHVibGljLmpzJykuU3RhcnRTdG9wTm90aWZpZXI8VD59IFtzdGFydF1cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHVibGljLmpzJykuV3JpdGFibGU8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cml0YWJsZSh2YWx1ZSwgc3RhcnQgPSBub29wKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlVuc3Vic2NyaWJlcn0gKi9cblx0bGV0IHN0b3A7XG5cdC8qKiBAdHlwZSB7U2V0PGltcG9ydCgnLi9wcml2YXRlLmpzJykuU3Vic2NyaWJlSW52YWxpZGF0ZVR1cGxlPFQ+Pn0gKi9cblx0Y29uc3Qgc3Vic2NyaWJlcnMgPSBuZXcgU2V0KCk7XG5cdC8qKiBAcGFyYW0ge1R9IG5ld192YWx1ZVxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGZ1bmN0aW9uIHNldChuZXdfdmFsdWUpIHtcblx0XHRpZiAoc2FmZV9ub3RfZXF1YWwodmFsdWUsIG5ld192YWx1ZSkpIHtcblx0XHRcdHZhbHVlID0gbmV3X3ZhbHVlO1xuXHRcdFx0aWYgKHN0b3ApIHtcblx0XHRcdFx0Ly8gc3RvcmUgaXMgcmVhZHlcblx0XHRcdFx0Y29uc3QgcnVuX3F1ZXVlID0gIXN1YnNjcmliZXJfcXVldWUubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKGNvbnN0IHN1YnNjcmliZXIgb2Ygc3Vic2NyaWJlcnMpIHtcblx0XHRcdFx0XHRzdWJzY3JpYmVyWzFdKCk7XG5cdFx0XHRcdFx0c3Vic2NyaWJlcl9xdWV1ZS5wdXNoKHN1YnNjcmliZXIsIHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocnVuX3F1ZXVlKSB7XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzdWJzY3JpYmVyX3F1ZXVlLmxlbmd0aDsgaSArPSAyKSB7XG5cdFx0XHRcdFx0XHRzdWJzY3JpYmVyX3F1ZXVlW2ldWzBdKHN1YnNjcmliZXJfcXVldWVbaSArIDFdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3Vic2NyaWJlcl9xdWV1ZS5sZW5ndGggPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlVwZGF0ZXI8VD59IGZuXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0ZnVuY3Rpb24gdXBkYXRlKGZuKSB7XG5cdFx0c2V0KGZuKHZhbHVlKSk7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtpbXBvcnQoJy4vcHVibGljLmpzJykuU3Vic2NyaWJlcjxUPn0gcnVuXG5cdCAqIEBwYXJhbSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5JbnZhbGlkYXRvcjxUPn0gW2ludmFsaWRhdGVdXG5cdCAqIEByZXR1cm5zIHtpbXBvcnQoJy4vcHVibGljLmpzJykuVW5zdWJzY3JpYmVyfVxuXHQgKi9cblx0ZnVuY3Rpb24gc3Vic2NyaWJlKHJ1biwgaW52YWxpZGF0ZSA9IG5vb3ApIHtcblx0XHQvKiogQHR5cGUge2ltcG9ydCgnLi9wcml2YXRlLmpzJykuU3Vic2NyaWJlSW52YWxpZGF0ZVR1cGxlPFQ+fSAqL1xuXHRcdGNvbnN0IHN1YnNjcmliZXIgPSBbcnVuLCBpbnZhbGlkYXRlXTtcblx0XHRzdWJzY3JpYmVycy5hZGQoc3Vic2NyaWJlcik7XG5cdFx0aWYgKHN1YnNjcmliZXJzLnNpemUgPT09IDEpIHtcblx0XHRcdHN0b3AgPSBzdGFydChzZXQsIHVwZGF0ZSkgfHwgbm9vcDtcblx0XHR9XG5cdFx0cnVuKHZhbHVlKTtcblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0c3Vic2NyaWJlcnMuZGVsZXRlKHN1YnNjcmliZXIpO1xuXHRcdFx0aWYgKHN1YnNjcmliZXJzLnNpemUgPT09IDAgJiYgc3RvcCkge1xuXHRcdFx0XHRzdG9wKCk7XG5cdFx0XHRcdHN0b3AgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblx0cmV0dXJuIHsgc2V0LCB1cGRhdGUsIHN1YnNjcmliZSB9O1xufVxuXG4vKipcbiAqIERlcml2ZWQgdmFsdWUgc3RvcmUgYnkgc3luY2hyb25pemluZyBvbmUgb3IgbW9yZSByZWFkYWJsZSBzdG9yZXMgYW5kXG4gKiBhcHBseWluZyBhbiBhZ2dyZWdhdGlvbiBmdW5jdGlvbiBvdmVyIGl0cyBpbnB1dCB2YWx1ZXMuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlLXN0b3JlI2Rlcml2ZWRcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5TdG9yZXN9IFNcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSB7U30gc3RvcmVzIC0gaW5wdXQgc3RvcmVzXG4gKiBAcGFyYW0geyh2YWx1ZXM6IGltcG9ydCgnLi9wcml2YXRlLmpzJykuU3RvcmVzVmFsdWVzPFM+LCBzZXQ6ICh2YWx1ZTogVCkgPT4gdm9pZCwgdXBkYXRlOiAoZm46IGltcG9ydCgnLi9wdWJsaWMuanMnKS5VcGRhdGVyPFQ+KSA9PiB2b2lkKSA9PiBpbXBvcnQoJy4vcHVibGljLmpzJykuVW5zdWJzY3JpYmVyIHwgdm9pZH0gZm4gLSBmdW5jdGlvbiBjYWxsYmFjayB0aGF0IGFnZ3JlZ2F0ZXMgdGhlIHZhbHVlc1xuICogQHBhcmFtIHtUfSBbaW5pdGlhbF92YWx1ZV0gLSBpbml0aWFsIHZhbHVlXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlJlYWRhYmxlPFQ+fVxuICovXG5cbi8qKlxuICogRGVyaXZlZCB2YWx1ZSBzdG9yZSBieSBzeW5jaHJvbml6aW5nIG9uZSBvciBtb3JlIHJlYWRhYmxlIHN0b3JlcyBhbmRcbiAqIGFwcGx5aW5nIGFuIGFnZ3JlZ2F0aW9uIGZ1bmN0aW9uIG92ZXIgaXRzIGlucHV0IHZhbHVlcy5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtc3RvcmUjZGVyaXZlZFxuICogQHRlbXBsYXRlIHtpbXBvcnQoJy4vcHJpdmF0ZS5qcycpLlN0b3Jlc30gU1xuICogQHRlbXBsYXRlIFRcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtIHtTfSBzdG9yZXMgLSBpbnB1dCBzdG9yZXNcbiAqIEBwYXJhbSB7KHZhbHVlczogaW1wb3J0KCcuL3ByaXZhdGUuanMnKS5TdG9yZXNWYWx1ZXM8Uz4pID0+IFR9IGZuIC0gZnVuY3Rpb24gY2FsbGJhY2sgdGhhdCBhZ2dyZWdhdGVzIHRoZSB2YWx1ZXNcbiAqIEBwYXJhbSB7VH0gW2luaXRpYWxfdmFsdWVdIC0gaW5pdGlhbCB2YWx1ZVxuICogQHJldHVybnMge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5SZWFkYWJsZTxUPn1cbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KCcuL3ByaXZhdGUuanMnKS5TdG9yZXN9IFNcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1N9IHN0b3Jlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7VH0gW2luaXRpYWxfdmFsdWVdXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL3B1YmxpYy5qcycpLlJlYWRhYmxlPFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlZChzdG9yZXMsIGZuLCBpbml0aWFsX3ZhbHVlKSB7XG5cdGNvbnN0IHNpbmdsZSA9ICFBcnJheS5pc0FycmF5KHN0b3Jlcyk7XG5cdC8qKiBAdHlwZSB7QXJyYXk8aW1wb3J0KCcuL3B1YmxpYy5qcycpLlJlYWRhYmxlPGFueT4+fSAqL1xuXHRjb25zdCBzdG9yZXNfYXJyYXkgPSBzaW5nbGUgPyBbc3RvcmVzXSA6IHN0b3Jlcztcblx0aWYgKCFzdG9yZXNfYXJyYXkuZXZlcnkoQm9vbGVhbikpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2Rlcml2ZWQoKSBleHBlY3RzIHN0b3JlcyBhcyBpbnB1dCwgZ290IGEgZmFsc3kgdmFsdWUnKTtcblx0fVxuXHRjb25zdCBhdXRvID0gZm4ubGVuZ3RoIDwgMjtcblx0cmV0dXJuIHJlYWRhYmxlKGluaXRpYWxfdmFsdWUsIChzZXQsIHVwZGF0ZSkgPT4ge1xuXHRcdGxldCBzdGFydGVkID0gZmFsc2U7XG5cdFx0Y29uc3QgdmFsdWVzID0gW107XG5cdFx0bGV0IHBlbmRpbmcgPSAwO1xuXHRcdGxldCBjbGVhbnVwID0gbm9vcDtcblx0XHRjb25zdCBzeW5jID0gKCkgPT4ge1xuXHRcdFx0aWYgKHBlbmRpbmcpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y2xlYW51cCgpO1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gZm4oc2luZ2xlID8gdmFsdWVzWzBdIDogdmFsdWVzLCBzZXQsIHVwZGF0ZSk7XG5cdFx0XHRpZiAoYXV0bykge1xuXHRcdFx0XHRzZXQocmVzdWx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsZWFudXAgPSBpc19mdW5jdGlvbihyZXN1bHQpID8gcmVzdWx0IDogbm9vcDtcblx0XHRcdH1cblx0XHR9O1xuXHRcdGNvbnN0IHVuc3Vic2NyaWJlcnMgPSBzdG9yZXNfYXJyYXkubWFwKChzdG9yZSwgaSkgPT5cblx0XHRcdHN1YnNjcmliZShcblx0XHRcdFx0c3RvcmUsXG5cdFx0XHRcdCh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdHZhbHVlc1tpXSA9IHZhbHVlO1xuXHRcdFx0XHRcdHBlbmRpbmcgJj0gfigxIDw8IGkpO1xuXHRcdFx0XHRcdGlmIChzdGFydGVkKSB7XG5cdFx0XHRcdFx0XHRzeW5jKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQoKSA9PiB7XG5cdFx0XHRcdFx0cGVuZGluZyB8PSAxIDw8IGk7XG5cdFx0XHRcdH1cblx0XHRcdClcblx0XHQpO1xuXHRcdHN0YXJ0ZWQgPSB0cnVlO1xuXHRcdHN5bmMoKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gc3RvcCgpIHtcblx0XHRcdHJ1bl9hbGwodW5zdWJzY3JpYmVycyk7XG5cdFx0XHRjbGVhbnVwKCk7XG5cdFx0XHQvLyBXZSBuZWVkIHRvIHNldCB0aGlzIHRvIGZhbHNlIGJlY2F1c2UgY2FsbGJhY2tzIGNhbiBzdGlsbCBoYXBwZW4gZGVzcGl0ZSBoYXZpbmcgdW5zdWJzY3JpYmVkOlxuXHRcdFx0Ly8gQ2FsbGJhY2tzIG1pZ2h0IGFscmVhZHkgYmUgcGxhY2VkIGluIHRoZSBxdWV1ZSB3aGljaCBkb2Vzbid0IGtub3cgaXQgc2hvdWxkIG5vIGxvbmdlclxuXHRcdFx0Ly8gaW52b2tlIHRoaXMgZGVyaXZlZCBzdG9yZS5cblx0XHRcdHN0YXJ0ZWQgPSBmYWxzZTtcblx0XHR9O1xuXHR9KTtcbn1cblxuLyoqXG4gKiBUYWtlcyBhIHN0b3JlIGFuZCByZXR1cm5zIGEgbmV3IG9uZSBkZXJpdmVkIGZyb20gdGhlIG9sZCBvbmUgdGhhdCBpcyByZWFkYWJsZS5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUtc3RvcmUjcmVhZG9ubHlcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5SZWFkYWJsZTxUPn0gc3RvcmUgIC0gc3RvcmUgdG8gbWFrZSByZWFkb25seVxuICogQHJldHVybnMge2ltcG9ydCgnLi9wdWJsaWMuanMnKS5SZWFkYWJsZTxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRvbmx5KHN0b3JlKSB7XG5cdHJldHVybiB7XG5cdFx0c3Vic2NyaWJlOiBzdG9yZS5zdWJzY3JpYmUuYmluZChzdG9yZSlcblx0fTtcbn1cblxuZXhwb3J0IHsgZ2V0X3N0b3JlX3ZhbHVlIGFzIGdldCB9O1xuIiwgImltcG9ydCB7IHdyaXRhYmxlIH0gZnJvbSBcInN2ZWx0ZS9zdG9yZVwiO1xuaW1wb3J0IHR5cGUgT2JzaWRpYW5DaGF0R1BUUGx1Z2luIGZyb20gXCIuL21haW5cIjtcblxuY29uc3QgcGx1Z2luID0gd3JpdGFibGU8T2JzaWRpYW5DaGF0R1BUUGx1Z2luPigpO1xuZXhwb3J0IGRlZmF1bHQgeyBwbHVnaW4gfTtcbiIsICJpbXBvcnQgeyBQVUJMSUNfVkVSU0lPTiB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC92ZXJzaW9uLmpzJztcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKVxuXHQvLyBAdHMtaWdub3JlXG5cdCh3aW5kb3cuX19zdmVsdGUgfHwgKHdpbmRvdy5fX3N2ZWx0ZSA9IHsgdjogbmV3IFNldCgpIH0pKS52LmFkZChQVUJMSUNfVkVSU0lPTik7XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQSxvREFBQUEsU0FBQTtBQUFBO0FBQ0EsSUFBQUEsUUFBTyxV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LEtBQUssS0FBSyxJQUFJLEtBQUssS0FBSyxJQUFJLEtBQUssS0FBSyxJQUFJLEtBQUssS0FBSyxJQUFJLEtBQUssS0FBSztBQUN0RSxTQUFRLFVBQVcsTUFBTSxLQUFNLEVBQUksSUFDL0IsVUFBVyxNQUFNLEtBQU0sRUFBSSxJQUMzQixVQUFXLE1BQU0sS0FBTSxFQUFJLElBQzNCLFVBQVcsTUFBTSxLQUFNLEVBQUksSUFDM0IsVUFBVyxNQUFNLEtBQU0sRUFBSSxJQUMzQixVQUFXLE1BQU0sSUFBSyxFQUFJLElBQzFCLFVBQVcsTUFBTSxJQUFLLEVBQUksSUFDMUIsVUFBVSxLQUFLLEVBQUksSUFDbkIsVUFBVyxNQUFNLEtBQU0sRUFBSSxJQUMzQixVQUFXLE1BQU0sS0FBTSxFQUFJLElBQzNCLFVBQVcsTUFBTSxLQUFNLEVBQUksSUFDM0IsVUFBVyxNQUFNLEtBQU0sRUFBSSxJQUMzQixVQUFXLE1BQU0sS0FBTSxFQUFJLElBQzNCLFVBQVcsTUFBTSxJQUFLLEVBQUksSUFDMUIsVUFBVyxNQUFNLElBQUssRUFBSSxJQUMxQixVQUFVLEtBQUssRUFBSSxJQUNuQixVQUFXLE1BQU0sS0FBTSxFQUFJLElBQzNCLFVBQVcsTUFBTSxLQUFNLEVBQUksSUFDM0IsVUFBVyxNQUFNLEtBQU0sRUFBSSxJQUMzQixVQUFXLE1BQU0sS0FBTSxFQUFJLElBQzNCLFVBQVcsTUFBTSxLQUFNLEVBQUksSUFDM0IsVUFBVyxNQUFNLElBQUssRUFBSSxJQUMxQixVQUFXLE1BQU0sSUFBSyxFQUFJLElBQzFCLFVBQVUsS0FBSyxFQUFJLElBQ25CLFVBQVcsTUFBTSxLQUFNLEVBQUksSUFDM0IsVUFBVyxNQUFNLEtBQU0sRUFBSSxJQUMzQixVQUFXLE1BQU0sS0FBTSxFQUFJLElBQzNCLFVBQVcsTUFBTSxLQUFNLEVBQUksSUFDM0IsVUFBVyxNQUFNLEtBQU0sRUFBSSxJQUMzQixVQUFXLE1BQU0sSUFBSyxFQUFJLElBQzFCLFVBQVcsTUFBTSxJQUFLLEVBQUksSUFDMUIsVUFBVSxLQUFLLEVBQUksSUFDbkIsVUFBVyxN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ZTtBQUNuQixTQUFLLFdBQVcsT0FBTyxPQUFPLENBQUMsR0FBRyxrQkFBa0IsTUFBTSxLQUFLLFNBQVMsQ0FBQztBQUN6RSxTQUFLLGtCQUFrQixLQUFLLGlCQUFpQjtBQUM3QyxTQUFLLGFBQWE7QUFBQSxFQUNwQjtBQUFBLEVBRUEsTUFBTSxlQUFlO0FBQ25CLFNBQUssYUFBYTtBQUNsQixVQUFNLEtBQUssU0FBUyxLQUFLLFFBQVE7QUFBQSxFQUNuQztBQUNGOyIsCiAgIm5hbWVzIjogWyJtb2R1bGUiLCAibW9kdWxlIiwgImNhbWVsQ2FzZSIsICJtb2R1bGUiLCAic3R5bGVzIiwgIm1vZHVsZSIsICJzZWxmIiwgIm9yaWdpbmFsIiwgInJlcXVpcmVfcmV0cnkiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJwUmV0cnkiLCAiZXJyb3IiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAicnVuIiwgImVsZW1lbnQiLCAibm93IiwgInJ1biIsICJsZW4iLCAiaSIsICJsZW4yIiwgImltcG9ydF9vYnNpZGlhbiIsICJwbHVnaW4iLCAidGV4dCIsICJzbmFrZUNhc2UiLCAicm9vdCIsICJydW4iLCAibGxtIiwgInRleHQiLCAidGV4dCIsICJydW4iLCAiZWxhcHNlZCIsICJzdHlsZXMiLCAiUFF1ZXVlTW9kIiwgInBSZXRyeSIsICJpc0Jyb3dzZXIiLCAiaXNXZWJXb3JrZXIiLCAiaXNKc0RvbSIsICJpc0Rlbm8iLCAiaXNOb2RlIiwgImdldEVudiIsICJydW50aW1lRW52aXJvbm1lbnQiLCAiZ2V0UnVudGltZUVudmlyb25tZW50IiwgImdldEVudmlyb25tZW50VmFyaWFibGUiLCAiZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSIsICJnZXRSdW50aW1lRW52aXJvbm1lbnQiLCAicnVuIiwgImdldEVudmlyb25tZW50VmFyaWFibGUiLCAicmVzdWx0IiwgInJ1biIsICJ2YWx1ZSIsICJfYSIsICJfYiIsICJpbXBvcnRfcF9xdWV1ZSIsICJQUXVldWVNb2QiLCAidGV4dCIsICJlcnIiLCAibGxtIiwgImJsb2NrcyIsICJpbXBvcnRfcF9yZXRyeSIsICJpbXBvcnRfcF9xdWV1ZSIsICJTVEFUVVNfTk9fUkVUUlkiLCAiQXN5bmNDYWxsZXIiLCAiUFF1ZXVlTW9kIiwgInBSZXRyeSIsICJfX2RlZlByb3AiLCAiX19kZWZOb3JtYWxQcm9wIiwgIl9fcHVibGljRmllbGQiLCAiYmFzZTY0IiwgInRleHQiLCAiX19wdWJsaWNGaWVsZCIsICJBc3luY0NhbGxlciIsICJpbXBvcnRfcF9yZXRyeSIsICJ2YWxpZGF0ZSIsICJrZXlzIiwgImkiLCAiZG9jdW1lbnQiLCAidmFsaWRhdGUiLCAiYnVmZmVyIiwgInJ1biIsICJfYSIsICJydW4iLCAiX2EiLCAiX2NvZXJjZVRvRGljdCIsICJjYWxsZXIiLCAiQXN5bmNDYWxsZXIiLCAic3RhdGUiLCAicFJldHJ5IiwgInJlc3VsdCIsICJfYSIsICJfY29lcmNlVG9EaWN0IiwgIkFzeW5jQ2FsbGVyIiwgImNhY2hlIiwgInRleHQiLCAidGV4dCIsICJlbGVtZW50IiwgIl9hIiwgImVsZW1lbnQiLCAiYXR0ciIsICJzdWJzY3JpYmUiLCAicnVuIl0KfQo=
